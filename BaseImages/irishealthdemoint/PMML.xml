<?xml version="1.0" encoding="UTF-8"?>
<Export generator="IRIS" version="26">
<Class name="%DeepSee.PMML.Builder.AbstractBuilder">
<IncludeCode>%PMML</IncludeCode>
<Super>%SerialObject</Super>
<System>4</System>
<TimeCreated>62860,56356.130465</TimeCreated>

<Parameter name="MODELCLASSNAME">
<Type>CLASSNAME</Type>
</Parameter>

<Property name="Dataset">
<Type>%DeepSee.PMML.Dataset</Type>
<Transient>1</Transient>
</Property>

<Property name="TargetField">
<Type>%String</Type>
</Property>

<Property name="Description">
<Type>%String</Type>
</Property>

<Property name="ModelName">
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="FunctionName">
<Type>%String</Type>
<InitialExpression>"classification"</InitialExpression>
</Property>

<Property name="AlgorithmName">
<Type>%String</Type>
</Property>

<Property name="OutputProbability">
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="DataSources">
<Type>%DeepSee.PMML.Definition.Extension.DataSource</Type>
<Collection>list</Collection>
</Property>

<Method name="GeneratePMML">
<Final>1</Final>
<FormalSpec>*pPMML:%DeepSee.PMML.Definition.PMML</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set pPMML = ##class(%DeepSee.PMML.Definition.PMML).%Create("4.1", ..Description, $classname())
		
		// append ..DataSources
		set tExtension = ##class(%DeepSee.PMML.Definition.Extension).%New()
		set tExtension.name = "isc:datasource"
		for i = 1:1:..DataSources.Count() {
			do tExtension.iscExtensions.Insert(..DataSources.GetAt(i))
		}
		do pPMML.DataDictionary.Extension.Insert(tExtension)
		
		set tSC = ..AppendModel(.pPMML, 1)
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="AppendModel">
<Final>1</Final>
<FormalSpec><![CDATA[&pPMML:%DeepSee.PMML.Definition.PMML,pAddUnknownFields:%Boolean=1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		if '$isobject(..Dataset) {
			set tSC = $$$ERROR($$$GeneralError, "No Dataset registered for this builder")
			quit:$$$ISERR(tSC)
		}
		
		if (..TargetField="") {
			set tSC = $$$ERROR($$$GeneralError, "No TargetField registered for this builder")
			quit
		}
		
		// 1: check pPMML and generate field name dictionary
		if '$isobject(pPMML) {
			set tSC = $$$ERROR($$$GeneralError, "No PMML to append to. Initialize first or call GeneratePMML()")
			quit
		}
		set tSC = pPMML.DataDictionary.%GetDictionary(.tFieldList)
		quit:$$$ISERR(tSC)
		set tSC = pPMML.TransformationDictionary.%ValidateNames(.tFieldList)
		quit:$$$ISERR(tSC)
		
		
		// 2: data dictionary & miningfields
		set tMiningSchema = ##class(%DeepSee.PMML.Definition.MiningSchema).%New()
		set tFieldName = ""
		for {
			#dim tField As %DeepSee.PMML.Dataset.Field
			set tField = ..Dataset.Fields.GetNext(.tFieldName)
			quit:tFieldName=""
			
			if $d(tFieldList("fields", tField.Name)) {
				// known field
			} elseif 'pAddUnknownFields {
				set tSC = $$$ERROR($$$GeneralError, "Unknown field name: '"_tField.Name_"'")
				quit
			} else {
				set tDataField = ##class(%DeepSee.PMML.Definition.DataField).%New()
				set tDataField.name = tField.Name
				set tDataField.optype = tField.OpType
				set tDataField.dataType = tField.DataType
				set tDataField.displayName = tField.DisplayName
				do pPMML.DataDictionary.AddField(tDataField)
			
				// if there's only 15 members or less, we'll add Value elements
				if (tField.OpType'="continuous") {
					set tSC = ..Dataset.Get1DDistribution(tField.Name, .tFieldValues)
					quit:$$$ISERR(tSC)
					if $g(tFieldValues)<=15 {
						for i = 1:1:$g(tFieldValues) {
							set tFieldValue = $li($g(tFieldValues(i)),1)
							set tValue = ##class(%DeepSee.PMML.Definition.Util.Value).%New()
							set tValue.value = tFieldValue
							set tValue.property = $s(tFieldValue="":"missing", 1:"valid")
							do tDataField.Values.Insert(tValue)
						}
					}
				}
			}
			
			// mining field
			set tMiningField = ##class(%DeepSee.PMML.Definition.MiningField).%New()
			set tMiningField.name = tField.Name
			set tMiningField.usageType = $s(tField.Name=..TargetField:$$$PMMLusageTypePredicted, 1:$$$PMMLusageTypeActive)
			do tMiningSchema.MiningFields.Insert(tMiningField)
		}
		quit:$$$ISERR(tSC)
		
		// Append builder spec as <Extension>
		set tExtension = ##class(%DeepSee.PMML.Definition.Extension).%New()
		set tExtension.name = "isc:datasource"
		set tSC = ..Dataset.GetPMMLDataSource(.tDataSourceSpec)
		quit:$$$ISERR(tSC)
		set tDataSourceSpec.name = "Training dataset"_$s(pPMML.Models.Count():" "_(pPMML.Models.Count()+1), 1:"")
		set tDataSourceSpec.description = "Dataset used to train model '"_..ModelName_"'"
		do tExtension.iscExtensions.Insert(tDataSourceSpec)
		do pPMML.DataDictionary.Extension.Insert(tExtension)
		
		
		// 4: model definition
		set tModel = $classmethod(..#MODELCLASSNAME, "%New")
		set tModel.modelName = ..ModelName
		set tModel.functionName = ..FunctionName
		set tModel.algorithmName = ..AlgorithmName
		set tModel.MiningSchema = tMiningSchema
		
		set tSC = ..BuildModel(.tModel)
		quit:$$$ISERR(tSC)
		
		if (..OutputProbability) {
			set tModel.Output = ##class(%DeepSee.PMML.Definition.Output).%New()
			set tOutputField = ##class(%DeepSee.PMML.Definition.OutputField).%New()
			set tOutputField.name = "predicted value"
			set tOutputField.feature = "predictedValue"
			do tModel.Output.OutputFields.Insert(tOutputField)
			set tOutputField = ##class(%DeepSee.PMML.Definition.OutputField).%New()
			set tOutputField.name = "probability"
			set tOutputField.feature = "probability"
			do tModel.Output.OutputFields.Insert(tOutputField)
		}
		
		do pPMML.Models.Insert(tModel)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="BuildModel">
<Abstract>1</Abstract>
<FormalSpec><![CDATA[&pModel:%DeepSee.PMML.Definition.Models.AbstractModel]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	quit $$$OK
]]></Implementation>
</Method>

<Method name="AddDataSourceCube">
<Description>
Registers an additional DeepSee-based Data Source so it will be added to the generated PMML's
DataDictionary section and can subsequently be used for validation purposes.
Expected field mapping format: pFieldMap([fieldName]) = [DeepSee spec]</Description>
<FormalSpec><![CDATA[pName:%String,pCubeName:%String,&pFieldMap,pFilter:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tDataSource = ##class(%DeepSee.PMML.Definition.Extension.DeepSeeDataSource).%New()
		set tDataSource.cubeName = pCubeName
		set tDataSource.filter = pFilter
		
		set tFieldName = ""
		for {
			set tFieldName = $order(pFieldMap(tFieldName), 1, tSpec)
			quit:tFieldName=""
			set tMap = ##class(%DeepSee.PMML.Definition.Extension.FieldMap).%New()
			set tMap.fieldName = tFieldName
			set tMap.spec = tSpec
			do tDataSource.Fields.Insert(tMap)
		}
		
		set tSC = ..DataSources.Insert(tDataSource)
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="AddDataSourceSQL">
<Description>
Registers an additional SQL-based Data Source so it will be added to the generated PMML's
DataDictionary section and can subsequently be used for validation purposes.
Expected field mapping format: pFieldMap([fieldName]) = [column name]</Description>
<FormalSpec><![CDATA[pName:%String,pSQL:%String,&pFieldMap,pIdField:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tDataSource = ##class(%DeepSee.PMML.Definition.Extension.SQLDataSource).%New()
		set tDataSource.name = pName
		set tDataSource.SQL = pSQL
		set tDataSource.idField = pIdField
		
		set tFieldName = ""
		for {
			set tFieldName = $order(pFieldMap(tFieldName), 1, tColumnName)
			quit:tFieldName=""
			set tMap = ##class(%DeepSee.PMML.Definition.Extension.FieldMap).%New()
			set tMap.fieldName = tFieldName
			set tMap.spec = tColumnName
			do tDataSource.Fields.Insert(tMap)
		}
		
		set tSC = ..DataSources.Insert(tDataSource)
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Serial</Type>
<State>AbstractBuilderState</State>
<StreamLocation>^%DeepSee.PMML.Builder.AbstractBuilderS</StreamLocation>
<Data name="AbstractBuilderState">
<Value name="1">
<Value>TargetField</Value>
</Value>
<Value name="2">
<Value>Description</Value>
</Value>
<Value name="3">
<Value>ModelName</Value>
</Value>
<Value name="4">
<Value>FunctionName</Value>
</Value>
<Value name="5">
<Value>AlgorithmName</Value>
</Value>
<Value name="6">
<Value>OutputProbability</Value>
</Value>
<Value name="7">
<Value>DataSources</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%DeepSee.PMML.Builder.NaiveBayes">
<Super>%DeepSee.PMML.Builder.AbstractBuilder</Super>
<System>4</System>
<TimeCreated>62860,56375.21212</TimeCreated>

<Parameter name="MODELCLASSNAME">
<Default>%DeepSee.PMML.Definition.Models.NaiveBayesModel</Default>
</Parameter>

<Property name="Threshold">
<Type>%Numeric</Type>
<InitialExpression>0.0001</InitialExpression>
</Property>

<Method name="BuildModel">
<FormalSpec><![CDATA[&pModel:%DeepSee.PMML.Definition.Models.AbstractModel]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		// simple attributes
		set pModel.threshold = ..Threshold
		
		// <BayesOutput>
		set pModel.BayesOutput = ##class(%DeepSee.PMML.Definition.Models.NaiveBayes.BayesOutput).%New()
		set pModel.BayesOutput.fieldName = ..TargetField
		set pModel.BayesOutput.TargetValueCounts = ##class(%DeepSee.PMML.Definition.Models.NaiveBayes.TargetValueCounts).%New()
		
		set tSC = ..Dataset.Get1DDistribution(..TargetField, .tDistribution)
		quit:$$$ISERR(tSC)
		
		for i = 1:1:$g(tDistribution) {
			set tMemberKey = $li(tDistribution(i),1), tCount = $li(tDistribution(i),2)
			continue:(tMemberKey="")||'tCount
			
			set tTVCount = ##class(%DeepSee.PMML.Definition.Models.NaiveBayes.TargetValueCount).%New()
			set tTVCount.value = tMemberKey
			set tTVCount.count = tCount
			do pModel.BayesOutput.TargetValueCounts.Counts.Insert(tTVCount)
		}
		
		// <BayesInputs>
		set pModel.BayesInputs = ##class(%DeepSee.PMML.Definition.Models.NaiveBayes.BayesInputs).%New()
		set tFieldName = ""
		for {
			set tField = ..Dataset.Fields.GetNext(.tFieldName)
			quit:tFieldName=""
			continue:tFieldName=..TargetField
			
			set tBayesInput = ##class(%DeepSee.PMML.Definition.Models.NaiveBayes.BayesInput).%New()
			set tBayesInput.fieldName = tFieldName
			
			set tSC = ..Dataset.GetXDDistribution($lb(..TargetField, tFieldName), .tDistribution)
			quit:$$$ISERR(tSC)
			set tTargetValueCount = $g(tDistribution("value",1))
			set tFieldValueCount = $g(tDistribution("value",2))
			for j = 1:1:tFieldValueCount {
				set tFieldValue = tDistribution("value",2,j)
				continue:tFieldValue=""
				
				set tPairCounts = ##class(%DeepSee.PMML.Definition.Models.NaiveBayes.PairCounts).%New()
				set tPairCounts.value = tFieldValue
				set tPairCounts.TargetValueCounts = ##class(%DeepSee.PMML.Definition.Models.NaiveBayes.TargetValueCounts).%New()
				
				for k = 1:1:tTargetValueCount {
					set tTargetValue = tDistribution("value",1,k)
					continue:tTargetValue=""
					
					set tResultCount = $g(tDistribution(k,j))
					continue:'tResultCount
					
					set tTVCount = ##class(%DeepSee.PMML.Definition.Models.NaiveBayes.TargetValueCount).%New()
					set tTVCount.value = tTargetValue
					set tTVCount.count = tResultCount
					do tPairCounts.TargetValueCounts.Counts.Insert(tTVCount)
				}
				do tBayesInput.PairCounts.Insert(tPairCounts)
			}
			
			do pModel.BayesInputs.BayesInput.Insert(tBayesInput)
		}
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Serial</Type>
<Data name="AbstractBuilderState">
<Value name="1">
<Value>TargetField</Value>
</Value>
<Value name="2">
<Value>Description</Value>
</Value>
<Value name="3">
<Value>ModelName</Value>
</Value>
<Value name="4">
<Value>FunctionName</Value>
</Value>
<Value name="5">
<Value>AlgorithmName</Value>
</Value>
<Value name="6">
<Value>OutputProbability</Value>
</Value>
<Value name="7">
<Value>Threshold</Value>
</Value>
<Value name="8">
<Value>DataSources</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%DeepSee.PMML.Builder.Text">
<IncludeCode>%IKPublic</IncludeCode>
<Super>%DeepSee.PMML.Builder.AbstractBuilder</Super>
<System>4</System>
<TimeCreated>62907,68015.920433</TimeCreated>

<Parameter name="MODELCLASSNAME">
<Default>%DeepSee.PMML.Definition.Models.TextModel</Default>
</Parameter>

<Property name="EntityCount">
<Type>%String</Type>
<InitialExpression>50</InitialExpression>
</Property>

<Property name="InputLanguages">
<Type>%String</Type>
</Property>

<Property name="InputType">
<Description>
Whether the model should have separate DataFields for each term or a single containing the whole text</Description>
<Type>%String</Type>
<InitialExpression>"text"</InitialExpression>
<Parameter name="VALUELIST" value=",text,terms"/>
</Property>

<Property name="TermWeightsLocal">
<Type>%String</Type>
<InitialExpression>"termFrequency"</InitialExpression>
<Parameter name="VALUELIST" value=",termFrequency,binary,logarithmic,augmentedNormalizedTermFrequency"/>
</Property>

<Property name="TermWeightsGlobal">
<Type>%String</Type>
<InitialExpression>"inverseDocumentFrequency"</InitialExpression>
<Parameter name="VALUELIST" value=",inverseDocumentFrequency,none,GFIDF,normal,probabilisticInverse"/>
</Property>

<Property name="TermWeightsDocumentNormalization">
<Type>%String</Type>
<InitialExpression>"none"</InitialExpression>
<Parameter name="VALUELIST" value=",none,cosine"/>
</Property>

<Property name="SimilarityType">
<Type>%String</Type>
<InitialExpression>"cosine"</InitialExpression>
<Parameter name="VALUELIST" value=",euclidian,cosine"/>
</Property>

<Property name="TermSelectionMetric">
<Type>%String</Type>
<Parameter name="VALUELIST" value=",NaiveBayes,BM25"/>
</Property>

<UDLText name="T">
<Content><![CDATA[
// (VALUELIST = ",Document Frequency,DIA association factor,Information Gain,Mutual Information,Chi-square,NGL coefficient,Relevancy score,Odds Ratio,GSS coefficient");

]]></Content>
</UDLText>

<Method name="BuildModel">
<FormalSpec><![CDATA[&pModel:%DeepSee.PMML.Definition.Models.AbstractModel]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		// define input mapping
		set tInput = ##class(%DeepSee.PMML.Definition.Extension.TextModelInput).%New()
		set tInput.inputType = ..InputType
		set tInput.Fields = ##class(%DeepSee.PMML.Definition.Util.Array).%New()
		set tInput.Fields.type = "string"
		set tFieldName = "", tTextFields="", tCount = 0
		for {
			set tFieldName = ..Dataset.Fields.Next(tFieldName)
			quit:tFieldName=""
			continue:tFieldName=..TargetField
			set tTextFields = tTextFields _ " " _ $$$QUOTE(tFieldName)
			set x = $i(tCount)
		}
		set tTextFields = $e(tTextFields, 2, *)
		if (..InputType = "text") {
			set tInput.Fields.Values = tTextFields
			set tInput.Fields.n = tCount
		}
		// if input mode is terms, we'll have to replace the DataField and MiningField entries
		elseif (..InputType = "terms") {
			// TODO
			set tSC = $$$ERROR($$$NotImplemented)
			quit:$$$ISERR(tSC)
		}
		set tExtension = ##class(%DeepSee.PMML.Definition.Extension).%New()
		do tExtension.iscExtensions.Insert(tInput)
		do pModel.Extension.Insert(tExtension)
		
		// append Normalization and Similarity nodes
		set tNormalization = ##class(%DeepSee.PMML.Definition.Models.Text.Normalization).%New()
		set tNormalization.documentNormalization = ..TermWeightsDocumentNormalization
		set tNormalization.globalTermWeights = ..TermWeightsGlobal
		set tNormalization.localTermWeights = ..TermWeightsLocal
		set pModel.Normalization = tNormalization
		
		set tSimilarity = ##class(%DeepSee.PMML.Definition.Models.Text.Similarity).%New()
		set tSimilarity.similarityType = ..SimilarityType
		set pModel.Similarity = tSimilarity
		
		
		// build Corpus
		set tCorpus = ##class(%DeepSee.PMML.Definition.Models.Text.Corpus).%New()
		set tSC = ..Dataset.Get1DDistribution(..TargetField, .tCategories)
		quit:$$$ISERR(tSC)
		set tDocumentCount = +$g(tCategories)
		set pModel.numberOfDocuments = tDocumentCount
		for i = 1:1:tDocumentCount {
			set tCategory = $li(tCategories(i),1)
			set tDocument = ##class(%DeepSee.PMML.Definition.Models.Text.Document).%New()
			set:tCategory="" tCategory = "[null]", $li(tCategories(i),1) = "[null]" // TODO
			set tDocument.name = tCategory
			set tDocument.id = tCategory // or i?
			do tCorpus.Documents.Insert(tDocument)
		}
		set pModel.Corpus = tCorpus
		
		
		// now load data into a temporary iKnow domain
		set tConfigName = $classname()_"#"_$job
		do:##class(%iKnow.Configuration).NameIndexExists(tConfigName) ##class(%iKnow.Configuration).%DeleteId(##class(%iKnow.Configuration).NameIndexOpen(tConfigName).Id)
		set tConfig = ##class(%iKnow.Configuration).%New(tConfigName, $l(..InputLanguages,",")>1, $s(..InputLanguages="":"en", 1:..InputLanguages),, 0)
		set tSC = tConfig.%Save()
		quit:$$$ISERR(tSC)
		set tDomainName = $classname()_"#"_$job
		do:##class(%iKnow.Domain).NameIndexExists(tDomainName) ##class(%iKnow.Domain).%DeleteId(##class(%iKnow.Domain).NameIndexOpen(tDomainName).Id)
		set tDomain = ##class(%iKnow.Domain).%New(tDomainName)
		set tSC = tDomain.%Save()
		quit:$$$ISERR(tSC)
		set tSC = tDomain.SetParameter($$$IKPIGNOREEMPTYBATCH, 1)
		quit:$$$ISERR(tSC)
		set tFieldId = ##class(%iKnow.Queries.MetadataAPI).AddField(tDomain.Id, "Category",,, $$$MDSTBITMAP,,,,, .tSC)
		quit:$$$ISERR(tSC)
		
		#dim tResultSet As %SQL.StatementResult
		set tSC = ..Dataset.GetAsResultSet($lfs($e(tTextFields,2,*-1),""" """)_$lb(..TargetField), .tResultSet)
		quit:$$$ISERR(tSC)
		kill ^IRIS.Temp.PMML.StageText(+$j)
		set tCount = 0, tFieldCount = $l(tTextFields,",")
		while tResultSet.%Next() {
			set x = $i(tCount), tHasData = 0
			for i = 1:1:tFieldCount {
				set tText = tResultSet.%GetData(i)
				continue:tText=""
				set tHasData = 1
				set ^IRIS.Temp.PMML.StageText(+$j, tCount, i) = tText
			}
			set:tHasData ^IRIS.Temp.PMML.StageText(+$j, tCount) = $lb(tResultSet.%GetData(tFieldCount+1))
		}
		quit:$$$ISERR(tSC)
		
		set tLister = ##class(%iKnow.Source.Global.Lister).%New(tDomain.Id)
		set tSC = tLister.SetConfig(tConfigName)
		quit:$$$ISERR(tSC)
		set tSC = tLister.SetProcessor(, $lb(2, $c(13,10,13,10), $lb("Category")))
		quit:$$$ISERR(tSC)
		set tSC = tLister.AddListToBatch("^IRIS.Temp.PMML.StageText("_+$j_")")
		quit:$$$ISERR(tSC)
		
		set tLoader = ##class(%iKnow.Source.Loader).%New(tDomain.Id)
		set tSC = tLoader.ProcessBatch()
		quit:$$$ISERR(tSC)
		
		set tFilters = tDocumentCount
		for i = 1:1:tDocumentCount {
			set tFilters(i) = ##class(%iKnow.Filters.SimpleMetadataFilter).%New(tDomain.Id, "Category", "=", $li(tCategories(i),1))
		}
		
		
		// now find the best overall indicators
		if (..TermSelectionMetric = "NaiveBayes") {
			set tSC = ..GetEntitiesByNBProb(tDomain.Id, .tFilters)
			quit:$$$ISERR(tSC)
		} elseif (..TermSelectionMetric = "BM25") {
			set tSC = ..GetEntitiesByBM25(tDomain.Id)
			quit:$$$ISERR(tSC)
		} else {
			set tSC = $$$ERROR($$$GeneralError, "Unsupported term selection metric: '"_..TermSelectionMetric_"'")
			quit
		}
		// TODO: implement alternative techniques
		
		
		kill tEntities
		set tScore="", tEntities=0
		for {
			set tScore = $order(^||%PMML.EntSorted(tScore))
			quit:tScore=""
			set tEntityId = ""
			for {
				set tEntityId = $order(^||%PMML.EntSorted(tScore, tEntityId))
				quit:tEntityId=""
				quit:$i(tEntities)>..EntityCount
				set tEntityIds(tEntities) = tEntityId
				set tEntities(tEntities) = ##class(%iKnow.Queries.EntityAPI).GetValue(tDomain.Id, tEntityId)
			}
			quit:tEntities>..EntityCount
		}
		set tEntityCount = tEntities-1
		kill ^||%PMML.EntSorted
		
		// build dictionary based on tEntities
		set pModel.numberOfTerms = tEntityCount
		set tDictionary = ##class(%DeepSee.PMML.Definition.Models.Text.Dictionary).%New()
		set tDictionary.Terms = ##class(%DeepSee.PMML.Definition.Util.Array).%New()
		set tDictionary.Terms.type = "string"
		set tDictionary.Terms.n = tEntityCount
		set tEntityValues = ""
		for i = 1:1:tEntityCount {
			set tEntityValues = tEntityValues _ " " _ $$$QUOTE(tEntities(i))
		}
		set tDictionary.Terms.Values = $e(tEntityValues, 2, *)
		set pModel.Dictionary = tDictionary
		
		
		// build documentTermMatrix based on tEntities and tFilters
		set tMatrix = ##class(%DeepSee.PMML.Definition.Util.Matrix).%New()
		set tMatrix.nbCols = tEntityCount
		set tMatrix.nbRows = tDocumentCount
		set tMatrix.diagDefault = 0
		set tMatrix.offDiagDefault = 0
		for i = 1:1:tEntityCount {
			set tEntUniId = tEntityIds(i)
			for j = 1:1:tDocumentCount {
				set tSpread = ##class(%iKnow.Queries.EntityAPI).GetSpread(tDomain.Id, tEntUniId,, tFilters(j), .tSC)
				quit:$$$ISERR(tSC)
				set tFreq = ##class(%iKnow.Queries.EntityAPI).GetFrequency(tDomain.Id, tEntUniId,,, tFilters(j), .tSC)
				quit:$$$ISERR(tSC)
				continue:'tFreq
				set tCell = ##class(%DeepSee.PMML.Definition.Util.MatCell).%New()
				set tCell.row = j, tCell.col = i
				set tCell.value = $fnumber(tFreq/tFilters(j).FilteredSourceCount,"",2)
				//set tCell.value = tSpread
				do tMatrix.Cells.Insert(tCell)
			}
			quit:$$$ISERR(tSC)
		}
		quit:$$$ISERR(tSC)
		set tDTMatrix = ##class(%DeepSee.PMML.Definition.Models.Text.DocumentTermMatrix).%New()
		set tDTMatrix.Matrix = tMatrix
		set pModel.DocumentTermMatrix = tDTMatrix
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	
	// clean up temporary domain and config
	if $d(tDomainName) {
		set tDomain = ##class(%iKnow.Domain).NameIndexOpen(tDomainName)
		if $isobject(tDomain) {
			do tDomain.DropData(1,1,1)
			do tDomain.%DeleteId(tDomain.Id)
			set tDomain = ""
		}
	}
	if $d(tConfigName) {
		set tConfig = ##class(%iKnow.Configuration).NameIndexOpen(tConfigName)
		if $isobject(tConfig) {
			do tConfig.%DeleteId(tConfig.Id)
			set tConfig = ""
		}
	}
	kill ^IRIS.Temp.PMML.StageText(+$j)
	
	quit tSC
]]></Implementation>
</Method>

<Method name="GetEntitiesByNBProb">
<FormalSpec><![CDATA[pDomainId:%Integer,&pFilters]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		for i = 1:1:pFilters {
			set tSC = ##class(%iKnow.Analytics.NaiveBayesClassifier).GetEntityProbabilities(pDomainId, pFilters(i), .tProbabilities, ..EntityCount\pFilters)
			quit:$$$ISERR(tSC)
			
			set tEntityId = ""
			for {
				set tEntityId = $order(tProbabilities(tEntityId), 1, tProb)
				quit:tEntityId=""
				set tScore = $s(tProb<0.5:1-tProb, 1:tProb)-0.5
				continue:tScore=0.5
				set tEntProbs(tEntityId, i) = tScore
				//set tSpread = ##class(%iKnow.Queries.EntityAPI).GetSpread(tDomain.Id, tEntityId)
				//set tScore = tScore * tSpread
				//set tEntProbs(tEntityId) = $g(tEntProbs(tEntityId)) + tScore
			}
		}
		quit:$$$ISERR(tSC)
		
		kill ^||%PMML.EntSorted
		set tEntityId = ""
		for {
			set tEntityId = $order(tEntProbs(tEntityId))
			quit:tEntityId=""
			set tTotal = 0
			for i = 1:1:pFilters {
				if '$d(tEntProbs(tEntityId,i),tScore) {
					set tProb = ##class(%iKnow.Analytics.NaiveBayesClassifier).GetEntityProbability(pDomainId, tEntityId, pFilters(i))
					set tScore = $s(tProb<0.5:1-tProb, 1:tProb)-0.5
					continue:tScore=0.5
					set tEntProbs(tEntityId,i) = tScore
				}
				set tTotal = tTotal+(tScore*tFilters(i).FilteredSourceCount)
			}
			set ^||%PMML.EntSorted(-tTotal, tEntityId) = ""
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="GetEntitiesByBM25">
<FormalSpec>pDomainId:%Integer,pEntType:%Integer=$$$ENTTYPECONCEPT</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		/*
		b = 0.75 (smoothing)
		k1 = 1.6 (tuning)
		
		BM25(tf) = termFreq [* (k1 + 1)] / (k1 * ((1-b) + b * docLength / avgDocLength) + termFreq) * [RSJ|IDF]
		RSJ = log( (spreadFilter + 0.5) * (DCsample - DCfilter - spreadSample + spreadFilter + 0.5) / ( (spreadSample - spreadFilter + 0.5) * (DCfilter - spreadFilter + 0.5) ) )
		IDF = log( (DC - spread + 0.5) / (spread + 0.5) )
		*/
		
		set b = 0.75, k1 = 1.6
		set tDocCount = ##class(%iKnow.Queries.SourceAPI).GetCountByDomain(pDomainId)
		set tEntOccCount = ##class(%iKnow.Queries.EntityAPI).GetOccurrenceCountByDomain(pDomainId,, pEntType)
		set tAvgDocLength = tEntOccCount / tDocCount
		
		kill ^||%PMML.EntIDF
		set tEntUniId = ""
		for {
			set tEntUniId = $order(^ISC.IK.EntUniDetails(pDomainId, tEntUniId), 1, tDetails)
			quit:tEntUniId=""
			
			set tSpread = $lg(tDetails, $case(pEntType, $$$ENTTYPEANY:3, $$$ENTTYPECONCEPT:4, $$$ENTTYPERELATION:5))
			continue:tSpread<=1
			set ^||%PMML.EntIDF(tEntUniId) = $zlog((tDocCount - tSpread + 0.5) / (tSpread + 0.5))
		}
		
		if (pEntType = $$$ENTTYPEANY) {
			set tSrcId=""
			for {
				set tSrcId = $order(^ISC.IK.SrcDetails(pDomainId,tSrcId), 1, tDetails)
				quit:tSrcId=""
				
				set tDocLengths(tSrcId) = $lg(tDetails,4)
			}
		}
		
		kill ^||%PMML.EntBM25
		set tSrcId = ""
		for {
			set tSrcId = $order(^ISC.IK.EntSrcDetails(pDomainId, tSrcId))
			quit:tSrcId=""
			
			kill tSrcEnts
			merge tSrcEnts = ^ISC.IK.EntSrcDetails(pDomainId, tSrcId)
			
			if (pEntType=$$$ENTTYPEANY) {
				set tDocLength = tDocLengths(tSrcId)
			} else {
				set tDocLength = 0
				set tEntUniId = ""
				for {
					set tEntUniId = $order(tSrcEnts(tEntUniId), 1, tDetails)
					quit:tEntUniId=""
					
					set tFrequency = $case(pEntType, $$$ENTTYPEANY:$lg(tDetails,1)+$lg(tDetails,2), $$$ENTTYPECONCEPT:$lg(tDetails,1), $$$ENTTYPERELATION:$lg(tDetails,2))
					set x = $i(tDocLength, tFrequency)
				}
			}
			
			set tEntUniId = ""
			for {
				set tEntUniId = $order(tSrcEnts(tEntUniId), 1, tDetails)
				quit:tEntUniId=""
				
				set tFrequency = $case(pEntType, $$$ENTTYPEANY:$lg(tDetails,1)+$lg(tDetails,2), $$$ENTTYPECONCEPT:$lg(tDetails,1), $$$ENTTYPERELATION:$lg(tDetails,2))
				continue:'tFrequency
				
				set tBM25 = tFrequency / (k1 * ((1-b) + b * (tDocLength / tAvgDocLength)) + tFrequency)
				set x = $i(^||%PMML.EntBM25(tEntUniId), tBM25)
			}
		}
		
		kill ^||%PMML.EntSorted
		set tEntUniId = ""
		for {
			set tEntUniId = $order(^||%PMML.EntIDF(tEntUniId), 1, tIDF)
			quit:tEntUniId=""
			
			set ^||%PMML.EntSorted(-tIDF * ^||%PMML.EntBM25(tEntUniId), tEntUniId) = ""
		}

	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	kill ^||%PMML.EntIDF, ^||%PMML.EntBM25
	quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Serial</Type>
<Data name="AbstractBuilderState">
<Value name="1">
<Value>TargetField</Value>
</Value>
<Value name="2">
<Value>Description</Value>
</Value>
<Value name="3">
<Value>ModelName</Value>
</Value>
<Value name="4">
<Value>FunctionName</Value>
</Value>
<Value name="5">
<Value>AlgorithmName</Value>
</Value>
<Value name="6">
<Value>OutputProbability</Value>
</Value>
<Value name="7">
<Value>EntityCount</Value>
</Value>
<Value name="8">
<Value>TermWeightsLocal</Value>
</Value>
<Value name="9">
<Value>TermWeightsGlobal</Value>
</Value>
<Value name="10">
<Value>TermWeightsDocumentNormalization</Value>
</Value>
<Value name="11">
<Value>SimilarityType</Value>
</Value>
<Value name="12">
<Value>Mode</Value>
</Value>
<Value name="13">
<Value>InputLanguages</Value>
</Value>
<Value name="14">
<Value>InputType</Value>
</Value>
<Value name="15">
<Value>DataSources</Value>
</Value>
<Value name="16">
<Value>TermSelectionMetric</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%DeepSee.PMML.Builder.Tree">
<Super>%DeepSee.PMML.Builder.AbstractBuilder</Super>
<System>4</System>
<TimeCreated>62866,42206.414672</TimeCreated>

<Parameter name="MODELCLASSNAME">
<Default>%DeepSee.PMML.Definition.Models.TreeModel</Default>
</Parameter>

<Property name="CustomTree">
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="MaxTreeDepth">
<Type>%Integer</Type>
<InitialExpression>3</InitialExpression>
</Property>

<Property name="ScoringMetric">
<Type>%String</Type>
<InitialExpression>"GiniImpurity"</InitialExpression>
<Parameter name="VALUELIST" value=",Confidence,GiniImpurity,InformationGain"/>
</Property>

<Property name="MissingValueStrategy">
<Type>%String</Type>
<InitialExpression>"none"</InitialExpression>
<Parameter name="VALUELIST" value=",none,lastPrediction,nullPrediction,defaultChild,weightedConfidence,aggregateNodes"/>
</Property>

<Property name="MissingValuePenalty">
<Type>%Double</Type>
<InitialExpression>1.0</InitialExpression>
</Property>

<Property name="NoTrueChildStrategy">
<Type>%String</Type>
<InitialExpression>"returnNullPrediction"</InitialExpression>
<Parameter name="VALUELIST" value=",returnNullPrediction,returnLastPrediction"/>
</Property>

<Method name="BuildModel">
<FormalSpec><![CDATA[&pModel:%DeepSee.PMML.Definition.Models.AbstractModel]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if $d(..CustomTree) { 
			merge tTree = ..CustomTree
		} else {
			set tTreeBuilder = ##class(%DeepSee.PMML.Utils.TreeBuilder).%New(..Dataset, ..TargetField)
			if '$isobject(tTreeBuilder) { set tSC = %objlasterror  quit }
			set tTreeBuilder.TrackDistributions = 1
			set tTreeBuilder.SplitScoringAlgorithm = ..ScoringMetric
		
			set tSC = tTreeBuilder.Build(..MaxTreeDepth)
			quit:$$$ISERR(tSC)
			
			merge tTree = tTreeBuilder.Tree
		}
		
		// transform tree into <Node> elements
		set tSC = ..CreateNodeElement(.tTree, 0, .tNodeElement)
		quit:$$$ISERR(tSC)
		
		set pModel.Node = tNodeElement
		set pModel.splitCharacteristic = $s(tTreeBuilder.SplitsPerNode=2:"binarySplit", 1:"multiSplit")
		set pModel.noTrueChildStrategy = ..NoTrueChildStrategy
		set pModel.missingValueStrategy = ..MissingValueStrategy
		set pModel.missingValuePenalty = ..MissingValuePenalty
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="CreateNodeElement">
<FormalSpec><![CDATA[&pTree,pNodeId:%Integer,*pNodeElement:%DeepSee.PMML.Definition.Models.Trees.TreeNode]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		if '$d(pTree(pNodeId), tDetails) {
			set tSC =$$$ERROR($$$GeneralError, "Node "_pNodeId_" not found in tree")
			quit
		}
		
		set pNodeElement = ##class(%DeepSee.PMML.Definition.Models.Trees.TreeNode).%New()
		set pNodeElement.id = pNodeId
		set pNodeElement.recordCount = $li(tDetails, 4)
		
		// create predicate for node split condition
		kill tCondition
		merge tCondition = pTree(pNodeId, "condition")
		set tSC = ..CreatePredicateElement(.tCondition, .tPredicate)
		quit:$$$ISERR(tSC)
		set pNodeElement.Predicate = tPredicate
		
		
		// append score distributions
		set tValue = ""
		for {
			set tValue = $order(pTree(pNodeId, "distribution", tValue), 1, tCount)
			quit:tValue=""
			continue:tValue=$c(0)
			continue:'tCount
			
			set tDistribution = ##class(%DeepSee.PMML.Definition.Models.Trees.ScoreDistribution).%New()
			set tDistribution.recordCount = tCount
			set tDistribution.value = $s(tValue=$c(0):"", 1:tValue)
			set tDistribution.probability = tCount / $li(tDetails, 4)
			do pNodeElement.ScoreDistributions.Insert(tDistribution)
		}
		
		
		// append child nodes
		set tChildNodeId = ""
		for {
			set tChildNodeId = $order(pTree(pNodeId,"ch",tChildNodeId))
			quit:tChildNodeId=""
			
			set tSC = ..CreateNodeElement(.pTree, tChildNodeId, .tChildNodeElement)
			quit:$$$ISERR(tSC)
			
			do pNodeElement.Subnodes.Insert(tChildNodeElement)
		}
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="CreatePredicateElement">
<FormalSpec><![CDATA[&pCondition,*pPredicate:%DeepSee.PMML.Definition.Util.Predicate]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK, pPredicate=""
	try {
		if '$d(pCondition) {
			set pPredicate = ##class(%DeepSee.PMML.Definition.Util.True).%New()
			quit
		}
		
		if $listvalid(pCondition) {
			set pPredicate = ##class(%DeepSee.PMML.Definition.Util.SimplePredicate).%New()
			set pPredicate.field = $li(pCondition, 1)
			if ($li(pCondition,3)="") {
				set pPredicate.operator = $s($li(pCondition,2)="=":"isMissing", 1:"isNotMissing")
			} else {
				do pPredicate.SetOperatorSymbol($li(pCondition, 2))
				set pPredicate.value = $li(pCondition, 3)
			}
			quit
		}
		
		set pPredicate = ##class(%DeepSee.PMML.Definition.Util.CompoundPredicate).%New()
		set pPredicate.booleanOperator = $$$LOWER(pCondition)
		
		set i = ""
		for {
			set i = $order(pCondition(i))
			quit:i=""
			
			kill tSubCondition
			merge tSubCondition = pCondition(i)
			set tSC = ..CreatePredicateElement(.tSubCondition, .tSubPredicate)
			quit:$$$ISERR(tSC)
			
			do pPredicate.Predicates.Insert(tSubPredicate)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Serial</Type>
<Data name="AbstractBuilderState">
<Value name="1">
<Value>TargetField</Value>
</Value>
<Value name="2">
<Value>Description</Value>
</Value>
<Value name="3">
<Value>ModelName</Value>
</Value>
<Value name="4">
<Value>FunctionName</Value>
</Value>
<Value name="5">
<Value>AlgorithmName</Value>
</Value>
<Value name="6">
<Value>OutputProbability</Value>
</Value>
<Value name="7">
<Value>ScoringMetric</Value>
</Value>
<Value name="8">
<Value>MaxTreeDepth</Value>
</Value>
<Value name="9">
<Value>MissingValueStrategy</Value>
</Value>
<Value name="10">
<Value>MissingValuePenalty</Value>
</Value>
<Value name="11">
<Value>NoTrueChildStrategy</Value>
</Value>
<Value name="12">
<Value>DataSources</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%DeepSee.PMML.Data">
<Description><![CDATA[
Represents a single "record" of data for the models defined in a <class>%DeepSee.PMML.Definition</class>
class. A subclass of this class is generated upon compiling a PMML definition, which can then
be instantiated to run the predictive models against. See the %Execute method in 
<class>%DeepSee.PMML.Model.AbstractModel</class> for more details.]]></Description>
<Abstract>1</Abstract>
<IncludeCode>%PMML</IncludeCode>
<IncludeGenerator>%PMML</IncludeGenerator>
<Super>%SerialObject</Super>
<System>3</System>
<TimeCreated>62739,40555.168165</TimeCreated>

<Property name="%Properties">
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Method name="%SetPropertyStatus">
<Internal>1</Internal>
<FormalSpec>pProperty:%String,pStatus:%String(VALUELIST=",valid,invalid,missing,predicted")</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ..%Properties($$$PROPERTYNAME(pProperty)) = pStatus
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetPropertyValue">
<Internal>1</Internal>
<FormalSpec>pProperty:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit $property($this, $$$PROPERTYNAME(pProperty))
]]></Implementation>
</Method>

<Method name="%SetPropertyValue">
<Internal>1</Internal>
<FormalSpec>pProperty:%String,pValue:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set $property($this, $$$PROPERTYNAME(pProperty)) = pValue
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetPropertyStatus">
<FormalSpec>pProperty:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// first ensure the property's getter is invoked (for derived fields)
	set x = $property($this, $$$PROPERTYNAME(pProperty))
	quit $g(..%Properties($$$PROPERTYNAME(pProperty)),"missing")
]]></Implementation>
</Method>

<Method name="%IsMissing">
<FormalSpec>pProperty:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	quit (..%GetPropertyStatus(pProperty)="missing")
]]></Implementation>
</Method>

<Method name="%IsInvalid">
<FormalSpec>pProperty:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	quit (..%GetPropertyStatus(pProperty)="invalid")
]]></Implementation>
</Method>

<Method name="%CreateFromArray">
<Description>
Instantiates an object from this class based on the values in the supplied array.</Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pArray,*pSC:%Status=$$$OK]]></FormalSpec>
<ReturnType>%DeepSee.PMML.Data</ReturnType>
<Implementation><![CDATA[
	set tObj = ..%New()
	if (tObj="") { set pSC = %objlasterror  quit "" }
	set pSC = tObj.%LoadData(.pArray)
	quit $s($$$ISERR(pSC):"", 1:tObj)
]]></Implementation>
</Method>

<Method name="%LoadData">
<Description>
Loads the property values in the supplied array, overwriting existing values for those properties.</Description>
<Internal>1</Internal>
<Abstract>1</Abstract>
<FormalSpec><![CDATA[&pArray]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// implementation generated by %DeepSee.PMML.Definition.%CreateClasses
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%CreateFromObject">
<Description>
Instantiates an object from this class based on the property values of the supplied object.</Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>pObject,*pSC:%Status=$$$OK</FormalSpec>
<ReturnType>%DeepSee.PMML.Data</ReturnType>
<Implementation><![CDATA[
	set tObj = ..%New()
	if (tObj="") { set pSC = %objlasterror  quit "" }
	set pSC = tObj.%LoadObject(pObject)
	quit $s($$$ISERR(pSC):"", 1:tObj)
]]></Implementation>
</Method>

<Method name="%LoadObject">
<Description>
Loads the property values from the supplied object, overwriting existing values for those properties.</Description>
<Internal>1</Internal>
<Abstract>1</Abstract>
<FormalSpec>pObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// implementation generated by %DeepSee.PMML.Definition.%CreateClasses
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%ResetDerivedFields">
<Internal>1</Internal>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// implementation generated by %DeepSee.PMML.Definition.%CreateClasses
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetAsArray">
<Description>
Loads all data fields into pArray, which ensures their *Get methods are invoked so
their values are populated and status info is available.</Description>
<Internal>1</Internal>
<Abstract>1</Abstract>
<FormalSpec>*pArray,*pStatus,pSkipMissing:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// implementation generated by %DeepSee.PMML.Definition.%CreateClasses
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetDerivedFields">
<Description>
Loads all derived fields into pArray, which ensures their *Get methods are invoked so
their values are populated and status info is available.</Description>
<Internal>1</Internal>
<FormalSpec><![CDATA[&pArray=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// implementation generated by %DeepSee.PMML.Definition.%CreateClasses
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%CreateFromDeepSee">
<Description><![CDATA[
Instantiates an object from this class based on the dimension level and measure values
of a DeepSee fact, using the mapping described in <var>pDataSource</var> ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFactId:%Integer,*pData:%DeepSee.PMML.Data,pDataSource:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// implementation generated by %DeepSee.PMML.Definition.%CreateClasses
	// (if DeepSee cube info available)
	quit $$$ERROR($$$GeneralError, "No DeepSee DataSource mapping found: '"_pDataSource_"'")
]]></Implementation>
</Method>

<Method name="%GetDeepSeeSpec">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pPropertyName:%String,pDataSource:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// implementation generated by %DeepSee.PMML.Definition.%CreateClasses
	// (if DeepSee cube info available)
	quit ""
]]></Implementation>
</Method>

<Method name="%CreateFromResultSet">
<Description><![CDATA[
Instantiates an object of this class based on the <i>current</i> record of the supplied
ResultSet object. If a <var>pFieldMap</var> is supplied, it takes precedence over the value
of <var>pDataSource</var> for mapping the ResultSet's columns to data fields.]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pResultSet:%SQL.StatementResult,*pData:%DeepSee.PMML.Data,&pFieldMap,pDataSource:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// implementation generated by %DeepSee.PMML.Definition.%CreateClasses
	// (if SQL Query info available)
	quit $$$ERROR($$$GeneralError, "No SQL result set mapping found: '"_pDataSource_"'")
]]></Implementation>
</Method>

<Method name="%GetResultSetColumn">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pPropertyName:%String,pDataSource:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// implementation generated by %DeepSee.PMML.Definition.%CreateClasses
	// (if SQL Query info available)
	quit pPropertyName
]]></Implementation>
</Method>

<Method name="%CreateDataset">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDataSource:%String="",*pDataset:%DeepSee.PMML.Dataset</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// implementation generated by %DeepSee.PMML.Definition.%CreateClasses based on DataSource info (extension)
	quit $$$ERROR($$$NotImplemented)
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Serial</Type>
<StreamLocation>^%DeepSee.PMML.DataS</StreamLocation>
</Storage>
</Class>


<Class name="%DeepSee.PMML.Dataset.Array">
<Description>
Dataset implementation for a simple local array / inline table containing the actual data,
primarily for use with ModelVerification records in the PMML spec.
NOTE: This class does not implement the whole %DeepSee.PMML.Dataset spec!</Description>
<Hidden>1</Hidden>
<Super>%DeepSee.PMML.Dataset</Super>
<System>4</System>
<TimeCreated>62885,45377.036697</TimeCreated>

<Property name="Data">
<Description>
..Data([record ID], [field spec]) = [value]</Description>
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="%CreateFromModelValidation">
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String,pModelVerification:%DeepSee.PMML.Definition.ModelVerification,*pSC:%Status</FormalSpec>
<ReturnType>%DeepSee.PMML.Dataset.Array</ReturnType>
<Implementation><![CDATA[
	set pSC = $$$OK, tObj = ""
	try {
		set tObj = ..%New()
		set tObj.Name = pName
		set tObj.IdField = ""
		
	} catch (ex) {
		set pSC = ex.AsStatus()
	}
	quit $s($$$ISERR(pSC):"", 1:tObj)
]]></Implementation>
</Method>

<Method name="Get1DDistribution">
<Description>
accepts
	pFilters(n) = $lb(field, operator, key)
returns:
	pDistribution("total") = tTotalCount
	pDistribution(n) = $lb(value, count)</Description>
<FormalSpec><![CDATA[pField:%String,*pDistribution,&pFilters]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	quit:$d(pFilters) $$$ERROR($$$NotImplemented)
	
	set tSC = $$$OK
	try {
		kill pDistribution
		set tColId = ..Fields.GetAt(pField).Spec
		
		set tRecordId = ""
		for {
			set tRecordId = $order(..Data(tRecordId))
			quit:tRecordId=""
			
			set tValue = ..Data(tRecordId,tColId)
			set:tValue="" tValue = $c(0)
			set x = $i(tValues(tValue))
		}
		
		set tValue=""
		for {
			set tValue = $order(tValues(tValue),1,tCount)
			quit:tValue=""
			
			set pDistribution($i(pDistribution)) = $lb(tValue, tCount)
			set x = $i(pDistribution("total"), tCount)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="GetRecordIds">
<Description>
returns pIds(n) = rowid</Description>
<FormalSpec><![CDATA[*pIds,&pFilters]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	quit:$d(pFilters) $$$ERROR($$$NotImplemented)
	
	set tSC = $$$OK
	try {
		kill pIds
		
		set tRecordId = ""
		for {
			set tRecordId = $order(..Data(tRecordId))
			quit:tRecordId=""
			
			set pIds($i(pIds)) = tRecordId
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="GetValueCount">
<FormalSpec><![CDATA[pField:%String,pIncludeNull:%Boolean=1,&pFilters,*pSC:%Status]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	if $d(pFilters){ set pSC = $$$ERROR($$$NotImplemented) quit "" }
	
	set pSC = $$$OK, tValueCount = ""
	try {
		
		set tColId = ..Fields.GetAt(pField).Spec
		
		set tRecordId = ""
		for {
			set tRecordId = $order(..Data(tRecordId))
			quit:tRecordId=""
			
			set tValue = ..Data(tRecordId,tColId)
			if (tValue="") {
				continue:'pIncludeNull
				set tValue = $c(0)
			}
			set:'$d(tValues(tValue)) tValues(tValue) = $i(tValueCount)
		}
		
	} catch (ex) {
		set pSC = ex.AsStatus()
	}
	quit tValueCount
]]></Implementation>
</Method>

<Method name="GetXDDistribution">
<Description>
accepts
	pFilters(n) = $lb(field, operator, key)
returns:
	pDistribution = $lb(dim1Count, dim2Count, ...)
	pDistribution("value", dim, i) = value
	pDistribution(i, j, ...) = tCount
	pDistribution("total", dim, i) = tDimTotal</Description>
<FormalSpec><![CDATA[pFields:%List,*pDistribution,&pFilters]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	quit $$$ERROR($$$NotImplemented)
	quit:$d(pFilters) $$$ERROR($$$NotImplemented)
	
	set tSC = $$$OK
	try {
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Dataset.Base">
<Abstract>1</Abstract>
<Super>%Persistent,%DeepSee.PMML.Dataset</Super>
<System>4</System>
<TimeCreated>62882,48304.515284</TimeCreated>

<Property name="BootstrapCount">
<Type>%Integer</Type>
</Property>

<Method name="%OnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	quit ..Clear()
]]></Implementation>
</Method>

<Method name="GetBootstrapInfo">
<Internal>1</Internal>
<Abstract>1</Abstract>
<FormalSpec>*pSQL:%String,*pFields:%ArrayOfObjects</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
</Method>

<Method name="GetBootstrap">
<FormalSpec>pBootstrapId:%Integer,*pBootstrap:%DeepSee.PMML.Dataset.Bootstrap</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		if '$d(^%DeepSee.PMML.DatasetD(+..%Id(), "bs", pBootstrapId)) {
			set tSC = $$$ERROR($$$GeneralError, "No bootstrap with ID "_pBootstrapId)
			quit
		}
		
		set tSC = ..GetBootstrapInfo(.tSQL, .tFields)
		quit:$$$ISERR(tSC)
		
		set pBootstrap = ##class(%DeepSee.PMML.Dataset.Bootstrap).%New(pBootstrapId, tSQL, $this)
		set:pBootstrap="" tSC = %objlasterror
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="ClearBootstraps">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		quit:'..BootstrapCount
		quit:..%Id()=""
		
		kill ^%DeepSee.PMML.DatasetD(..%Id(), "bs")
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="GenerateBootstraps">
<FormalSpec>pCount:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		if (..%Id()="") {
			set tSC = $$$ERROR($$$GeneralError, "Dataset should be saved before bootstraps can be generated")
			quit
		}
		
		set tSC = ..ClearBootstraps()
		quit:$$$ISERR(tSC)
		
		if '$isobject(..IdField) {
			set tSC = $$$ERROR($$$GeneralError, "Dataset should have an ID field registered to be able to generate bootstraps")
			quit
		}
		
		// round up the available record IDs
		set tSC = ..GetRecordIds(.tIDs)
		quit:$$$ISERR(tSC)
		set tRecordCount = tIDs
		
		// now build the random samples by selecting tRecordCount IDs from tIDs
		for tBootstrapId = 1:1:pCount {
			kill tSamples
			for i = 1:1:tRecordCount {
				set tRecordId = tIDs(1+$random(tRecordCount))
				set x = $i(tSamples(tRecordId))
			}
			merge ^%DeepSee.PMML.DatasetD(..%Id(), "bs", tBootstrapId) = tSamples
			
		}
		set ..BootstrapCount = pCount
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^%DeepSee.PMML.DatasetD</DataLocation>
<DefaultData>DatasetBaseDefaultData</DefaultData>
<IdLocation>^%DeepSee.PMML.DatasetD</IdLocation>
<IndexLocation>^%DeepSee.PMML.DatasetI</IndexLocation>
<StreamLocation>^%DeepSee.PMML.DatasetS</StreamLocation>
<ExtentSize>100000</ExtentSize>
<Data name="DatasetBaseDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Name</Value>
</Value>
<Value name="3">
<Value>IdField</Value>
</Value>
<Value name="4">
<Value>Fields</Value>
</Value>
<Value name="5">
<Value>BootstrapCount</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%DeepSee.PMML.Dataset.Bootstrap">
<Description><![CDATA[
Lightweight object representing a resampled version of the <property>OriginalSet</property> dataset]]></Description>
<Super>%DeepSee.PMML.Dataset</Super>
<System>4</System>
<TimeCreated>62882,48517.509789</TimeCreated>

<Property name="BootstrapId">
<Type>%Integer</Type>
</Property>

<Property name="SQL">
<Type>%String</Type>
<Private>1</Private>
<Parameter name="MAXLEN"/>
</Property>

<Property name="OriginalSet">
<Type>%DeepSee.PMML.Dataset.Base</Type>
</Property>

<Method name="%OnNew">
<FormalSpec>pBootstrapId:%Integer,pSQL:%String,pOriginalSet:%DeepSee.PMML.Dataset.Base,pFields:%ArrayOfObjects</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ..BootstrapId = pBootstrapId
	set ..SQL = pSQL
	set ..OriginalSet = pOriginalSet
	
	set ..Name = pOriginalSet.Name_" - bootstrap #"_pBootstrapId
	set ..IdField = pOriginalSet.IdField
	
	set ..Fields = $s($g(pFields)="":pOriginalSet.Fields, 1:pFields)
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="FieldsGet">
<Internal>1</Internal>
<ReturnType>%ArrayOfObjects</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	// forward to parent field property
	quit ..OriginalSet.Fields
]]></Implementation>
</Method>

<Method name="GetSqlWhere">
<FormalSpec><![CDATA[&pFilters]]></FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	quit:$g(pFilters)="" "1=1"
	
	if $listvalid(pFilters) {
		set tFilterField = ..Fields.GetAt($li(pFilters,1))
		set tFilterOperator = $lg(pFilters,2,"=")
		set tFilterValue = $lg(pFilters,3)
		set tFilterValue = $s($isvalidnum(tFilterValue):tFilterValue, 1:"'"_tFilterValue_"'")
		quit "("_tFilterField.Spec_" "_tFilterOperator_" "_tFilterValue_")"
	} 
	
	set tWhere = "", i = "", tLogic = pFilters
	for {
		set i = $order(pFilters(i))
		quit:i=""
		kill tSubFilter
		merge tSubFilter = pFilters(i)
		set tWhere = tWhere _ $lb(..GetSqlWhere(.tSubFilter))
	}
	if (tLogic = "NOT") {
		quit "NOT (" _ $lts(tWhere," AND ") _ ")"
	} else {
		quit "(" _ $lts(tWhere," "_tLogic_" ") _ ")"
	}
]]></Implementation>
</Method>

<Method name="Get1DDistribution">
<Description>
accepts
	pFilters(n) = $lb(field, operator, key)
returns:
	pDistribution("total") = tTotalCount
	pDistribution(n) = $lb(value, count)</Description>
<FormalSpec><![CDATA[pField:%String,*pDistribution,&pFilters]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		kill pDistribution
		set tFieldSpec = ..Fields.GetAt(pField).Spec
		$$$QUOTEIFRESERVED(tFieldSpec)
		set tIdFieldSpec = ..IdField.Spec
		$$$QUOTEIFRESERVED(tIdFieldSpec)
		
		set tSQL = "SELECT %EXACT("_tFieldSpec_"), SUM(b.SampleCount) FROM ("_..SQL_") t, %DeepSee_PMML_Dataset.BootstrapLink b"
		set tSQL = tSQL_" WHERE (t."_tIdFieldSpec_" = b.RecordId AND b.BootstrapId = "_..BootstrapId_")"
		set tSQL = tSQL_" AND b.OriginalSetId = "_..OriginalSet.%Id()_" AND "_..GetSqlWhere(.pFilters)_" GROUP BY %EXACT("_tFieldSpec_")"
		
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare(tSQL)
		quit:$$$ISERR(tSC)
		set tResult = tStatement.%Execute()
		set tTotal = 0
		while tResult.%Next(.tSC) {
			quit:$$$ISERR(tSC)
			set tMember = tResult.%GetData(1)
			set tCount = tResult.%GetData(2)
			set pDistribution($i(pDistribution)) = $lb(tMember, tCount)
			set tTotal = tTotal+tCount
		}
		quit:$$$ISERR(tSC)
		set pDistribution("total") = tTotal
	
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="GetXDDistribution">
<Description>
accepts
	pFilters(n) = $lb(field, operator, key)
returns:
	pDistribution = $lb(dim1Count, dim2Count, ...)
	pDistribution("total") = total
	pDistribution("value", dim, i) = value
	pDistribution(i, j, ...) = tCount
</Description>
<FormalSpec><![CDATA[pFields:%List,*pDistribution,&pFilters]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		kill pDistribution
		
		set tFieldSpecs = "", tDims = $ll(pFields)
		for i=1:1:tDims {
			quit:'..HasField($li(pFields,i), .tSC)
			set tFieldSpec = ..Fields.GetAt($li(pFields,i)).Spec
			$$$QUOTEIFRESERVED(tFieldSpec)
			set tFieldSpecs = tFieldSpecs _ $s(tFieldSpecs="":"", 1:", ") _ "%EXACT("_tFieldSpec_")"
		}
		set tIdFieldSpec = ..IdField.Spec
		$$$QUOTEIFRESERVED(tIdFieldSpec)
		
		set tSQL = "SELECT "_tFieldSpecs_", SUM(b.SampleCount) FROM ("_..SQL_") t, %DeepSee_PMML_Dataset.BootstrapLink b"
		set tSQL = tSQL_" WHERE (t."_tIdFieldSpec_" = b.RecordId AND b.BootstrapId = "_..BootstrapId_")"
		set tSQL = tSQL_" AND b.OriginalSetId = "_..OriginalSet.%Id()_" AND "_..GetSqlWhere(.pFilters)_" GROUP BY "_tFieldSpecs
		
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare(tSQL)
		quit:$$$ISERR(tSC)
		set tResult = tStatement.%Execute()
		set tTotal = 0
		kill tValueMap, ^||%Distribution // tValueMap(dim,value) = n
		while tResult.%Next(.tSC) {
			quit:$$$ISERR(tSC)
			
			set tVarName = "^||%Distribution"
			set tCount = tResult.%GetData(tDims+1)
			
			for i = 1:1:tDims {
				set tMember = tResult.%GetData(i)
				if '$d(tValueMap(i,$s(tMember="":$c(0),1:tMember)), tIndex) {
					set tIndex = $i(pDistribution("value",i))
					set tValueMap(i,$s(tMember="":$c(0),1:tMember)) = tIndex
					set pDistribution("value",i,tIndex) = tMember
				}
				set tVarName = $name(@tVarName@(tIndex))
				set x = $i(pDistribution("total", i, tIndex), tCount)
			}
			set @tVarName = tCount
			set tTotal = tTotal+tCount
		}
		quit:$$$ISERR(tSC)
		set pDistribution("total") = tTotal
		merge pDistribution = ^||%Distribution
		kill ^||%Distribution
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="GetValueCount">
<FormalSpec><![CDATA[pField:%String,pIncludeNull:%Boolean=1,&pFilters,*pSC:%Status]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	set pSC = $$$OK, tCount = ""
	try {
		
		set tFieldSpec = ..Fields(pField)
		set tIdFieldSpec = ..IdField.Spec
		$$$QUOTEIFRESERVED(tIdFieldSpec)

		set tSQL = "SELECT COUNT(DISTINCT %EXACT("_tFieldSpec_"))"
		set:pIncludeNull tSQL = tSQL _ ", SUM(IFNULL("_tFieldSpec_",1))"
		set tSQL = tSQL _ " FROM ("_..SQL_") WHERE "_..GetSqlWhere(.pFilters)
		set tSQL = tSQL _ " AND ("_tIdFieldSpec_" IN (SELECT RecordId FROM %DeepSee_PMML_Dataset.BootstrapLink"
		set tSQL = tSQL _ " WHERE BootstrapId = " _ ..BootstrapId _ " AND OriginalSetId = "_..OriginalSet.%Id()_"))"
		
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare(tSQL)
		quit:$$$ISERR(tSC)
		set tResult = tStatement.%Execute()
		do tResult.%Next(.tSC)
		quit:$$$ISERR(tSC)
		set tCount = tResult.%GetData(1)
		set:pIncludeNull tCount = tCount + (tResult.%GetData(2)>0)
		
	} catch (ex) {
		set pSC = ex.AsStatus()
	}
	quit tCount
]]></Implementation>
</Method>

<Method name="GetRecordIds">
<Description>
returns pIds(n) = rowid</Description>
<FormalSpec><![CDATA[*pRecordIds,&pFilters]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if '$isobject(..IdField) {
			set tSC = $$$ERROR($$$GeneralError, "No ID Field registered for this dataset")
			quit
		}
		set tIdFieldSpec = ..IdField.Spec
		$$$QUOTEIFRESERVED(tIdFieldSpec)
		
		set tSQL = "SELECT "_tIdFieldSpec_" FROM ("_..SQL_") WHERE "_..GetSqlWhere(.pFilters)
		set tSQL = tSQL _ " AND ("_tIdFieldSpec_" IN (SELECT RecordId FROM %DeepSee_PMML_Dataset.BootstrapLink"
		set tSQL = tSQL _ " WHERE BootstrapId = " _ ..BootstrapId _ " AND OriginalSetId = "_..OriginalSet.%Id()_"))"
		
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare(tSQL)
		quit:$$$ISERR(tSC)
		
		set tResult = tStatement.%Execute()
		while tResult.%Next() {
			set pRecordIds($i(pRecordIds)) = tResult.%GetData(1)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Dataset.BootstrapLink">
<Hidden>1</Hidden>
<StorageStrategy>IndexOnly</StorageStrategy>
<Super>%Persistent</Super>
<System>4</System>
<TimeCreated>62882,48610.496683</TimeCreated>

<Property name="OriginalSetId">
<Type>%Integer</Type>
</Property>

<Property name="BootstrapId">
<Type>%Integer</Type>
</Property>

<Property name="RecordId">
<Type>%Integer</Type>
</Property>

<Property name="SampleCount">
<Type>%Integer</Type>
</Property>

<Index name="BootstrapIndex">
<IdKey>1</IdKey>
<PrimaryKey>1</PrimaryKey>
<Properties>OriginalSetId,BootstrapId,RecordId</Properties>
<Unique>1</Unique>
</Index>

<Storage name="IndexOnly">
<Type>%Storage.SQL</Type>
<StreamLocation>^%DeepSee.PMML.DatasetS</StreamLocation>
<ExtentSize>100000</ExtentSize>
<SQLMap name="MainIndex">
<Type>data</Type>
<Global>^%DeepSee.PMML.DatasetD</Global>
<Subscript name="1">
<Expression>{OriginalSetId}</Expression>
</Subscript>
<Subscript name="2">
<Expression>bs</Expression>
</Subscript>
<Subscript name="3">
<Expression>{BootstrapId}</Expression>
</Subscript>
<Subscript name="4">
<Expression>{RecordId}</Expression>
</Subscript>
<Data name="SampleCount"/>
</SQLMap>
</Storage>
</Class>


<Class name="%DeepSee.PMML.Dataset.Cube">
<IncludeCode>%DeepSee</IncludeCode>
<Super>%DeepSee.PMML.Dataset.Base</Super>
<System>4</System>
<TimeCreated>62882,48721.963945</TimeCreated>

<Property name="CubeName">
<Type>%String</Type>
</Property>

<Property name="Filter">
<Type>%String</Type>
<Parameter name="MAXLEN" value="2000"/>
</Property>

<Method name="%Create">
<Description>
pFields is an array of the cube levels and measures to be included in the dataset
pFields(n) = $lb(name, spec, tDataType, tOpType)
Field spec is MDX level spec [].[].[]</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pName:%String,pCubeName:%String,&pFields,pFilter:%String="",*pSC:%Status]]></FormalSpec>
<ReturnType>%DeepSee.PMML.Dataset.Cube</ReturnType>
<Implementation><![CDATA[
	set pSC = $$$OK, tObj = ""
	try {
		quit:'##class(%DeepSee.Utils).%CubeExists(pCubeName, .pSC)
		
		set tObj = ..%New()
		set tObj.Name = pName
		set tObj.CubeName = pCubeName
		set tObj.Filter = pFilter
		set tObj.IdField = ##class(%DeepSee.PMML.Dataset.Field).%New("ID","ID","integer")
		
		// if no fields specified, use all cube levels and measures (exclude computed & all levels)
		if '$d(pFields) {
			
			set tSC = ##class(%DeepSee.Utils).%GetCubeLevels(pCubeName, .tLevels, 1, 1)
			quit:$$$ISERR(tSC)
			set i = ""
			for {
				set i = $order(tLevels(i),1,tLevelInfo)
				quit:i=""
				
				continue:$li(tLevelInfo,1)'="l"
				
				set tDimName = $li(tLevelInfo,2)
				set tHierName = $li(tLevelInfo,3)
				set tLevelName = $lg(tLevelInfo,4)
				
				set tSpec = "["_tDimName_"].["_tHierName_"].["_tLevelName_"]"
				
				// using caption as field name
				set tSC = ##class(%DeepSee.Utils).%GetMemberCaption(pCubeName, tDimName, tHierName, tLevelName, .tCaption)
				quit:$$$ISERR(tSC)
				
				set tField = ##class(%DeepSee.PMML.Dataset.Field).%New(tCaption, tSpec, "string", "categorical")
				do tObj.Fields.SetAt(tField, tCaption)
			}
			
			set pSC = ##class(%DeepSee.Utils).%GetCubeMeasures(pCubeName, .tMeasures, 1)
			quit:$$$ISERR(pSC)
			set i = ""
			for {
				set i = $order(tMeasures(i),1,tMsrInfo)
				quit:i=""
				
				set tType = $li(tMsrInfo,3)
				continue:tType="iKnow"
				
				set tCaption = $li(tMsrInfo,2)
				set tSpec = "[MEASURES].["_$li(tMsrInfo,1)_"]"
				set tDataType = $case(tType, "numeric":"doubl", "number":"double", :tType)
				set tOpType = $case(tType, "numeric":"continuous", "number":"continuous", :"categorical")
				set tField = ##class(%DeepSee.PMML.Dataset.Field).%New(tCaption, tSpec, tDataType, tOpType)
				do tObj.Fields.SetAt(tField, tCaption)
			}
			
		} elseif $isobject(pFields) {
			
			for i = 1:1:pFields.Count() {
				set tField = pFields.GetAt(i)
				
				// existence check & spec expansion
				set pSC = ##class(%DeepSee.Utils).%GetDimensionInfo(pCubeName, tField.Spec, .tDimNo, .tHierNo, .tLevelNo)
				quit:$$$ISERR(pSC)
				set pSC = ##class(%DeepSee.Utils).%GetDimensionSpec(pCubeName, .tFieldSpec, tDimNo, tHierNo, tLevelNo)
				quit:$$$ISERR(pSC)
				
				set tField.Spec = tFieldSpec
				do tObj.Fields.SetAt(tField, tField.Name)
			}
			
		} else {
		
			set i = ""
			for {
				set i = $order(pFields(i),1,tFieldInfo)
				quit:i=""
				
				set tFieldName = $li(tFieldInfo,1)
				set tFieldSpec = $li(tFieldInfo,2)
				
				// existence check & spec expansion
				set pSC = ##class(%DeepSee.Utils).%GetDimensionInfo(pCubeName, tFieldSpec, .tDimNo, .tHierNo, .tLevelNo)
				quit:$$$ISERR(pSC)
				set pSC = ##class(%DeepSee.Utils).%GetDimensionSpec(pCubeName, .tFieldSpec, tDimNo, tHierNo, tLevelNo)
				quit:$$$ISERR(pSC)
				
				set tDataType = $lg(tFieldInfo,3,"string")
				set tOpType = $lg(tFieldInfo,4,"categorical")
				set tDisplayName = $lg(tFieldInfo,5)
				set tField = ##class(%DeepSee.PMML.Dataset.Field).%New(tFieldName, tFieldSpec, tDataType, tOpType, tDisplayName)
				do tObj.Fields.SetAt(tField, tFieldName)
			}
			quit:$$$ISERR(pSC)
		}
		
	} catch (ex) {
		set pSC = ex.AsStatus()
	}
	quit $s($$$ISERR(pSC):"", 1:tObj)
]]></Implementation>
</Method>

<Method name="GetMDXFilter">
<Description>
accepts
	pFilters(n) = $lb(field, operator, key)</Description>
<FormalSpec><![CDATA[&pFilters,*pSC:%Status,pAppendGlobalFilter:%Boolean=1]]></FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set pSC = $$$OK, tFilter = ""
	try {
		set:pAppendGlobalFilter&&(..Filter'="") tFilter = " %FILTER "_..Filter
		
		quit:$g(pFilters)=""
		
		if $listvalid(pFilters) {
			quit:'..HasField($li(pFilters,1), .pSC)
			set tFilterField = ..Fields.GetAt($li(pFilters,1))
			set tFilterOperator = $lg(pFilters,2,"=")
			set tFilterValue = $lg(pFilters,3)
			if (tFilterOperator = "=") {
				set tFilterSpec = tFilterField.Spec _ ".&["_tFilterValue_"]"
			} elseif (tFilterOperator = "!=") {
				set tFilterSpec = tFilterField.Spec _ ".&["_tFilterValue_"].%NOT"
			} else {
				set pSC = $$$ERROR($$$GeneralError, "unsupported operator for cube: "_tFilterOperator)
				quit
			}
			set tFilter = tFilter _ " %FILTER " _ tFilterSpec
			quit
		}
		
		if $g(pFilters)'="AND" {
			set pSC = $$$ERROR($$$GeneralError, "unsupported condition logic: "_pFilters)
			quit
		}
		
		set i = ""
		for {
			set i = $order(pFilters(i))
			quit:i=""
			kill tSubFilter
			merge tSubFilter = pFilters(i)
			set tFilter = tFilter _ ..GetMDXFilter(.tSubFilter, .pSC, 0)
			quit:$$$ISERR(pSC)
		}
		quit:$$$ISERR(pSC)
		
	} catch (ex) {
		set pSC = ex.AsStatus()
	}
	quit tFilter
]]></Implementation>
</Method>

<Method name="Get1DDistribution">
<Description>
accepts
	pFilters(n) = $lb(field, operator, key)
returns:
	pDistribution("total") = tTotalCount
	pDistribution(n) = $lb(value, count)</Description>
<FormalSpec><![CDATA[pField:%String,*pDistribution,&pFilters]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		kill pDistribution
		set pDistribution=0
		quit:'..HasField(pField, .tSC)
		
		if ..IsMeasure(pField) {
			set tSC = $$$ERROR($$$GeneralError, "cannot get distribution for measure")
			quit
		}
		
		set tFieldSpec = ..Fields.GetAt(pField).Spec
		set tMDX = "SELECT NON EMPTY {"_tFieldSpec_".Members,"_tFieldSpec_".["_$$$DeepSeeNullMarker_"]} ON 1 "
		set tMDX = tMDX _ " FROM ["_..CubeName_"]" _ ..GetMDXFilter(.pFilters, .tSC)
		quit:$$$ISERR(tSC)
		
		set tResultSet = ##class(%DeepSee.ResultSet).%ExecuteDirect(tMDX,, .tSC)
		quit:$$$ISERR(tSC)
		set tMemberCount = tResultSet.%GetAxisSize(2)
		set tSC = tResultSet.%GetAxisMembers(2,.tKey)
		quit:$$$ISERR(tSC)
		set tTotal = 0
		for i = 1:1:tMemberCount {
			set tMemberKey = $lg(^||DeepSee.AxisMembers(tKey, 2, i, 0),6)
			set tCount = tResultSet.%GetOrdinalValue(1,i)
			set tMemberKey = $s(tMemberKey=$$$DeepSeeNullMarker:"", 1:tMemberKey)
			set pDistribution($i(pDistribution)) = $lb(tMemberKey, tCount)
			set tTotal = tTotal+tCount
		}
		set pDistribution("total") = tTotal
		kill ^||DeepSee.AxisMembers(tKey)
	
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="GetXDDistribution">
<Description>
accepts
	pFilters(n) = $lb(field, operator, key)
returns:
	pDistribution = $lb(dim1Count, dim2Count, ...)
	pDistribution("value", dim, i) = value
	pDistribution(i, j, ...) = tCount
	pDistribution("total", dim, i) = tDimTotal</Description>
<FormalSpec><![CDATA[pFields:%List,*pDistribution,&pFilters]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		kill pDistribution
		set pDistribution=0
		set tDims = $ll(pFields)
		
		set tMDX = ""
		for i = 1:1:tDims {
			set tField = $li(pFields,i)
			quit:'..HasField(tField, .tSC)
			
			set tSpec = ..Fields.GetAt(tField).Spec
			if ..IsMeasure(tField) {
				set tSC = $$$ERROR($$$GeneralError, "cannot get distribution for measure")
				quit
			}
			set tMDX = $s(tMDX="":"", 1:tMDX_", ")_ "{"_tSpec_".Members,"_tSpec_".["_$$$DeepSeeNullMarker_"]}"
		}
		quit:$$$ISERR(tSC)
		set:tDims>1 tMDX = "NONEMPTYCROSSJOIN("_tMDX_")"
		set tMDX = "SELECT NON EMPTY "_tMDX_" ON 1 FROM ["_..CubeName_"] " _ ..GetMDXFilter(.pFilters, .tSC)
		quit:$$$ISERR(tSC)
		
		set tResultSet = ##class(%DeepSee.ResultSet).%ExecuteDirect(tMDX,, .tSC)
		quit:$$$ISERR(tSC)
		set tMemberCount = tResultSet.%GetAxisSize(2)
		set tSC = tResultSet.%GetAxisMembers(2,.tKey)
		quit:$$$ISERR(tSC)
		set tTotal = 0
		kill tValueMap, ^||%Distribution // tValueMap(dim,value) = n
		for i = 1:1:tMemberCount {
			set tVarName = "^||%Distribution"
			set tCount = tResultSet.%GetOrdinalValue(tDims-1,i)
			for j = 1:1:tDims {
				set tMemberKey = $lg(^||DeepSee.AxisMembers(tKey, 2, i, j-1),6)
				set:tMemberKey=$$$DeepSeeNullMarker tMemberKey = ""
				if '$d(tValueMap(j,$s(tMemberKey="":$c(0),1:tMemberKey)), tIndex) {
					set tIndex = $i(pDistribution("value",j))
					set tValueMap(j,$s(tMemberKey="":$c(0),1:tMemberKey)) = tIndex
					set pDistribution("value",j,tIndex) = tMemberKey
				}
				set tVarName = $name(@tVarName@(tIndex))
				set x = $i(pDistribution("total", j, tIndex), tCount)
			}
			set @tVarName = tCount
			set tTotal = tTotal+tCount
		}
		set pDistribution("total") = tTotal
		merge pDistribution = ^||%Distribution
		kill ^||%Distribution, ^||DeepSee.AxisMembers(tKey)
	
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="GetValueCount">
<FormalSpec><![CDATA[pField:%String,pIncludeNull:%Boolean=1,&pFilters,*pSC:%Status]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	set pSC = $$$OK, tCount = ""
	try {
		quit:'..HasField(pField, .pSC)
		
		if ..IsMeasure(pField) {
			set pSC = $$$ERROR($$$GeneralError, "cannot get distribution for measure")
			quit
		}
		
		set tFieldSpec = ..Fields.GetAt(pField).Spec
		if (pIncludeNull) {
			set tMDX = "SELECT NON EMPTY {"_tFieldSpec_".Members,"_tFieldSpec_".["_$$$DeepSeeNullMarker_"]} ON 1 "
		} else {
			set tMDX = "SELECT NON EMPTY "_tFieldSpec_".Members ON 1 "
		}
		set tMDX = tMDX _ " FROM ["_..CubeName_"] " _ ..GetMDXFilter(.pFilters, .pSC)
		quit:$$$ISERR(pSC)
		
		set tResultSet = ##class(%DeepSee.ResultSet).%ExecuteDirect(tMDX,, .pSC)
		quit:$$$ISERR(pSC)
		set tCount = tResultSet.%GetAxisSize(2)
		
	} catch (ex) {
		set pSC = ex.AsStatus()
	}
	quit tCount
]]></Implementation>
</Method>

<Method name="GetBootstrapInfo">
<Internal>1</Internal>
<FormalSpec>*pSQL:%String,*pFields:%ArrayOfObjects</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		if (..Filter'="") { // TODO --> use %DeepSee.ResultSet.%ExecuteListing()!
			set tSC = $$$ERROR($$$GeneralError, "Cube filters not supported for Bootstraps")
			quit
		}
		
		set pSQL = "SELECT ID"
		set pFields = ##class(%ArrayOfObjects).%New()
		
		set tFieldName = ""
		for {
			set tFieldName = ..Fields.GetAt(tFieldName)
			quit:tFieldName=""
			
			set tField = ..Fields.GetAt(tFieldName)
			set tSC = ##class(%DeepSee.PMML.Utils.DeepSee).GetFactPropertyForSpec(..CubeName, tField.Spec, 1, .tExpression)
			quit:$$$ISERR(tSC)
			
			set tColName = $piece(tExpression,"->",*)
			set pSQL = pSQL _ ", " _ tExpression _ " " _ tColName
			
			set tBootstrapField = ##class(%DeepSee.PMML.Dataset.Field).%New(tFieldName, tColName, tField.DataType, tField.OpType)
			do pFields.SetAt(tBootstrapField, tFieldName)
		}
		quit:$$$ISERR(tSC)
		
		set pSQL = pSQL_" FROM "_##class(%DeepSee.Utils).%GetCubeFactTable(..CubeName, .tSC)
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="GetRecordIds">
<Description>
returns pIds(n) = rowid</Description>
<FormalSpec><![CDATA[*pRecordIds,&pFilters]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tFactClass = $$$UPPER(##class(%DeepSee.Utils).%GetCubeFactClass(..CubeName, .tSC))
		quit:$$$ISERR(tSC)
		
		set tFactId = ""
		for {
			set tFactId = $order($$$DeepSeeFactGLVN(tFactClass,tFactId))
			quit:tFactId=""
			set pRecordIds($i(pRecordIds)) = tFactId
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="IsMeasure">
<FormalSpec>pFieldName:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	quit ($l(..Fields.GetAt(pFieldName).Spec,"].[")=2)
]]></Implementation>
</Method>

<Method name="GetPMMLDataSourceInternal">
<Internal>1</Internal>
<FormalSpec>*pDataSource:%DeepSee.PMML.Definition.Extension.DataSource</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set pDataSource = ##class(%DeepSee.PMML.Definition.Extension.DeepSeeDataSource).%New()
		set pDataSource.cubeName = ..CubeName
		set pDataSource.filter = ..Filter
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="GetAsResultSet">
<Internal>1</Internal>
<FormalSpec><![CDATA[pFields:%List,*pResultSet:%SQL.StatementResult,&pFilters]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		if $d(pFilters) { // TODO
			set tSC = $$$ERROR($$$GeneralError, "Filters not supported for querying Cube-based dataset")
			quit
		}
		
		set tSQL = ""
		for i = 1:1:$ll(pFields) {
			set tFieldName = $li(pFields, i)
			set tField = ..Fields.GetAt(tFieldName)
			if '$isobject(tField) {
				set tSC = $$$ERROR($$$GeneralError, "Unkown field: '"_tFieldName_"'")
				quit
			}
			set tSC = ##class(%DeepSee.PMML.Utils.DeepSee).GetFactPropertyForSpec(..CubeName, tField.Spec, 1, .tExpression)
			quit:$$$ISERR(tSC)
			set tSQL = tSQL _ ", " _ tExpression
		}
		quit:$$$ISERR(tSC)
		
		set tSQL = "SELECT "_$e(tSQL,3,*)_" FROM "_##class(%DeepSee.Utils).%GetSQLTableName(..CubeName)
		quit:$$$ISERR(tSC)
		
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare(tSQL)
		quit:$$$ISERR(tSC)
		
		set pResultSet = tStatement.%Execute()
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DefaultData>CubeDatasetDefaultData</DefaultData>
<Data name="CubeDatasetDefaultData">
<Subscript>"CubeDataset"</Subscript>
<Value name="1">
<Value>CubeName</Value>
</Value>
<Value name="2">
<Value>Filter</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%DeepSee.PMML.Dataset.Field">
<Super>%SerialObject</Super>
<System>4</System>
<TimeCreated>62882,48382.282431</TimeCreated>

<Property name="Name">
<Type>%String</Type>
<Parameter name="MAXLEN" value="200"/>
</Property>

<Property name="DisplayName">
<Type>%String</Type>
<Parameter name="MAXLEN" value="200"/>
</Property>

<Property name="Spec">
<Type>%String</Type>
<Parameter name="MAXLEN" value="200"/>
</Property>

<Property name="DataType">
<Type>%DeepSee.PMML.Datatype.DataType</Type>
</Property>

<Property name="OpType">
<Type>%DeepSee.PMML.Datatype.OpType</Type>
</Property>

<Method name="%OnNew">
<FormalSpec>pName:%String="",pSpec:%String="",pDataType:%String="",pOpType:%String="",pDisplayName:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set ..Name = pName
	set ..Spec = pSpec
	set ..DataType = pDataType
	set ..OpType = pOpType
	set ..DisplayName = pDisplayName
	Quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Serial</Type>
<State>DatasetFieldState</State>
<StreamLocation>^%DeepSee.PMML.DatasetFieldS</StreamLocation>
<Data name="DatasetFieldState">
<Value name="1">
<Value>Name</Value>
</Value>
<Value name="2">
<Value>Spec</Value>
</Value>
<Value name="3">
<Value>DataType</Value>
</Value>
<Value name="4">
<Value>OpType</Value>
</Value>
<Value name="5">
<Value>DisplayName</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%DeepSee.PMML.Dataset.ResultSet">
<Super>%DeepSee.PMML.Dataset.Table</Super>
<System>4</System>
<TimeCreated>62882,49069.582234</TimeCreated>

<Property name="ResultSet">
<Description>
Only populated while running %Create, so it can be picked up by LoadTempTable</Description>
<Type>%IResultSet</Type>
<Transient>1</Transient>
</Property>

<Method name="%Create">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pName:%String,pResultSet:%IResultSet,&pFields,&pTempTableName:%String="",pIdColumn:%String="",*pSC:%Status]]></FormalSpec>
<ReturnType>%DeepSee.PMML.Dataset.ResultSet</ReturnType>
<Implementation><![CDATA[
	set pSC = $$$OK, tObj = ""
	try {
		
		set tObj = ..%New()
		set tObj.Name = pName
		
		set pSC = tObj.SetFields(.pFields, pIdColumn, pResultSet.%GetMetadata())
		quit:$$$ISERR(pSC)
		
		set tObj.ResultSet = pResultSet
		set pSC = tObj.CreateTempTable(.pTempTableName)
		quit:$$$ISERR(pSC)
		
	} catch (ex) {
		set pSC = ex.AsStatus()
	}
	quit $s($$$ISERR(pSC):"", 1:tObj)
]]></Implementation>
</Method>

<Method name="LoadTempTable">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		#dim tMetadata As %ResultSet.MetaData = ..ResultSet.%GetMetadata()
		/*for i = 1:1:tMetadata.columnCount {
			set tColName = tMetadata.columns.GetAt(i).colName
			continue:..GetFieldBySpec(tColName)=""*/
		
		set tInsertFields = "", tInsertValues = ""
		set tFieldName = ""
		for {
			set tField = ..Fields.GetNext(.tFieldName)
			quit:tFieldName=""
				
			set tInsertFields = $s(tInsertFields'="":tInsertFields_", ", 1:"") _ tField.Spec
			set tInsertValues = $s(tInsertValues'="":tInsertValues_", ", 1:"") _ "?"
		}
		
		set tInsertStmt = "INSERT INTO "_..TempTable_" ("_tInsertFields_") VALUES ("_tInsertValues_")"
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare(tInsertStmt)
		quit:$$$ISERR(tSC)
		
		while ..ResultSet.%Next() {
			
			kill tParams
			set tFieldName = ""
			for {
				set tField = ..Fields.GetNext(.tFieldName)
				quit:tFieldName=""
				
				set tParams($i(tParams)) = ..ResultSet.%Get(tField.Spec)
			}
			
			set tSC = tStatement.%Execute(tParams...)
			quit:$$$ISERR(tSC)
		}
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
</Storage>
</Class>


<Class name="%DeepSee.PMML.Dataset.SQL">
<Super>%DeepSee.PMML.Dataset.Table</Super>
<System>4</System>
<TimeCreated>62882,49120.080578</TimeCreated>

<Property name="SQL">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Method name="%Create">
<Description>
pFields is an array of the cube levels and measures to be included in the dataset
pFields(n) = $lb(name, spec, tDataType, tOpType)
field spec is the column name</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pName:%String,pSQL:%String,&pFields,&pCreateTempTable:%String="",pIdColumn:%String="",*pSC:%Status]]></FormalSpec>
<ReturnType>%DeepSee.PMML.Dataset.SQL</ReturnType>
<Implementation><![CDATA[
	set pSC = $$$OK, tObj = ""
	try {
		set pSQL = $zstrip(pSQL, "<>WC")
		set tStatement = ##class(%SQL.Statement).%New()
		set pSC = tStatement.%Prepare(pSQL)
		quit:$$$ISERR(pSC)
		
		// check statement type (should be SELECT or CALL)
		if (tStatement.%Metadata.statementType '= 1) && (tStatement.%Metadata.statementType '= 45) {
			set pSC = $$$ERROR($$$GeneralError, "Invalid statement type for SQL dataset (should be SELECT or CALL)")
			quit
		}
		
		set tObj = ..%New()
		set tObj.Name = pName
		set tObj.SQL = pSQL
		
		// store fields (or auto-populate based on statement metadata)
		set pSC = tObj.SetFields(.pFields, pIdColumn, tStatement.%Metadata)
	
		// build temp table if requested
		if (pCreateTempTable'="") {
			set pSC = tObj.CreateTempTable(.pCreateTempTable)
			quit:$$$ISERR(pSC)
		}
		
	} catch (ex) {
		set pSC = ex.AsStatus()
	}
	quit $s($$$ISERR(pSC):"", 1:tObj)
]]></Implementation>
</Method>

<Method name="GetSqlFrom">
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit $s(..TempTable'="":..TempTable, 1:"("_..SQL_")")
]]></Implementation>
</Method>

<Method name="LoadTempTable">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tFieldName = "", tInsertStmt = ""
		for {
			set tField = ..Fields.GetNext(.tFieldName)
			quit:tFieldName=""
			
			set tInsertStmt = $s(tInsertStmt'="":tInsertStmt_", ", 1:"") _ tField.Spec
		}
		
		set tInsertStmt = "INSERT %NOINDEX INTO "_..TempTable_" ("_tInsertStmt_") SELECT "_tInsertStmt_" FROM ("_..SQL_")"
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare(tInsertStmt)
		quit:$$$ISERR(tSC)
		
		kill %objlasterror
		do tStatement.%Execute()
		set tSC = $g(%objlasterror, $$$OK)
		quit:$$$ISERR(tSC)
		
		// rebuild indices
		set tSC = $classmethod(..TempTableClass, "%BuildIndices",, 1)
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="GetPMMLDataSourceInternal">
<Internal>1</Internal>
<FormalSpec>*pDataSource:%DeepSee.PMML.Definition.Extension.DataSource</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set pDataSource = ##class(%DeepSee.PMML.Definition.Extension.SQLDataSource).%New()
		set pDataSource.SQL = ..SQL
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DefaultData>SQLDatasetDefaultData</DefaultData>
<Data name="SQLDatasetDefaultData">
<Subscript>"SQLDataset"</Subscript>
<Value name="1">
<Value>SQL</Value>
</Value>
<Value name="2">
<Value>TempTable</Value>
</Value>
<Value name="3">
<Value>TempTableClass</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%DeepSee.PMML.Dataset.Table">
<Abstract>1</Abstract>
<Super>%DeepSee.PMML.Dataset.Base</Super>
<System>4</System>
<TimeCreated>62882,49039.959148</TimeCreated>

<Property name="TempTable">
<Type>%String</Type>
</Property>

<Property name="TempTableClass">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Method name="SetFields">
<FormalSpec><![CDATA[&pFields,pIdColumn:%String,pMetadata]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		// if no fields are specified, retrieve all selected by the query (except IdColumn)
		if '$d(pFields) {
			
			for i = 1:1:pMetadata.columnCount {
				set tColumn = pMetadata.columns.GetAt(i)
				
				set tFieldName = tColumn.colName
				continue:(tFieldName=$p(pIdColumn,":",1))
				
				set tDataType = $case(tColumn.clientType, 7:"string", 10:"string", 5:"integer", 16:"boolean", :"double")
				set tOpType = $case(tColumn.clientType, 7:"categorical", 10:"categorical", 5:"categorical", 16:"categorical", :"continuous")
				set tField = ##class(%DeepSee.PMML.Dataset.Field).%New(tFieldName, tFieldName, tDataType, tOpType)
				do ..Fields.SetAt(tField, tFieldName)
			}
		
		} elseif $isobject(pFields) {
			
			for i = 1:1:pFields.Count() {
				set tField = pFields.GetAt(i)
				
				if '$d(pMetadata.columnIndex($$$UPPER(tField.Spec))) {
					set tSC = $$$ERROR($$$GeneralError, "Fieldname not retrieved by query: "_tField.Spec)
					quit
				}
				do ..Fields.SetAt(tField, tField.Name)
			}
			
		} else {
			set i = ""
			for {
				set i = $order(pFields(i),1,tFieldInfo)
				quit:i=""
				
				set tFieldName = $li(tFieldInfo,1)
				set tFieldSpec = $li(tFieldInfo,2)
				if '$d(pMetadata.columnIndex($$$UPPER(tFieldSpec))) {
					set tSC = $$$ERROR($$$GeneralError, "Fieldname not retrieved by query: "_tFieldSpec)
					quit
				}
				
				set tDataType = $li(tFieldInfo,3)
				set tOpType = $li(tFieldInfo,4)
				set tDisplayName = $lg(tFieldInfo,5)
				set tField = ##class(%DeepSee.PMML.Dataset.Field).%New(tFieldName, tFieldSpec, tDataType, tOpType, tDisplayName)
				do ..Fields.SetAt(tField, tFieldName)
			}
			quit:$$$ISERR(tSC)
		}
			
		// check if pIdColumn is included (if specified)
		if (pIdColumn'="") {
			if '$d(pMetadata.columnIndex($$$UPPER(pIdColumn)), tIdColIndex) {
				set tSC = $$$ERROR($$$GeneralError, "ID column not retrieved by query: "_pIdColumn)
				quit
			}
			
			set tColumn = pMetadata.columns.GetAt($lg(tIdColIndex,1))
			set tDataType = $case(tColumn.clientType, 7:"%String", 10:"%String", 5:"%Integer", :"%Numeric")
			set ..IdField = ##class(%DeepSee.PMML.Dataset.Field).%New(pIdColumn, pIdColumn, tDataType)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="CreateTempTable">
<Description>
Use pIndexFields to switch indices for all fields on or off
Use pIndexFields(fieldName) = indexType to override the default of bitmap indices for 
categorical and ordinal fields and normal indices for continuous fields.</Description>
<FormalSpec><![CDATA[&pClassName,&pIndexFields:%Boolean=1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		if (..TempTableClass'="") {
			// we already have a temp table
			set pClassName = ..TempTableClass
			quit
		}
		
		// rewrite if supplied as a boolean
		set pClassName = $g(pClassName)
		set:(pClassName="")||'$system.OBJ.IsValidClassname(pClassName) pClassName = $s($system.OBJ.IsValidClassname(..Name):..Name, 1:"User.TempDataset")
		set:$l(pClassName,".")=1 pClassName = "User."_pClassName
		set ..TempTableClass = pClassName, x=0
		while ##class(%Dictionary.ClassDefinition).%ExistsId(..TempTableClass) {
			set ..TempTableClass = pClassName_$i(x)
		}
		set pClassName = ..TempTableClass
		
		set tClass = ##class(%Dictionary.ClassDefinition).%New()
		set tClass.ProcedureBlock = 1
		set tClass.Name = pClassName
		set tClass.Super = "%Persistent"
		
		// create ID column
		if $isobject(..IdField) && (..IdField.Spec'="") {
			set tProp = ##class(%Dictionary.PropertyDefinition).%New()
			set tProp.Name = ..IdField.Spec
			set tProp.Type = ##class(%DeepSee.PMML.Datatype.DataType).GetClassname(..IdField.DataType)
			set tProp.Description = "ID Column"
			do tClass.Properties.Insert(tProp)
			
			set tIndex = ##class(%Dictionary.IndexDefinition).%New()
			set tIndex.Name = tProp.Name _ "PK"
			set tIndex.Properties = tProp.Name
			set tIndex.Unique = 1
			set tIndex.PrimaryKey = 1
			set tIndex.IdKey = 1
			do tClass.Indices.Insert(tIndex)
			set tIndex="", tProp=""
		}
		
		set tFieldName = ""
		for {
			set tField = ..Fields.GetNext(.tFieldName)
			quit:tFieldName=""
			
			set tProp = ##class(%Dictionary.PropertyDefinition).%New()
			set tProp.Name = tFieldName 
			set tProp.SqlFieldName = tField.Spec
			set tProp.Type = ##class(%DeepSee.PMML.Datatype.DataType).GetClassname(tField.DataType)
			do tClass.Properties.Insert(tProp)
			set tProp = ""
			
			continue:'pIndexFields&&'$d(pIndexFields(tFieldName))
			
			set tIndexType = $g(pIndexFields(tFieldName), $s(tField.OpType="continuous":"", 1:"bitmap"))
			set tIndex = ##class(%Dictionary.IndexDefinition).%New()
			set tIndex.Name = tFieldName_"Idx"
			set tIndex.Properties = tFieldName
			set tIndex.Type = tIndexType
			do tClass.Indices.Insert(tIndex)
			set tIndex=""
		}
		
		set tSC = tClass.%Save()
		quit:$$$ISERR(tSC)
		set tClass=""
		
	    set tSC = $system.OBJ.Compile(pClassName, "ck-d")
	    quit:$$$ISERR(tSC)
	    
	    set ..TempTable = ##class(%DeepSee.Utils).%GetSQLTableName(pClassName)
	    
	    set tSC = ..LoadTempTable()
	    quit:$$$ISERR(tSC)
	    
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="LoadTempTable">
<Abstract>1</Abstract>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
</Method>

<Method name="Get1DDistribution">
<Description>
accepts
	pFilters(n) = $lb(field, operator, key)
returns:
	pDistribution("total") = tTotalCount
	pDistribution(n) = $lb(value, count)</Description>
<FormalSpec><![CDATA[pField:%String,*pDistribution,&pFilters]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		kill pDistribution
		set pDistribution=0
		quit:'..HasField(pField, .tSC)
		
		set tFieldSpec = ..Fields.GetAt(pField).Spec
		$$$QUOTEIFRESERVED(tFieldSpec)
		
		set tSQL = "SELECT %EXACT("_tFieldSpec_"), COUNT(*) FROM "_..GetSqlFrom()
		set tSQL = tSQL_" WHERE "_..GetSqlWhere(.pFilters, .tSC)_" GROUP BY %EXACT("_tFieldSpec_")"
		quit:$$$ISERR(tSC)
		
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare(tSQL)
		quit:$$$ISERR(tSC)
		set tResult = tStatement.%Execute()
		set tTotal = 0
		while tResult.%Next(.tSC) {
			quit:$$$ISERR(tSC)
			set tMember = tResult.%GetData(1)
			set tCount = tResult.%GetData(2)
			set pDistribution($i(pDistribution)) = $lb(tMember, tCount)
			set tTotal = tTotal+tCount
		}
		quit:$$$ISERR(tSC)
		set pDistribution("total") = tTotal
	
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="GetSqlFrom">
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit ..TempTable
]]></Implementation>
</Method>

<Method name="GetSqlWhere">
<FormalSpec><![CDATA[&pFilters,*pSC:%Status]]></FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set pSC = $$$OK
	
	quit:$g(pFilters)="" "1=1"
	
	if $listvalid(pFilters) {
		quit:'..HasField($li(pFilters,1), .pSC)
		set tFilterField = ..Fields.GetAt($li(pFilters,1)).Spec
		$$$QUOTEIFRESERVED(tFilterField)
		set tFilterOperator = $lg(pFilters,2,"=")
		set tFilterValue = $lg(pFilters,3)
		set tFilterValue = $s($isvalidnum(tFilterValue):tFilterValue, 1:"'"_tFilterValue_"'")
		quit "("_tFilterField_" "_tFilterOperator_" "_tFilterValue_")"
	} 
	quit:$$$ISERR(pSC)
	
	set tWhere = "", i = "", tLogic = pFilters
	for {
		set i = $order(pFilters(i))
		quit:i=""
		kill tSubFilter
		merge tSubFilter = pFilters(i)
		set tWhere = tWhere _ $lb(..GetSqlWhere(.tSubFilter))
	}
	if (tLogic = "NOT") {
		quit "NOT (" _ $lts(tWhere," AND ") _ ")"
	} else {
		quit "(" _ $lts(tWhere," "_tLogic_" ") _ ")"
	}
]]></Implementation>
</Method>

<Method name="Clear">
<Description>
Clears all temporary structures created by this object.
The dataset should remain usable after calling this method!</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = ..ClearBootstraps()
	quit:$$$ISERR(tSC) tSC
	
	quit:..TempTable="" $$$OK
	
	set tSC = $classmethod(..TempTableClass,"%KillExtent")
	quit:$$$ISERR(tSC) tSC
	set tSC = $system.OBJ.Delete(..TempTableClass, "-d")
	set ..TempTable = "", ..TempTableClass = ""
	quit tSC
]]></Implementation>
</Method>

<Method name="GetBootstrapInfo">
<Internal>1</Internal>
<FormalSpec>*pSQL:%String,*pFields:%ArrayOfObjects</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set pSQL = ..GetSqlFrom(), pFields = ..Fields
	quit $$$OK
]]></Implementation>
</Method>

<Method name="GetXDDistribution">
<Description>
accepts
	pFilters(n) = $lb(field, operator, key)
returns:
	pDistribution = $lb(dim1Count, dim2Count, ...)
	pDistribution("total") = total
	pDistribution("value", dim, i) = value
	pDistribution(i, j, ...) = tCount
</Description>
<FormalSpec><![CDATA[pFields:%List,*pDistribution,&pFilters]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		kill pDistribution
		set pDistribution=0
		
		set tFieldSpecs = "", tDims = $ll(pFields)
		for i=1:1:tDims {
			quit:'..HasField($li(pFields,i), .tSC)
			set tFieldSpec = ..Fields.GetAt($li(pFields,i)).Spec
			$$$QUOTEIFRESERVED(tFieldSpec)
			set tFieldSpecs = tFieldSpecs _ $s(tFieldSpecs="":"", 1:", ") _ "%EXACT("_tFieldSpec_")"
		}
		
		set tSQL = "SELECT "_tFieldSpecs_", COUNT(*) FROM "_..GetSqlFrom()
		set tSQL = tSQL_" WHERE "_..GetSqlWhere(.pFilters, .tSC)_" GROUP BY "_tFieldSpecs
		quit:$$$ISERR(tSC)
		
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare(tSQL)
		quit:$$$ISERR(tSC)
		set tResult = tStatement.%Execute()
		set tTotal = 0
		kill tValueMap, ^||%Distribution // tValueMap(dim,value) = n
		while tResult.%Next(.tSC) {
			quit:$$$ISERR(tSC)
			
			set tVarName = "^||%Distribution"
			set tCount = tResult.%GetData(tDims+1)
			
			for i = 1:1:tDims {
				set tMember = tResult.%GetData(i)
				if '$d(tValueMap(i,$s(tMember="":$c(0),1:tMember)), tIndex) {
					set tIndex = $i(pDistribution("value",i))
					set tValueMap(i,$s(tMember="":$c(0),1:tMember)) = tIndex
					set pDistribution("value",i,tIndex) = tMember
				}
				set tVarName = $name(@tVarName@(tIndex))
				set x = $i(pDistribution("total", i, tIndex), tCount)
			}
			set @tVarName = tCount
			set tTotal = tTotal+tCount
		}
		quit:$$$ISERR(tSC)
		set pDistribution("total") = tTotal
		merge pDistribution = ^||%Distribution
		kill ^||%Distribution
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="GetValueCount">
<FormalSpec><![CDATA[pField:%String,pIncludeNull:%Boolean=1,&pFilters,*pSC:%Status]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	set pSC = $$$OK, tCount = ""
	try {
		quit:'..HasField(pField, .pSC)
		
		set tFieldSpec = ..Fields.GetAt(pField).Spec
		$$$QUOTEIFRESERVED(tFieldSpec)

		set tSQL = "SELECT COUNT(DISTINCT "_tFieldSpec_")"
		set:pIncludeNull tSQL = tSQL _ ", SUM(IFNULL("_tFieldSpec_",1))"
		set tSQL = tSQL _ " FROM "_..GetSqlFrom()_" WHERE "_..GetSqlWhere(.pFilters, .pSC)
		quit:$$$ISERR(pSC)
		
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare(tSQL)
		quit:$$$ISERR(tSC)
		set tResult = tStatement.%Execute()
		do tResult.%Next(.tSC)
		quit:$$$ISERR(tSC)
		set tCount = tResult.%GetData(1)
		set:pIncludeNull tCount = tCount + (tResult.%GetData(2)>0)
		
	} catch (ex) {
		set pSC = ex.AsStatus()
	}
	quit tCount
]]></Implementation>
</Method>

<Method name="GetRecordIds">
<Description>
returns pIds(n) = rowid</Description>
<FormalSpec><![CDATA[*pRecordIds,&pFilters]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if '$isobject(..IdField) {
			set tSC = $$$ERROR($$$GeneralError, "No ID Field registered for this dataset")
			quit
		}
		set tIdFieldSpec = ..IdField.Spec
		$$$QUOTEIFRESERVED(tIdFieldSpec)
		
		set tSQL = "SELECT "_tIdFieldSpec_" FROM "_..GetSqlFrom()_" WHERE "_..GetSqlWhere(.pFilters, .tSC)
		quit:$$$ISERR(tSC)
		
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare(tSQL)
		quit:$$$ISERR(tSC)
		
		set tResult = tStatement.%Execute()
		while tResult.%Next() {
			set pRecordIds($i(pRecordIds)) = tResult.%GetData(1)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="GetAggregatesByCategory">
<Description><![CDATA[
Returns an array listing aggregate values for a continuous field <var>pContField</var> for
each value of a categorical field <var>pCatField</var>.
accepts
	pFilters(n) = $lb(field, operator, key)
returns:
	pAggregates(n) = $lb(category value, count, average, sum, max, min, countNonNull)]]></Description>
<FormalSpec><![CDATA[pContField:%String,pCatField:%String,*pAggregates,&pFilters]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		kill pAggregates
		set pAggregates=0
		
		set tContField = ..Fields.GetAt(pContField).Spec
		$$$QUOTEIFRESERVED(tContField)
		set tCatField = ..Fields.GetAt(pCatField).Spec
		$$$QUOTEIFRESERVED(tCatField)
		
		set tQuery = "SELECT %EXACT("_tCatField_") xCat, COUNT(*) xCount, AVG("_tContField_") xAvg," _
						" SUM("_tContField_") xSum, MAX("_tContField_") xMax, MIN("_tContField_") xMin," _
						" SUM(CASE WHEN "_tContField_" IS NULL THEN 0 ELSE 1 END) xCountNotNull FROM " _
						..GetSqlFrom() _ " WHERE " _ ..GetSqlWhere(.pFilters, .tSC) _ " GROUP BY %EXACT("_tCatField_")"
		quit:$$$ISERR(tSC)
		
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare(tQuery)
		quit:$$$ISERR(tSC)
		
		set tResult = tStatement.%Execute()
		while tResult.%Next() {
			set pAggregates($i(pAggregates)) = $lb(tResult.%GetData(1), tResult.%GetData(2), tResult.%GetData(3), tResult.%GetData(4), tResult.%GetData(5), tResult.%GetData(6), tResult.%GetData(7), tResult.%GetData(8))
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="GetAsResultSet">
<Internal>1</Internal>
<FormalSpec><![CDATA[pFields:%List,*pResultSet:%SQL.StatementResult,&pFilters]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set tSQL = ""
		for i = 1:1:$ll(pFields) {
			set tFieldName = $li(pFields, i)
			set tField = ..Fields.GetAt(tFieldName)
			if '$isobject(tField) {
				set tSC = $$$ERROR($$$GeneralError, "Unkown field: '"_tFieldName_"'")
				quit
			}
			set tFieldSpec = tField.Spec
			$$$QUOTEIFRESERVED(tFieldSpec)
			set tSQL = tSQL _ ", " _ tFieldSpec
		}
		quit:$$$ISERR(tSC)
		
		set tSQL = "SELECT "_$e(tSQL,3,*)_" FROM "_..GetSqlFrom()_" WHERE "_..GetSqlWhere(.pFilters, .tSC)
		quit:$$$ISERR(tSC)
		
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare(tSQL)
		quit:$$$ISERR(tSC)
		
		set pResultSet = tStatement.%Execute()
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DefaultData>TableDatasetDefaultData</DefaultData>
<Data name="TableDatasetDefaultData">
<Subscript>"TableDataset"</Subscript>
<Value name="1">
<Value>TempTable</Value>
</Value>
<Value name="2">
<Value>TempTableClass</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%DeepSee.PMML.Dataset.Utils">
<System>4</System>
<TimeCreated>62882,48781.712585</TimeCreated>

<Method name="GetChiSquared">
<Description><![CDATA[
Calculates the Pearson chi-squared test for the two-dimensional contingency table defined by
<var>pField1</var> and <var>pField2</var>. If the probability of this value is low (&lt;0.05),
<var>pField1</var> and <var>pField2</var> can be considered independent of one another.
http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pDataset:%DeepSee.PMML.Dataset,pField1:%String,pField2:%String,*pChiSquared:%Numeric,*pProbability:%Numeric,&pFilters,pYatesCorrection:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		for tField = pField1, pField2 {
			if (pDataset.Fields.GetAt(tField).OpType = "continuous") {
				set tSC = $$$ERROR($$$GeneralError, "only supported for categorical / ordinal fields")
				quit
			}
		}
		
		set tSC = pDataset.GetXDDistribution($lb(pField1, pField2), .tDistribution, .pFilters)
		quit:$$$ISERR(tSC)
		
		set pChiSquared = 0
		set tTotalCount = tDistribution("total")
		set i = ""
		for {
			set i = $order(tDistribution(i))
			quit:i=""
			continue:'i // skip "total" and "value" subscripts
			
			set tTotalI = tDistribution("total",1,i)
			
			set j = ""
			for {
				set j = $order(tDistribution(i,j),1,tCount)
				quit:j=""
				
				set tTotalJ = tDistribution("total",2,j)
				
				set tExpectedCount = tTotalJ * tTotalI / tTotalCount
				set tDifference = (tCount - tExpectedCount)
				set:pYatesCorrection tDifference = $zabs(tDifference) - 0.5
				set pChiSquared = pChiSquared + ((tDifference ** 2) / tExpectedCount)
			}
		}
		
		// now calculate probability
		set tNumValuesI = $o(tDistribution("total",1,""),-1)
		set tNumValuesJ = $o(tDistribution("total",2,""),-1)
		set tDegFreedom = (tNumValuesI-1) * (tNumValuesJ-1)
		
		// dodgy approximation function
		// http://www.jstor.org/discover/10.2307/2348373?uid=3737592&uid=2&uid=4&sid=21101671656727
		set tZ = $zsqr(pChiSquared) - $zsqr(tDegFreedom)
		if (tZ <= 0) {
			set pProbability = 1 - (0.5 * $zexp((0.8055*tZ)+(-0.9911*(tZ**2))))
		} else {
			set pProbability = 0.5 * $zexp((-1.2451*tZ)+(-0.6763*(tZ**2)))
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Dataset">
<Description><![CDATA[
A Dataset is a wrapper for a collection of records that can be analyzed, in order to build or
run a model. Implementations abstracting different sources of data can be found in 
<package>%DeepSee.PMML.Dataset</package>.]]></Description>
<Abstract>1</Abstract>
<IncludeCode>%PMML</IncludeCode>
<Super>%RegisteredObject</Super>
<System>4</System>
<TimeCreated>62882,48186.168413</TimeCreated>

<Property name="Name">
<Type>%String</Type>
<Parameter name="MAXLEN" value="200"/>
</Property>

<Property name="IdField">
<Type>%DeepSee.PMML.Dataset.Field</Type>
</Property>

<Property name="Fields">
<Type>%DeepSee.PMML.Dataset.Field</Type>
<Collection>array</Collection>
</Property>

<Method name="GetValueCount">
<Description><![CDATA[
Returns the number of distinct values for <var>pField</var> (categorical)]]></Description>
<Abstract>1</Abstract>
<FormalSpec><![CDATA[pField:%String,pIncludeNull:%Boolean=1,&pFilters,*pSC:%Status]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
</Method>

<Method name="Get1DDistribution">
<Description><![CDATA[
Returns an array describing the distribution of values for a field <var>pField</var> (categorical)
accepts
	pFilters(n) = $lb(field, operator, key)
returns:
	pDistribution("total") = tTotalCount
	pDistribution(n) = $lb(value, count)]]></Description>
<Abstract>1</Abstract>
<FormalSpec><![CDATA[pField:%String,*pDistribution,&pFilters]]></FormalSpec>
<ReturnType>%Status</ReturnType>
</Method>

<Method name="GetAggregatesByCategory">
<Description><![CDATA[
Returns an array listing aggregate values for a continuous field <var>pContField</var> for
each value of a categorical field <var>pCatField</var>.
accepts
	pFilters(n) = $lb(field, operator, key)
returns:
	pAggregates("total") = tTotalCount
	pAggregates(n) = $lb(category value, count, average, sum, max, min, countNonNull)]]></Description>
<Abstract>1</Abstract>
<FormalSpec><![CDATA[pContField:%String,pCatField:%String,*pAggregates,&pFilters]]></FormalSpec>
<ReturnType>%Status</ReturnType>
</Method>

<Method name="GetXDDistribution">
<Description>
accepts
	pFilters(n) = $lb(field, operator, key)
returns:
	pDistribution = $lb(dim1Count, dim2Count, ...)
	pDistribution("value", dim, i) = value
	pDistribution(i, j, ...) = tCount
	pDistribution("total", dim, i) = tDimTotal</Description>
<Abstract>1</Abstract>
<FormalSpec><![CDATA[pFields:%List,*pDistribution,&pFilters]]></FormalSpec>
<ReturnType>%Status</ReturnType>
</Method>

<Method name="Clear">
<Description>
Clears all temporary structures created by this object.
The dataset should remain usable after calling this method!</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	quit ..ClearBootstraps()
]]></Implementation>
</Method>

<Method name="GetFieldBySpec">
<FormalSpec>pFieldSpec:%String</FormalSpec>
<ReturnType>%DeepSee.PMML.Dataset.Field</ReturnType>
<Implementation><![CDATA[
	set tField = "", tName = ""
	for {
		set tName = ..Fields.GetNext(tName)
		quit:tName=""
		
		if (..Fields.GetAt(tName).Spec=pFieldSpec) {
			set tField = ..Fields.GetAt(tName)
			quit
		}
	}
	quit tField
]]></Implementation>
</Method>

<Method name="GetRecordIds">
<Description>
returns pIds(n) = rowid</Description>
<Abstract>1</Abstract>
<FormalSpec><![CDATA[*pIds,&pFilters]]></FormalSpec>
<ReturnType>%Status</ReturnType>
</Method>

<Method name="GetAsResultSet">
<Internal>1</Internal>
<Abstract>1</Abstract>
<FormalSpec><![CDATA[pFields:%List,*pResultSet:%SQL.StatementResult,&pFilters]]></FormalSpec>
<ReturnType>%Status</ReturnType>
</Method>

<Method name="HasField">
<FormalSpec>pFieldName:%String,*pSC:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set tHasField = $isobject(..Fields.GetAt(pFieldName))
	set pSC = $s(tHasField:$$$OK, 1:$$$ERROR($$$GeneralError, "Unknown field name: '"_pFieldName_"'"))
	quit tHasField
]]></Implementation>
</Method>

<Method name="GetPMMLDataSourceInternal">
<Internal>1</Internal>
<Abstract>1</Abstract>
<FormalSpec>*pDataSource:%DeepSee.PMML.Definition.Extension.DataSource</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
</Method>

<Method name="GetPMMLDataSource">
<Description>
Returns a %DeepSee.PMML.Definition.Extension.DataSource element representing the mapping from
data fields to source fields</Description>
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>*pDataSource:%DeepSee.PMML.Definition.Extension.DataSource,pName:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set tSC = ..GetPMMLDataSourceInternal(.pDataSource)
		quit:$$$ISERR(tSC)
		set pDataSource.name = $s(pName="":..Name, 1:pName)
		set:$isobject(..IdField) pDataSource.idField = ..IdField.Name
		
		set tFieldName = "", tAllEqual = 1
		for {
			set tField = ..Fields.GetNext(.tFieldName)
			quit:tFieldName=""
			
			set tFieldMap = ##class(%DeepSee.PMML.Definition.Extension.FieldMap).%New()
			set tFieldMap.fieldName = tFieldName
			set tFieldMap.spec = tField.Spec
			set:tAllEqual tAllEqual = (tFieldName = tField.Spec)
			do pDataSource.Fields.Insert(tFieldMap)
		}
		do:tAllEqual pDataSource.Fields.Clear()
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Datatype.Boolean">
<Super>%Boolean</Super>
<System>3</System>
<TimeCreated>62735,55404.898341</TimeCreated>
</Class>


<Class name="%DeepSee.PMML.Datatype.BooleanInt">
<Super>%Integer</Super>
<System>3</System>
<TimeCreated>62738,40133.84619</TimeCreated>

<Parameter name="VALUELIST">
<Default>,0,1</Default>
</Parameter>
</Class>


<Class name="%DeepSee.PMML.Datatype.CumulativeLinkFunction">
<Super>String</Super>
<System>3</System>
<TimeCreated>62738,39587.432183</TimeCreated>

<Parameter name="VALUELIST">
<Default>,logit,probit,cloglog,loglog,cauchit</Default>
</Parameter>
</Class>


<Class name="%DeepSee.PMML.Datatype.DataType">
<Super>String</Super>
<System>3</System>
<TimeCreated>62735,55437.333756</TimeCreated>

<Parameter name="VALUELIST">
<Default>,string,integer,float,double,boolean,date,time,dateTime,dateDaysSince[0],dateDaysSince[1960],dateDaysSince[1970],dateDaysSince[1980],timeSeconds,dateTimeSecondsSince[0],dateTimeSecondsSince[1960],dateTimeSecondsSince[1970],dateTimeSecondsSince[1980]</Default>
</Parameter>

<Method name="GetClassname">
<ClassMethod>1</ClassMethod>
<FormalSpec>pValue:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit "%DeepSee.PMML.Datatype." _ $case(pValue, "string":"String", "":"String", "float":"RealNumber", "double":"RealNumber", "boolean":"BooleanInt", :"IntNumber")
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Datatype.FieldName">
<Super>String</Super>
<System>3</System>
<TimeCreated>62735,55360.746449</TimeCreated>

<Parameter name="MAXLEN">
<Default>200</Default>
</Parameter>
</Class>


<Class name="%DeepSee.PMML.Datatype.FieldUsageType">
<IncludeGenerator>%PMML</IncludeGenerator>
<Super>String</Super>
<System>3</System>
<TimeCreated>62735,56767.00102</TimeCreated>

<Parameter name="VALUELIST">
<Expression>$lts($lb("",$$$PMMLusageTypePredicted, $$$PMMLusageTypeTarget, $$$PMMLusageTypeActive, $$$PMMLusageTypeSupplementary, $$$PMMLusageTypeGroup, $$$PMMLusageTypeOrder, $$$PMMLusageTypeFrequencyWeight, $$$PMMLusageTypeAnalysisWeight))</Expression>
</Parameter>
</Class>


<Class name="%DeepSee.PMML.Datatype.IntNumber">
<Super>%Integer</Super>
<System>3</System>
<TimeCreated>62735,55463.80731</TimeCreated>
</Class>


<Class name="%DeepSee.PMML.Datatype.InvalidValueTreatmentMethod">
<Super>String</Super>
<System>3</System>
<TimeCreated>62735,57311.994932</TimeCreated>

<Parameter name="VALUELIST">
<Default>,returnInvalid,asIs,asMissing</Default>
</Parameter>
</Class>


<Class name="%DeepSee.PMML.Datatype.LinkFunction">
<Super>String</Super>
<System>3</System>
<TimeCreated>62738,39684.451964</TimeCreated>

<Parameter name="VALUELIST">
<Default>,cloglog,identity,log,logc,logit,loglog,negbin,oddspower,power,probit</Default>
</Parameter>
</Class>


<Class name="%DeepSee.PMML.Datatype.MiningFunction">
<Super>String</Super>
<System>3</System>
<TimeCreated>62735,55508.556638</TimeCreated>

<Parameter name="VALUELIST">
<Default>,associationRules,sequences,classification,regression,clustering,timeSeries,mixed</Default>
</Parameter>
</Class>


<Class name="%DeepSee.PMML.Datatype.MissingValueTreatmentMethod">
<Super>String</Super>
<System>3</System>
<TimeCreated>62735,56920.03422</TimeCreated>

<Parameter name="VALUELIST">
<Default>,asIs,asMean,asMode,asMedian,asValue</Default>
</Parameter>
</Class>


<Class name="%DeepSee.PMML.Datatype.Number">
<Super>%Double</Super>
<System>3</System>
<TimeCreated>62735,55534.791032</TimeCreated>
</Class>


<Class name="%DeepSee.PMML.Datatype.OpType">
<Super>String</Super>
<System>3</System>
<TimeCreated>62735,55566.434745</TimeCreated>

<Parameter name="VALUELIST">
<Default>,categorical,ordinal,continuous</Default>
</Parameter>
</Class>


<Class name="%DeepSee.PMML.Datatype.OutlierTreatmentMethod">
<Super>String</Super>
<System>3</System>
<TimeCreated>62735,56864.237416</TimeCreated>

<Parameter name="VALUELIST">
<Default>,asIs,asMissingValues,asExtremeValues</Default>
</Parameter>
</Class>


<Class name="%DeepSee.PMML.Datatype.PercentageNumber">
<Super>%Double</Super>
<System>3</System>
<TimeCreated>62735,55598.568287</TimeCreated>

<Parameter name="MAXVAL">
<Default>100</Default>
</Parameter>

<Parameter name="MINVAL">
<Default>0</Default>
</Parameter>
</Class>


<Class name="%DeepSee.PMML.Datatype.ProbNumber">
<Super>%Double</Super>
<System>3</System>
<TimeCreated>62735,55633.304222</TimeCreated>

<Parameter name="MAXVAL">
<Default>1</Default>
</Parameter>

<Parameter name="MINVAL">
<Default>0</Default>
</Parameter>
</Class>


<Class name="%DeepSee.PMML.Datatype.RealNumber">
<Super>%Double</Super>
<System>3</System>
<TimeCreated>62735,55665.860939</TimeCreated>
</Class>


<Class name="%DeepSee.PMML.Datatype.ResultFeature">
<Super>String</Super>
<System>3</System>
<TimeCreated>62735,65000.241534</TimeCreated>

<Parameter name="VALUELIST">
<Default>,predictedValue,predictedDisplayValue,transformedValue,decision,probability,affinity,residual,standardError,clusterId,clusterAffinity,entityId,entityAffinity,warning,ruleValue,reasonCode</Default>
</Parameter>
</Class>


<Class name="%DeepSee.PMML.Datatype.RuleFeature">
<Super>String</Super>
<System>3</System>
<TimeCreated>62735,65100.079111</TimeCreated>

<Parameter name="VALUELIST">
<Default>,antecedent,consequent,rule,ruleId,confidence,support,lift,leverage,affinity</Default>
</Parameter>
</Class>


<Class name="%DeepSee.PMML.Datatype.String">
<Super>%String</Super>
<System>3</System>
<TimeCreated>62738,36090.927822</TimeCreated>

<Parameter name="MAXLEN">
<Default>200</Default>
</Parameter>
</Class>


<Class name="%DeepSee.PMML.Datatype.YesNo">
<Super>String</Super>
<System>3</System>
<TimeCreated>62735,61585.223197</TimeCreated>

<Parameter name="VALUELIST">
<Default>,yes,no</Default>
</Parameter>
</Class>


<Class name="%DeepSee.PMML.Definition.DataDictionary">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,45246.954301</TimeCreated>

<Property name="numberOfFields">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Parameter name="MINVAL" value="1"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="DataFields">
<Type>DataField</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="DataField"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Taxonomies">
<Type>Taxonomy</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="Taxonomy"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%OnValidateObject">
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if (..numberOfFields'="") && (..numberOfFields'=..DataFields.Count()) {
			set tSC = $$$ERROR($$$GeneralError, "value of numberOfFields attribute should match DataField element count")
			quit
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%GetDictionary">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set tSource = "DataDictionary"
		
		// append DataField entries
		for i = 1:1:..DataFields.Count() {
			set tField = ..DataFields.GetAt(i)
			
			if $d(pDictionary("fields", tField.name), tSrc) {
				set tSC = $$$ERROR($$$GeneralError, "Field already defined: '"_tField.name_"' ("_tSrc_")")
				quit
			}
			
			set pDictionary("fields", tField.name) = tSource
			set:tField.dataType'="" pDictionary("fields", tField.name, "dataType") = tField.dataType
			set:tField.optype'="" pDictionary("fields", tField.name, "optype") = tField.optype
		}
		
		// append Taxonomy entries
		for i = 1:1:..Taxonomies.Count() {
			set tTaxonomy = ..Taxonomies.GetAt(i)
			
			if $d(pDictionary("taxonomies", tTaxonomy.name), tSrc) {
				set tSC = $$$ERROR($$$GeneralError, "Taxonomy already defined: '"_tTaxonomy.name_"' ("_tSource_")")
				quit
			}
			
			set pDictionary("taxonomies", tTaxonomy.name) = tSource
		}
		
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="AddField">
<FormalSpec>pField:DataField</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	do ..DataFields.Insert(pField)
	set ..numberOfFields = ..numberOfFields+1
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.DataField">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,51281.557364</TimeCreated>

<Property name="name">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="displayName">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="optype">
<Type>%DeepSee.PMML.Datatype.OpType</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="dataType">
<Type>%DeepSee.PMML.Datatype.DataType</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="taxonomy">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="isCyclic">
<Type>%DeepSee.PMML.Datatype.BooleanInt</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Values">
<Type>%DeepSee.PMML.Definition.Util.DataFieldRange</Type>
<Collection>list</Collection>
<Parameter name="XMLNIL" value="1"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
<Parameter name="XMLTYPECONSTRAINT" value="CHOICE"/>
</Property>

<Method name="%OnValidateObject">
<Description>
Adds node-specific validation checks</Description>
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if (..optype '= "continuous") {
			for i = 1:1:..Values.Count() {
				if ..Values.GetAt(i).%IsA("%DeepSee.PMML.Definition.Util.Interval") {
					set tSC = $$$ERROR($$$GeneralError, "Interval definitions are only allowed for continuous fields")
					quit
				}
			}
			quit:$$$ISERR(tSC)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Decision">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,65541.619091</TimeCreated>

<Property name="value">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="displayValue">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="description">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="20000"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Decisions">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,65653.633772</TimeCreated>

<Property name="businessProblem">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="description">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="20000"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Decision">
<Type>Decision</Type>
<Collection>list</Collection>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.DefineFunction">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,58586.468885</TimeCreated>

<Property name="name">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="optype">
<Type>%DeepSee.PMML.Datatype.OpType</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="dataType">
<Type>%DeepSee.PMML.Datatype.DataType</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="ParameterFields">
<Type>%DeepSee.PMML.Definition.Util.ParameterField</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="ParameterField"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Expression">
<Type>%DeepSee.PMML.Definition.Util.AbstractExpression</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.DerivedField">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,58667.71166</TimeCreated>

<Property name="name">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Parameter name="MAXLEN" value="200"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="displayName">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="optype">
<Type>%DeepSee.PMML.Datatype.OpType</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="dataType">
<Type>%DeepSee.PMML.Datatype.DataType</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Expression">
<Type>%DeepSee.PMML.Definition.Util.AbstractExpression</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
<Parameter name="XMLTYPECONSTRAINT" value="CHOICE"/>
</Property>

<Property name="Value">
<Type>%DeepSee.PMML.Definition.Util.Value</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%OnValidateObject">
<Description>
Adds node-specific validation checks</Description>
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if ..Expression="" {
			set tSC = $$$ERROR($$$GeneralError, "DerivedField should have an expression element")
			quit
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Extension.DataSource">
<Abstract>1</Abstract>
<Super>ISCExtension</Super>
<System>3</System>
<TimeCreated>62861,48888.680292</TimeCreated>

<Property name="name">
<Type>%String</Type>
<Parameter name="MAXLEN" value="200"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="description">
<Type>%String</Type>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="idField">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Fields">
<Type>FieldMap</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="X-FieldMap"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Extension.DeepSeeDataSource">
<Super>DataSource</Super>
<System>3</System>
<TimeCreated>62861,53903.820717</TimeCreated>

<Parameter name="XMLNAME">
<Default>X-DeepSeeDataSource</Default>
</Parameter>

<Property name="cubeName">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="200"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="filter">
<Type>%String</Type>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="idField">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<InitialExpression>"ID"</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Extension.FieldMap">
<Super>%DeepSee.PMML.Definition.node</Super>
<System>3</System>
<TimeCreated>62861,48868.357588</TimeCreated>

<Parameter name="XMLNAME">
<Default>X-FieldMap</Default>
</Parameter>

<Property name="fieldName">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="spec">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="200"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Extension.ISCExtension">
<Super>%DeepSee.PMML.Definition.node</Super>
<System>3</System>
<TimeCreated>62861,48567.543029</TimeCreated>
</Class>


<Class name="%DeepSee.PMML.Definition.Extension.SQLDataSource">
<Super>DataSource</Super>
<System>3</System>
<TimeCreated>62861,53843.765134</TimeCreated>

<Parameter name="XMLNAME">
<Default>X-SQLDataSource</Default>
</Parameter>

<Property name="SQL">
<Type>%String</Type>
<Parameter name="MAXLEN" value="20000"/>
<Parameter name="XMLNAME" value="X-SQL"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Extension.TextModelInput">
<Super>ISCExtension</Super>
<System>3</System>
<TimeCreated>62879,50748.974591</TimeCreated>

<Parameter name="XMLNAME">
<Default>X-TextModelInput</Default>
</Parameter>

<Property name="inputType">
<Description><![CDATA[
This attribute defines whether the MiningField names referred in <property>Fields</property>
correspond to text that could contain any of the terms in DictionaryTerms (multiple input fields
are concatenated with two line breaks) or refer to inputs already containing the frequencies
of the terms in DictionaryTerms.]]></Description>
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="VALUELIST" value=",text,terms"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Fields">
<Type>%DeepSee.PMML.Definition.Util.Array</Type>
<Parameter name="XMLNAME" value="Array"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="languages">
<Description><![CDATA[
If <property>inputType</property> = "text", this property should define language of this text
input as a comma-separated list of two-letter language codes.]]></Description>
<Type>%DeepSee.PMML.Datatype.String</Type>
<InitialExpression>"en"</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Extension">
<Super>node</Super>
<System>3</System>
<TimeCreated>62735,44175.773281</TimeCreated>

<Parameter name="XMLIGNOREINVALIDTAG">
<Default>1</Default>
</Parameter>

<Parameter name="XMLIGNOREINVALIDATTRIBUTE">
<Default>1</Default>
</Parameter>

<Property name="extender">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="name">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="value">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="iscExtensions">
<Type>%DeepSee.PMML.Definition.Extension.ISCExtension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
<Parameter name="XMLTYPECONSTRAINT" value="CHOICE"/>
</Property>

<Property name="content">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN"/>
<Parameter name="XMLPROJECTION" value="CONTENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Header">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,43132.466257</TimeCreated>

<Property name="copyright">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
<Parameter name="XSDTYPE" value="xs:string"/>
</Property>

<Property name="description">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="20000"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
<Parameter name="XSDTYPE" value="xs:string"/>
</Property>

<Property name="Application">
<Type>HeaderApplication</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Annotation">
<Type>HeaderAnnotation</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Timestamp">
<Type>HeaderTimestamp</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.HeaderAnnotation">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,50922.409032</TimeCreated>

<Parameter name="XMLNAME">
<Default>Annotation</Default>
</Parameter>

<Property name="value">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="20000"/>
<Parameter name="XMLPROJECTION" value="CONTENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.HeaderApplication">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,50867.958829</TimeCreated>

<Parameter name="XMLNAME">
<Default>Application</Default>
</Parameter>

<Property name="name">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="version">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.HeaderTimestamp">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,51001.559054</TimeCreated>

<Parameter name="XMLNAME">
<Default>Timestamp</Default>
</Parameter>

<Property name="value">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="CONTENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.LocalTransformations">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62740,35469.067578</TimeCreated>

<Property name="DerivedFields">
<Type>DerivedField</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="DerivedField"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%ValidateNames">
<Final>1</Final>
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		// verify and append DerivedField entries
		for i = 1:1:..DerivedFields.Count() {
			#dim tField As DerivedField = ..DerivedFields.GetAt(i)
			
			if tField.name="" {
				set tSC = $$$ERROR($$$GeneralError, "Field name is required for DerivedField element")
				quit
			}
			
			if $d(pDictionary("fields", tField.name), tSource) {
				set tSC = $$$ERROR($$$GeneralError, "Field already defined: '"_tField.name_"' ("_tSource_")")
				quit
			}
			
			set tSC = tField.Expression.%ValidateNames(.pDictionary)
			quit:$$$ISERR(tSC)
			
			set pDictionary("fields", tField.name) = "Model"
			set:tField.dataType'="" pDictionary("fields", tField.name, "dataType") = tField.dataType
			set:tField.optype'="" pDictionary("fields", tField.name, "optype") = tField.optype
		}
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.MiningBuildTask">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,45296.726911</TimeCreated>
</Class>


<Class name="%DeepSee.PMML.Definition.MiningField">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,57027.833542</TimeCreated>

<Property name="name">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="usageType">
<Type>%DeepSee.PMML.Datatype.FieldUsageType</Type>
<InitialExpression>$$$PMMLusageTypeActive</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="optype">
<Type>%DeepSee.PMML.Datatype.OpType</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="importance">
<Type>%DeepSee.PMML.Datatype.ProbNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="outliers">
<Type>%DeepSee.PMML.Datatype.OutlierTreatmentMethod</Type>
<InitialExpression>"asIs"</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="lowValue">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="highValue">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="missingValueReplacement">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="missingValueTreatment">
<Type>%DeepSee.PMML.Datatype.MissingValueTreatmentMethod</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="invalidValueTreatment">
<Type>%DeepSee.PMML.Datatype.InvalidValueTreatmentMethod</Type>
<InitialExpression>"returnInvalid"</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Method name="%OnValidateObject">
<Description>
Adds node-specific validation checks</Description>
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if (..outliers = "asExtremeValues") && ((..lowValue="") || (..highValue="")) {
			set tSC = $$$ERROR($$$GeneralError, "highValue and lowValue are required when outliers=""asExtremevalues""")
			quit
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.MiningSchema">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,45695.967913</TimeCreated>

<Property name="MiningFields">
<Type>MiningField</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="MiningField"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%GetDictionary">
<Final>1</Final>
<FormalSpec><![CDATA[&pGlobalDictionary,*pLocalDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill pLocalDictionary
	set tSC = $$$OK
	try {
		
		merge pLocalDictionary("functions") = pGlobalDictionary("functions")
		merge pLocalDictionary("taxonomies") = pGlobalDictionary("taxonomies")
		
		// verify MiningField entries
		for i = 1:1:..MiningFields.Count() {
			set tField = ..MiningFields.GetAt(i)
			
			if '$d(pGlobalDictionary("fields", tField.name)) {
				set tSC = $$$ERROR($$$GeneralError, "Unknown field: '"_tField.name_"'")
				quit
			}
			
			merge pLocalDictionary("fields", tField.name) = pGlobalDictionary("fields", tField.name)
			
			set pLocalDictionary("fields", tField.name) = "Model"
			set:tField.usageType'="" pLocalDictionary("fields", tField.name, "usageType") = tField.usageType
			set:tField.optype'="" pLocalDictionary("fields", tField.name, "optype") = tField.optype
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.ModelExplanation">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62738,40221.272219</TimeCreated>
</Class>


<Class name="%DeepSee.PMML.Definition.ModelStats">
<Description>
This element is currently ignored</Description>
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,45865.245803</TimeCreated>
</Class>


<Class name="%DeepSee.PMML.Definition.ModelVerification">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,46019.581259</TimeCreated>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Fields">
<Type>%DeepSee.PMML.Definition.ModelVerificationFields</Type>
<Parameter name="XMLNAME" value="VerificationFields"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="InlineTable">
<Type>%DeepSee.PMML.Definition.Util.InlineTable</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="recordCount">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="fieldCount">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Method name="%OnValidateObject">
<Description>
Adds node-specific validation checks</Description>
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if ..recordCount {
			set tSC = ..InlineTable.%GetRows(.tRows)
			quit:$$$ISERR(tSC)
			
			if ($g(tRows) '= ..recordCount) {
				set tSC = $$$ERROR($$$GeneralError, "ModelVerification.recordCount attribute does not match nested InlineTable row count")
				quit
			}
		}
		
		if ..fieldCount && (..fieldCount '= ..Fields.Fields.Count()) {
			set tSC = $$$ERROR($$$GeneralError, "ModelVerification.fieldCount attribute does not ModelVerificationField count")
			quit
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.ModelVerificationField">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62882,47263.444764</TimeCreated>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="field">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="column">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="precision">
<Type>%Double</Type>
<InitialExpression>1E-6</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="zeroThreshold">
<Type>%Double</Type>
<InitialExpression>1E-16</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.ModelVerificationFields">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62882,47191.625071</TimeCreated>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Fields">
<Type>%DeepSee.PMML.Definition.ModelVerificationField</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="VerificationField"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.AbstractModel">
<Description>
Elements are defined in the subclasses, to ensure the right element sequence</Description>
<Abstract>1</Abstract>
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62735,43512.770953</TimeCreated>

<Property name="modelName">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
<Parameter name="XSDTYPE" value="xs:string"/>
</Property>

<Property name="functionName">
<Type>%DeepSee.PMML.Datatype.MiningFunction</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="algorithmName">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
<Parameter name="XSDTYPE" value="xs:string"/>
</Property>

<Property name="isScorable">
<Type>%DeepSee.PMML.Datatype.Boolean</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Method name="%ValidateNames">
<Final>1</Final>
<FormalSpec><![CDATA[&pGlobalDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tSC = ..MiningSchema.%GetDictionary(.pGlobalDictionary, .tLocalDictionary)
		quit:$$$ISERR(tSC)
		
		if $isobject(..LocalTransformations) {
			set tSC = ..LocalTransformations.%ValidateNames(.tLocalDictionary)
			quit:$$$ISERR(tSC)
		}
		
		if $isobject(..Targets) {
			set tSC = ..Targets.%ValidateNames(.tLocalDictionary)
			quit:$$$ISERR(tSC)
		}
		
		if $isobject(..Output) {
			set tSC = ..Output.%ValidateNames(.tLocalDictionary)
			quit:$$$ISERR(tSC)
		}
		
		// TODO: ModelStats
		// TODO: ModelExplanation
		// TODO: ModelVerification
		
		set tSC = ..%OnValidateNames(.tLocalDictionary)
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%OnValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%GetModelClass">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set tClassName = %compiledclass.Name
	do %code.WriteLine("	quit "_$$$QUOTE("%DeepSee.PMML.Model."_$e($p(tClassName,".",*),1,*-5)))
]]></Implementation>
</Method>

<Method name="%IsOutputFeatureSupported">
<Internal>1</Internal>
<FormalSpec>pFeature:%String,pValue:%String="",*pSC:%Status</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set pSC = $$$OK
	set tOutputField = ##class(%DeepSee.PMML.Definition.OutputField).%New()
	set tOutputField.name = "dummy", tOutputField.feature = pFeature, tOutputField.value=pValue
	quit $classmethod(..%GetModelClass(), "%IsOutputFieldSupported", $this, tOutputField, .pSC)
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Clustering.Cluster">
<Super>node</Super>
<System>3</System>
<TimeCreated>63125,39586.666994</TimeCreated>

<Property name="KohonenMap">
<Type>KohonenMap</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Coordinates">
<Type>%DeepSee.PMML.Definition.Util.AbstractArray</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
<Parameter name="XMLTYPECONSTRAINT" value="CHOICE"/>
</Property>

<Property name="Partition">
<Type>%DeepSee.PMML.Definition.Util.Partition</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Covariances">
<Type>%DeepSee.PMML.Definition.Util.Matrix</Type>
<Parameter name="XMLPROJECTION" value="WRAPPED"/>
</Property>

<Property name="id">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="name">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="size">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Parameter name="MINVAL" value="0"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Clustering.ClusteringField">
<Super>node</Super>
<System>3</System>
<TimeCreated>63125,40525.36259</TimeCreated>

<Property name="Comparisons">
<Type>%DeepSee.PMML.Definition.Util.Matrix</Type>
<Parameter name="XMLPROJECTION" value="WRAPPED"/>
</Property>

<Property name="field">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="isCenterField">
<Type>%DeepSee.PMML.Datatype.Boolean</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="fieldWeight">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="MINVAL" value="0"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="similarityScale">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="compareFunction">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="VALUELIST" value=",absDiff,gaussSim,delta,equal,table"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Clustering.ComparisonMeasure">
<Super>node</Super>
<System>3</System>
<TimeCreated>63125,40814.021653</TimeCreated>

<Property name="Metric">
<Type>ComparisonMetric</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
<Parameter name="XMLTYPECONSTRAINT" value="choice"/>
</Property>

<Property name="kind">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",distance,similarity"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="compareFunction">
<Type>%DeepSee.PMML.Datatype.String</Type>
<InitialExpression>"absDiff"</InitialExpression>
<Parameter name="VALUELIST" value=",absDiff,gaussSim,delta,equal,table"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="minimum">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="maximum">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Clustering.ComparisonMetric">
<Abstract>1</Abstract>
<Super>node</Super>
<System>3</System>
<TimeCreated>63125,40677.082104</TimeCreated>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Clustering.KohonenMap">
<Super>node</Super>
<System>3</System>
<TimeCreated>63125,39738.946326</TimeCreated>

<Property name="coord1">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="coord2">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="coord3">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Clustering.binarySimilarity">
<Super>ComparisonMetric</Super>
<System>3</System>
<TimeCreated>63125,41102.958866</TimeCreated>

<Property name="c00">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Required>1</Required>
<Parameter name="XMLNAME" value="c00-parameter"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="c01">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Required>1</Required>
<Parameter name="XMLNAME" value="c01-parameter"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="c10">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Required>1</Required>
<Parameter name="XMLNAME" value="c10-parameter"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="c11">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Required>1</Required>
<Parameter name="XMLNAME" value="c11-parameter"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="d00">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Required>1</Required>
<Parameter name="XMLNAME" value="d00-parameter"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="d01">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Required>1</Required>
<Parameter name="XMLNAME" value="d01-parameter"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="d10">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Required>1</Required>
<Parameter name="XMLNAME" value="d10-parameter"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="d11">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Required>1</Required>
<Parameter name="XMLNAME" value="d11-parameter"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Clustering.chebychev">
<Super>ComparisonMetric</Super>
<System>3</System>
<TimeCreated>63125,40920.499499</TimeCreated>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Clustering.cityBlock">
<Super>ComparisonMetric</Super>
<System>3</System>
<TimeCreated>63125,40903.694914</TimeCreated>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Clustering.euclidean">
<Super>ComparisonMetric</Super>
<System>3</System>
<TimeCreated>63125,40837.610937</TimeCreated>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Clustering.jaccard">
<Super>ComparisonMetric</Super>
<System>3</System>
<TimeCreated>63125,40974.227392</TimeCreated>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Clustering.minkowsky">
<Super>ComparisonMetric</Super>
<System>3</System>
<TimeCreated>63125,40934.444929</TimeCreated>

<Property name="p">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Required>1</Required>
<Parameter name="XMLNAME" value="p-parameter"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Clustering.node">
<Abstract>1</Abstract>
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>63125,39446.656805</TimeCreated>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Clustering.simpleMatching">
<Super>ComparisonMetric</Super>
<System>3</System>
<TimeCreated>63125,40955.24347</TimeCreated>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Clustering.squaredEuclidean">
<Super>ComparisonMetric</Super>
<System>3</System>
<TimeCreated>63125,40881.29374</TimeCreated>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Clustering.tanimoto">
<Super>ComparisonMetric</Super>
<System>3</System>
<TimeCreated>63125,40990.69881</TimeCreated>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.ClusteringModel">
<Super>AbstractModel</Super>
<System>3</System>
<TimeCreated>63125,40250.032971</TimeCreated>

<Property name="modelClass">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",centerBased,distributionBased"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="numberOfClusters">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="MiningSchema">
<Type>%DeepSee.PMML.Definition.MiningSchema</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Output">
<Type>%DeepSee.PMML.Definition.Output</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelStats">
<Type>%DeepSee.PMML.Definition.ModelStats</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelExplanation">
<Type>%DeepSee.PMML.Definition.ModelExplanation</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Targets">
<Type>%DeepSee.PMML.Definition.Targets</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="LocalTransformations">
<Type>%DeepSee.PMML.Definition.LocalTransformations</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ComparisonMeasure">
<Type>%DeepSee.PMML.Definition.Models.Clustering.ComparisonMeasure</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Fields">
<Type>%DeepSee.PMML.Definition.Models.Clustering.ClusteringField</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="ClusteringField"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="MissingValueWeights">
<Type>%DeepSee.PMML.Definition.Util.AbstractArray</Type>
<Parameter name="XMLPROJECTION" value="WRAPPED"/>
<Parameter name="XMLTYPECONSTRAINT" value="CHOICE"/>
</Property>

<Property name="Clusters">
<Type>%DeepSee.PMML.Definition.Models.Clustering.Cluster</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="Cluster"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelVerification">
<Type>%DeepSee.PMML.Definition.ModelVerification</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%OnValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		for i = 1:1:..Fields.Count() {
			set tField = ..Fields.GetAt(i)
			if '$d(pDictionary("fields", tField.field)) {
				set tSC = $$$ERROR($$$GeneralError, "Unknown field name in ClusteringField element: '"_tField.field_"'")
				quit
			}
			set pDictionary("clusteringFields", tField.field) = ""
		}
		quit:$$$ISERR(tSC)
		
		for i = 1:1:..Clusters.Count() {
			set tClusterId = ..Clusters.GetAt(i).id
			continue:tClusterId=""
			if $d(pDictionary("clusters", tClusterId)) {
				set tSC = $$$ERROR($$$GeneralError, "Duplicate cluster ID: '"_tClusterId_"'")
				quit
			}
			set pDictionary("clusters", tClusterId) = i
		}
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Description>
Adds node-specific validation checks</Description>
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tClusterCount = ..Clusters.Count()
		if (tClusterCount '= ..numberOfClusters) {
			set tSC = $$$ERROR($$$GeneralError, "numberOfClusters attribute should match <Cluster> element count")
			quit
		}
		
		if (..modelClass="") {
			set tSC = $$$ERROR($$$GeneralError, "modelClass is a mandatory attribute")
			quit
		} elseif (..modelClass="centerBased") {
			for i = 1:1:tClusterCount {
				if '$isobject(..Clusters.GetAt(i).Coordinates) {
					set tSC = $$$ERROR($$$GeneralError, "Center-based clustering models should define coordinates for each Cluster")
					quit
				}
			}
			quit:$$$ISERR(tSC)
		}
		
		for i = 1:1:tClusterCount {
			i
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.GeneralRegression.BaseCumHazardTables">
<Super>node</Super>
<System>3</System>
<TimeCreated>62738,40534.801988</TimeCreated>

<Property name="maxTime">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="BaselineStratum">
<Type>BaselineStratum</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="BaselineCells">
<Type>BaselineCell</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="BaselineCell"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.GeneralRegression.BaselineCell">
<Super>node</Super>
<System>3</System>
<TimeCreated>62738,38697.334089</TimeCreated>

<Property name="time">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="cumHazard">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.GeneralRegression.BaselineStratum">
<Super>node</Super>
<System>3</System>
<TimeCreated>62738,38856.095312</TimeCreated>

<Property name="value">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="label">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="maxTime">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Cells">
<Type>BaselineCell</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="BaselineCell"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.GeneralRegression.Categories">
<Super>node</Super>
<System>3</System>
<TimeCreated>62738,37452.95341</TimeCreated>

<Property name="Categories">
<Type>Category</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="Category"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.GeneralRegression.Category">
<Super>node</Super>
<System>3</System>
<TimeCreated>62738,37501.753178</TimeCreated>

<Property name="value">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.GeneralRegression.CovariateList">
<Super>node</Super>
<System>3</System>
<TimeCreated>62738,37203.773257</TimeCreated>

<Property name="Predictors">
<Type>Predictor</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="Predictor"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.GeneralRegression.EventValues">
<Super>node</Super>
<System>3</System>
<TimeCreated>62738,39151.893947</TimeCreated>

<Property name="Values">
<Type>%DeepSee.PMML.Definition.Util.Value</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="Value"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Intervals">
<Type>%DeepSee.PMML.Definition.Util.Interval</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="Interval"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.GeneralRegression.FactorList">
<Super>node</Super>
<System>3</System>
<TimeCreated>62738,37154.599973</TimeCreated>

<Property name="Predictors">
<Type>Predictor</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="Predictor"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.GeneralRegression.PCell">
<Super>node</Super>
<System>3</System>
<TimeCreated>62738,38549.230492</TimeCreated>

<Property name="targetCategory">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="parameterName">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="beta">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="df">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.GeneralRegression.PPCell">
<Super>node</Super>
<System>3</System>
<TimeCreated>62738,38048.376242</TimeCreated>

<Property name="value">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="predictorName">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="parameterName">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="targetCategory">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.GeneralRegression.PPCovCell">
<Super>node</Super>
<System>3</System>
<TimeCreated>62738,38210.536813</TimeCreated>

<Property name="pRow">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="pCol">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="tRow">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="tCol">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="value">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="targetCategory">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.GeneralRegression.PPCovMatrix">
<Super>node</Super>
<System>3</System>
<TimeCreated>62738,38282.984041</TimeCreated>

<Property name="type">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="VALUELIST" value=",model,robust"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Cells">
<Type>PPCovCell</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="PPCovCell"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.GeneralRegression.PPMatrix">
<Super>node</Super>
<System>3</System>
<TimeCreated>62738,38050.031291</TimeCreated>

<Property name="Cells">
<Type>PPCell</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="PPCell"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.GeneralRegression.ParamMatrix">
<Super>node</Super>
<System>3</System>
<TimeCreated>62738,38595.135018</TimeCreated>

<Property name="Cells">
<Type>PCell</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="PCell"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.GeneralRegression.Parameter">
<Super>node</Super>
<System>3</System>
<TimeCreated>62738,36107.154829</TimeCreated>

<Property name="name">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="label">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="referencePoint">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.GeneralRegression.ParameterList">
<Super>node</Super>
<System>3</System>
<TimeCreated>62738,36109.297015</TimeCreated>

<Property name="Parameters">
<Type>Parameter</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="Parameter"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.GeneralRegression.Predictor">
<Super>node</Super>
<System>3</System>
<TimeCreated>62738,37130.246302</TimeCreated>

<Property name="name">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="contrastMatrixType">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Categories">
<Type>Categories</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ContrastMatrix">
<Type>%DeepSee.PMML.Definition.Util.Matrix</Type>
<Parameter name="XMLNAME" value="Matrix"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%OnValidateObject">
<Description>
Adds node-specific validation checks</Description>
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		// TODO: contrast matrix input checking?
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.GeneralRegression.node">
<Abstract>1</Abstract>
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62738,37196.1562</TimeCreated>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.GeneralRegressionModel">
<Super>AbstractModel</Super>
<System>3</System>
<TimeCreated>62738,40925.577419</TimeCreated>

<Property name="targetVariableName">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="modelType">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",regression,generalLinear,multinomialLogistic,ordinalMultinomial,generalizedLinear,CoxRegression"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="targetReferenceCategory">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="cumulativeLink">
<Type>%DeepSee.PMML.Datatype.CumulativeLinkFunction</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="linkFunction">
<Type>%DeepSee.PMML.Datatype.LinkFunction</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="linkParameter">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="trialsVariable">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="trialsValue">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="distribution">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="VALUELIST" value=",binomial,gamma,igauss,negbin,normal,poisson,tweedie"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="distParameter">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="offsetVariable">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="offsetValue">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="modelDF">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="endTimeVariable">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="startTimeVariable">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="subjectIDVariable">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="statusVariable">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="baselineStrataVariable">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="MiningSchema">
<Type>%DeepSee.PMML.Definition.MiningSchema</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Output">
<Type>%DeepSee.PMML.Definition.Output</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelStats">
<Type>%DeepSee.PMML.Definition.ModelStats</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelExplanation">
<Type>%DeepSee.PMML.Definition.ModelExplanation</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Targets">
<Type>%DeepSee.PMML.Definition.Targets</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="LocalTransformations">
<Type>%DeepSee.PMML.Definition.LocalTransformations</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ParameterList">
<Type>%DeepSee.PMML.Definition.Models.GeneralRegression.ParameterList</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="FactorList">
<Type>%DeepSee.PMML.Definition.Models.GeneralRegression.FactorList</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="CovariateList">
<Type>%DeepSee.PMML.Definition.Models.GeneralRegression.CovariateList</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="PPMatrix">
<Type>%DeepSee.PMML.Definition.Models.GeneralRegression.PPMatrix</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="PPCovMatrix">
<Type>%DeepSee.PMML.Definition.Models.GeneralRegression.PPCovMatrix</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ParamMatrix">
<Type>%DeepSee.PMML.Definition.Models.GeneralRegression.ParamMatrix</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="EventValues">
<Type>%DeepSee.PMML.Definition.Models.GeneralRegression.EventValues</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="BaseCumHazardTables">
<Type>%DeepSee.PMML.Definition.Models.GeneralRegression.BaseCumHazardTables</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelVerification">
<Type>%DeepSee.PMML.Definition.ModelVerification</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%OnValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if (..targetVariableName'="") && '$$$PMMLusageTypeIsTarget(pDictionary("fields", ..targetVariableName, "usageType")) {
			set tSC = $$$ERROR($$$GeneralError, "if set, targetVariableName should correspond to a predicted MiningField")
			quit
		}
		
		if (..modelType'="CoxRegression") && $isobject(..ParameterList) && '..ParameterList.Parameters.Count() {
			set tSC = $$$ERROR($$$GeneralError, "At least one Parameter should be defined for a General Regression model (except when modelType=CoxRegression)")
			quit
		}
		
		if $isobject(..ParameterList) {
			for i = 1:1:..ParameterList.Parameters.Count() {
				set tParameter = ..ParameterList.Parameters.GetAt(i)
				set pDictionary("parameters", tParameter.name) = ""
			}
		}
		
		if $isobject(..FactorList) {
			for i = 1:1:..FactorList.Predictors.Count() {
				set tPredictor = ..FactorList.Predictors.GetAt(i)
				if '$d(pDictionary("fields", tPredictor.name)) {
					set tSC = $$$ERROR($$$GeneralError, "Unknown predictor field in FactorList: '"_tPredictor.name_"'")
					quit
				}
				if $g(pDictionary("fields", tPredictor.name, "optype"))'="categorical" {
					set tSC = $$$ERROR($$$GeneralError, "Predictors in FactorList should be categorical")
					quit
				}
				set pDictionary("predictors", tPredictor.name) = ""
			}
			quit:$$$ISERR(tSC)
		}
		
		if $isobject(..CovariateList) {
			for i = 1:1:..CovariateList.Predictors.Count() {
				set tPredictor = ..CovariateList.Predictors.GetAt(i)
				if '$d(pDictionary("fields", tPredictor.name)) {
					set tSC = $$$ERROR($$$GeneralError, "Unknown predictor field in CovariateList: '"_tPredictor.name_"'")
					quit
				}
				set pDictionary("predictors", tPredictor.name) = ""
			}
			quit:$$$ISERR(tSC)
		}
		
		if (..functionName'="classification") && (..functionName'="regression") {
			set tSC = $$$ERROR($$$GeneralError, "functionName can only be 'classification' or 'regression'")
			quit
		}
		
		for tProp = "trialsVariable", "offsetVariable", "endTimeVariable", "startTimeVariable", "subjectIDVariable", "statusVariable", "baselineStrataVariable" {
			set tPropValue = $property($this, tProp)
			if (tPropValue'="") && '$d(pDictionary("fields", tPropValue)) {
				set tSC = $$$ERROR($$$GeneralError, "Unknown field: '"_tPropValue_"' ("_tProp_")")
				quit
			}
		}
		quit:$$$ISERR(tSC)
		
		if (..trialsVariable'="") && (..trialsValue'="") {
			set tSC = $$$ERROR($$$GeneralError, "Only trialsVariable or trialsValue can be present, not both")
			quit
		}
		
		if (..offsetVariable'="") && (..offsetValue'="") {
			set tSC = $$$ERROR($$$GeneralError, "Only offsetVariable or offsetValue can be present, not both")
			quit
		}
		
		if $isobject(..PPMatrix) {
			for i = 1:1:..PPMatrix.Cells.Count() {
				set tCell = ..PPMatrix.Cells.GetAt(i)
				if '$d(pDictionary("predictors", tCell.predictorName)) {
					set tSC = $$$ERROR($$$GeneralError, "Unknown predictor field: '"_tCell.predictorName_"'")
					quit
				}
				if '$d(pDictionary("parameters", tCell.parameterName)) {
					set tSC = $$$ERROR($$$GeneralError, "Unknown parameter field: '"_tCell.parameterName_"'")
					quit
				}
			}
			quit:$$$ISERR(tSC)
		}
		
		if $isobject(..ParamMatrix) {
			for i = 1:1:..ParamMatrix.Cells.Count() {
				set tCell = ..ParamMatrix.Cells.GetAt(i)
				if '$d(pDictionary("parameters", tCell.parameterName)) {
					set tSC = $$$ERROR($$$GeneralError, "Unknown parameter field: '"_tCell.parameterName_"'")
					quit
				}
			}
			quit:$$$ISERR(tSC)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.MiningModel">
<Super>AbstractModel</Super>
<System>3</System>
<TimeCreated>63060,57367.427283</TimeCreated>

<Property name="MiningSchema">
<Type>%DeepSee.PMML.Definition.MiningSchema</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Output">
<Type>%DeepSee.PMML.Definition.Output</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelStats">
<Type>%DeepSee.PMML.Definition.ModelStats</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelExplanation">
<Type>%DeepSee.PMML.Definition.ModelExplanation</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Targets">
<Type>%DeepSee.PMML.Definition.Targets</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="LocalTransformations">
<Type>%DeepSee.PMML.Definition.LocalTransformations</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Segmentation">
<Type>%DeepSee.PMML.Definition.Segmentation</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelVerification">
<Type>%DeepSee.PMML.Definition.ModelVerification</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%GetModelClass">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit "%DeepSee.PMML.Model.Composite"
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		quit:'$isobject(..Segmentation)
		set tSegmentCount = ..Segmentation.Segments.Count()
		set tMethod = ..Segmentation.multipleModelMethod
		
		if (tMethod'="modelChain") {
			// all models should have the same mining function
			for i = 1:1:tSegmentCount {
				if (..Segmentation.Segments.GetAt(i).Model.functionName'=..functionName) {
					set tSC = $$$ERROR($$$GeneralError, "All models in a Segmentation must have the same mining function")
					quit
				}
			}
			quit:$$$ISERR(tSC)
		} else {
			if (..Segmentation.Segments.GetAt(tSegmentCount).Model.functionName'=..functionName) {
				set tSC = $$$ERROR($$$GeneralError, "If multipleModelMethod=""modelChain"", the last model in the chain should have the same mining function as the MiningModel")
				quit
			}
		}
		
		if ((..functionName="clustering") && '("majorityVote,weightedMajorityVote,selectFirst,selectAll,modelChain"[tMethod)) ||
		   ((..functionName="regression") && '("average,weightedAverage,median,sum,selectFirst,selectAll,modelChain"[tMethod)) ||
		   ((..functionName="classification") && (tMethod="sum")) {
			set tSC = $$$ERROR($$$GeneralError, "Invalid multipleModelMethod for function '"_..functionName_"'")
			quit
		}
		
		if (tMethod="selectAll") {
			set tSC = $$$ERROR($$$GeneralError, "multipleModelMethod=""selectAll"" is not supported")
			quit
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%OnValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		quit:'$isobject(..Segmentation)
		
		for i = 1:1:..Segmentation.Segments.Count() {
			set tSegment = ..Segmentation.Segments.GetAt(i)
			
			set tSC = tSegment.Predicate.%ValidateNames(.pDictionary)
			quit:$$$ISERR(tSC)
			
			set tSC = tSegment.Model.%ValidateNames(.pDictionary)
			quit:$$$ISERR(tSC)
			
			if (..Segmentation.multipleModelMethod="modelChain") && $isobject(tSegment.Model.Output) {
				for k = 1:1:tSegment.Model.Output.OutputFields.Count() {
					set tFieldName = tSegment.Model.Output.OutputFields.GetAt(k).name
					continue:$d(pDictionary("fields", tFieldName))
					set pDictionary("fields", tFieldName) = "PreviousModel"
				}
			}
		}
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.NaiveBayes.BayesInput">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62774,34278.914367</TimeCreated>

<Property name="DerivedField">
<Type>%DeepSee.PMML.Definition.DerivedField</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="PairCounts">
<Type>PairCounts</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="fieldName">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.NaiveBayes.BayesInputs">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62774,33614.433112</TimeCreated>

<Property name="BayesInput">
<Type>BayesInput</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.NaiveBayes.BayesOutput">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62774,33690.525634</TimeCreated>

<Property name="TargetValueCounts">
<Type>TargetValueCounts</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="fieldName">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.NaiveBayes.PairCounts">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62774,34150.710996</TimeCreated>

<Property name="TargetValueCounts">
<Type>TargetValueCounts</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="value">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.NaiveBayes.TargetValueCount">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62774,34262.377981</TimeCreated>

<Property name="value">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="count">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.NaiveBayes.TargetValueCounts">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>4</System>
<TimeCreated>62774,34184.170287</TimeCreated>

<Property name="Counts">
<Type>TargetValueCount</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="TargetValueCount"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.NaiveBayesModel">
<Super>AbstractModel</Super>
<System>3</System>
<TimeCreated>62774,33242.732384</TimeCreated>

<Property name="threshold">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="MiningSchema">
<Type>%DeepSee.PMML.Definition.MiningSchema</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Output">
<Type>%DeepSee.PMML.Definition.Output</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelStats">
<Type>%DeepSee.PMML.Definition.ModelStats</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelExplanation">
<Type>%DeepSee.PMML.Definition.ModelExplanation</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Targets">
<Type>%DeepSee.PMML.Definition.Targets</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="LocalTransformations">
<Type>%DeepSee.PMML.Definition.LocalTransformations</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="BayesInputs">
<Type>%DeepSee.PMML.Definition.Models.NaiveBayes.BayesInputs</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="BayesOutput">
<Type>%DeepSee.PMML.Definition.Models.NaiveBayes.BayesOutput</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelVerification">
<Type>%DeepSee.PMML.Definition.ModelVerification</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%OnValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		#dim tBayesInput As %DeepSee.PMML.Definition.Models.NaiveBayes.BayesInput
		for i = 1:1:..BayesInputs.BayesInput.Count() {
			set tBayesInput = ..BayesInputs.BayesInput.GetAt(i)
			if (tBayesInput.fieldName'="") && '$d(pDictionary("fields", tBayesInput.fieldName)) {
				set tSC = $$$ERROR($$$GeneralError, "BayesInput references a field that doesn't exist: '"_tBayesInput.fieldName_"'")
				quit
			}
			if $isobject(tBayesInput.DerivedField) {
				if '$isobject(tBayesInput.DerivedField.Expression) {
					set tSC = $$$ERROR($$$GeneralError, "BayesInput's DerivedField should have an Expression element")
					quit
				} elseif ('tBayesInput.DerivedField.Expression.%IsA("%DeepSee.PMML.Definition.Util.Discretize")) {
					set tSC = $$$ERROR($$$GeneralError, "BayesInput's DerivedField can only use Discretize expressions.")
					quit
				}
				set tSC = tBayesInput.DerivedField.Expression.%ValidateNames(.pDictionary)
				quit:$$$ISERR(tSC)
			}
		}
		quit:$$$ISERR(tSC)
		
		
		if (..BayesOutput.fieldName'="") && '$d(pDictionary("fields", ..BayesOutput.fieldName)) {
			set tSC = $$$ERROR($$$GeneralError, "BayesOutput references a field that doesn't exist: '"_..BayesOutput.fieldName_"'")
			quit
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.NeuralNetwork.Connection">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>63126,56279.23886</TimeCreated>

<Parameter name="XMLNAME">
<Default>Con</Default>
</Parameter>

<Property name="from">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="weight">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.NeuralNetwork.NeuralInput">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>63126,56116.779228</TimeCreated>

<Property name="DerivedField">
<Type>%DeepSee.PMML.Definition.DerivedField</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="id">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.NeuralNetwork.NeuralInputs">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>63126,56277.896944</TimeCreated>

<Property name="numberOfInputs">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Parameter name="MINVAL" value="0"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Inputs">
<Type>NeuralInput</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="NeuralInput"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.NeuralNetwork.NeuralLayer">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>63126,56277.549955</TimeCreated>

<Property name="numberOfNeurons">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Parameter name="MINVAL" value="0"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="activationFunction">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="VALUELIST" value=",threshold,logistic,tanh,identity,exponential,reciprocal,square,Gauss,sine,cosine,Elliot,arctan,radialBasis"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="normalizationMethod">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="VALUELIST" value=",none,simplemax,softmax"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="threshold">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="width">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="altitude">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Neurons">
<Type>Neuron</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="Neuron"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.NeuralNetwork.NeuralOutput">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>63126,56278.581524</TimeCreated>

<Property name="DerivedField">
<Type>%DeepSee.PMML.Definition.DerivedField</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="outputNeuron">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.NeuralNetwork.NeuralOutputs">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>63126,56278.236511</TimeCreated>

<Property name="numberOfOutputs">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Parameter name="MINVAL" value="0"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Outputs">
<Type>NeuralOutput</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="NeuralOutput"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.NeuralNetwork.Neuron">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>63126,56278.921594</TimeCreated>

<Property name="Connections">
<Type>Connection</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="Con"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="id">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="bias">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="width">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="altitude">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.NeuralNetwork">
<Super>AbstractModel</Super>
<System>3</System>
<TimeCreated>63126,56045.652455</TimeCreated>

<Property name="activationFunction">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",threshold,logistic,tanh,identity,exponential,reciprocal,square,Gauss,sine,cosine,Elliot,arctan,radialBasis"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="normalizationMethod">
<Type>%DeepSee.PMML.Datatype.String</Type>
<InitialExpression>"none"</InitialExpression>
<Parameter name="VALUELIST" value=",none,simplemax,softmax"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="threshold">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="width">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="altitude">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="numberOfLayers">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Parameter name="MINVAL" value="0"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="MiningSchema">
<Type>%DeepSee.PMML.Definition.MiningSchema</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Output">
<Type>%DeepSee.PMML.Definition.Output</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelStats">
<Type>%DeepSee.PMML.Definition.ModelStats</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelExplanation">
<Type>%DeepSee.PMML.Definition.ModelExplanation</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Targets">
<Type>%DeepSee.PMML.Definition.Targets</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="LocalTransformations">
<Type>%DeepSee.PMML.Definition.LocalTransformations</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="NeuralInputs">
<Type>%DeepSee.PMML.Definition.Models.NeuralNetwork.NeuralInputs</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Layers">
<Type>%DeepSee.PMML.Definition.Models.NeuralNetwork.NeuralLayer</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="NeuralLayer"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="NeuralOutputs">
<Type>%DeepSee.PMML.Definition.Models.NeuralNetwork.NeuralOutputs</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelVerification">
<Type>%DeepSee.PMML.Definition.ModelVerification</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%GetModelClass">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit "%DeepSee.PMML.Model.NeuralNetwork"
]]></Implementation>
</Method>

<Method name="%OnValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if $isobject(..NeuralInputs) {
			for i = 1:1:..NeuralInputs.Inputs.Count() {
				set tInput = ..NeuralInputs.Inputs.GetAt(i)
				set tSC = tInput.DerivedField.Expression.%ValidateNames(.pDictionary)
				quit:$$$ISERR(tSC)
				
				if ($d(pDictionary("neuron", tInput.id))) {
					set tSC = $$$ERROR($$$GeneralError, "Duplicate neuron ID: '"_tInput.id_"'")
					quit
				}
				set pDictionary("neuron", tInput.id) = "input"
			}
			quit:$$$ISERR(tSC)
		}
		
		for i = 1:1:..Layers.Count() {
			set tLayer = ..Layers.GetAt(i)
			for j = 1:1:tLayer.Neurons.Count() {
				set tNeuron = tLayer.Neurons.GetAt(j)
				if $d(pDictionary("neuron", tNeuron.id)) {
					set tSC = $$$ERROR($$$GeneralError, "Duplicate neuron ID: '"_tNeuron.id_"'")
					quit
				}
				set pDictionary("neuron", tNeuron.id) = "layer "_i
				
				for k = 1:1:tNeuron.Connections.Count() {
					set tFrom = tNeuron.Connections.GetAt(k).from
					if '$d(pDictionary("neuron", tFrom)) {
						set tSC = $$$ERROR($$$GeneralError, "Unknown neuron ID in Con element: '"_tFrom_"'")
						quit
					}
				}
				quit:$$$ISERR(tSC)
			}
			quit:$$$ISERR(tSC)
		}
		quit:$$$ISERR(tSC)
		
		if $isobject(..NeuralOutputs) {
			for i = 1:1:..NeuralOutputs.Outputs.Count() {
				set tOutput = ..NeuralOutputs.Outputs.GetAt(i)
				
				// TODO: is this OK? it won't find output field name references!
				//set tSC = tOutput.DerivedField.Expression.%ValidateNames(.pDictionary)
				//quit:$$$ISERR(tSC)
				
				if '$d(pDictionary("neuron", tOutput.outputNeuron)) {
					set tSC = $$$ERROR($$$GeneralError, "Unknown output neuron ID: '"_tOutput.outputNeuron_"'")
					quit
				}
			}
			quit:$$$ISERR(tSC)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Description>
Adds node-specific validation checks</Description>
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if '$isobject(..NeuralInputs) {
			set tSC = $$$ERROR($$$GeneralError, "NeuralInputs is a required element")
			quit
		}
		
		if (..NeuralInputs.numberOfInputs '= ..NeuralInputs.Inputs.Count()) {
			set tSC = $$$ERROR($$$GeneralError, "NeuralInputs numberOfInputs attribute does not match NeuralInput element count")
			quit
		}
		
		if '$isobject(..NeuralOutputs) {
			set tSC = $$$ERROR($$$GeneralError, "NeuralOutputs is a required element")
			quit
		}
		
		if (..NeuralOutputs.numberOfOutputs '= ..NeuralOutputs.Outputs.Count()) {
			set tSC = $$$ERROR($$$GeneralError, "NeuralOutputs numberOfOutputs attribute does not match NeuralOutput element count")
			quit
		}
		
		if (..numberOfLayers '= ..Layers.Count()) {
			set tSC = $$$ERROR($$$GeneralError, "numberOfLayers attribute does not match NeuralLayer element count")
			quit
		}
			
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Regression.CategoricalPredictor">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62917,57473.735134</TimeCreated>

<Property name="name">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="value">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="coefficient">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Regression.NumericPredictor">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62917,57447.226354</TimeCreated>

<Property name="name">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="exponent">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="coefficient">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Regression.PredictorTerm">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62917,57392.334606</TimeCreated>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="FieldRefs">
<Type>%DeepSee.PMML.Definition.Util.FieldRef</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="FieldRef"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="name">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="coefficient">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Regression.RegressionTable">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62917,57565.391917</TimeCreated>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="NumericPredictors">
<Type>%DeepSee.PMML.Definition.Models.Regression.NumericPredictor</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="NumericPredictor"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="CategoricalPredictors">
<Type>%DeepSee.PMML.Definition.Models.Regression.CategoricalPredictor</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="CategoricalPredictor"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="PredictorTerms">
<Type>%DeepSee.PMML.Definition.Models.Regression.PredictorTerm</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="PredictorTerm"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="intercept">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="targetCategory">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.RegressionModel">
<Super>%DeepSee.PMML.Definition.Models.AbstractModel</Super>
<System>3</System>
<TimeCreated>62917,57103.318487</TimeCreated>

<Property name="modelType">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="VALUELIST" value=",linearRegression,stepwisePolynomialRegression,logisticRegression"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="targetFieldName">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="normalizationMethod">
<Type>%DeepSee.PMML.Datatype.String</Type>
<InitialExpression>"none"</InitialExpression>
<Parameter name="VALUELIST" value=",none,simplemax,softmax,logit,probit,cloglog,exp,loglog,cauchit"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="MiningSchema">
<Type>%DeepSee.PMML.Definition.MiningSchema</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Output">
<Type>%DeepSee.PMML.Definition.Output</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelStats">
<Type>%DeepSee.PMML.Definition.ModelStats</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelExplanation">
<Type>%DeepSee.PMML.Definition.ModelExplanation</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Targets">
<Type>%DeepSee.PMML.Definition.Targets</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="LocalTransformations">
<Type>%DeepSee.PMML.Definition.LocalTransformations</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="RegressionTables">
<Type>%DeepSee.PMML.Definition.Models.Regression.RegressionTable</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="RegressionTable"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelVerification">
<Type>%DeepSee.PMML.Definition.ModelVerification</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%OnValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tTargetFieldName = ..targetFieldName
		if (tTargetFieldName = "") {
			for {
				set tTargetFieldName = $order(pDictionary("fields", tTargetFieldName))
				quit:tTargetFieldName=""
				quit:$$$PMMLusageTypeIsTarget($g(pDictionary("fields", tTargetFieldName, "usageType")))
			}
		} elseif '$$$PMMLusageTypeIsTarget($g(pDictionary("fields", ..targetFieldName, "usageType"))) {
			set tSC = $$$ERROR($$$GeneralError, "if set, targetVariableName should correspond to a predicted MiningField")
			quit
		}
		
		if (tTargetFieldName="") {
			set tSC = $$$ERROR($$$GeneralError, "No target field for this model")
			quit
		}
		
		#dim tRegTable As %DeepSee.PMML.Definition.Models.Regression.RegressionTable
		for i = 1:1:..RegressionTables.Count() {
			set tRegTable = ..RegressionTables.GetAt(i)
			
			if ($g(pDictionary("fields", tTargetFieldName, "optype"))'="continuous") {
				if (tRegTable.targetCategory="") {
					set tSC = $$$ERROR($$$GeneralError, "targetCategory is a required field for RegressionTable")
					quit
				}
				
				if $d(tCategories(tRegTable.targetCategory)) {
					set tSC = $$$ERROR($$$GeneralError, "targetCategory must be unique for each RegressionTable in a RegressionModel")
					quit
				}
				set tCategories(tRegTable.targetCategory) = ""
			}
			
			
			// Validate field refs
			#dim tNumPredictor As %DeepSee.PMML.Definition.Models.Regression.NumericPredictor
			for j = 1:1:tRegTable.NumericPredictors.Count() {
				set tNumPredictor = tRegTable.NumericPredictors.GetAt(j)
				if '$d(pDictionary("fields", tNumPredictor.name)) {
					set tSC = $$$ERROR($$$GeneralError, "NumericPredictor name not found in the Data Dictionary: '"_tNumPredictor.name_"'")
					quit
				}
			}
			for j = 1:1:tRegTable.CategoricalPredictors.Count() {
				set tCatPredictor = tRegTable.CategoricalPredictors.GetAt(j)
				if '$d(pDictionary("fields", tCatPredictor.name)) {
					set tSC = $$$ERROR($$$GeneralError, "CategoricalPredictor name not found in the Data Dictionary: '"_tCatPredictor.name_"'")
					quit
				}
			}
			#dim tPredictorTerm As %DeepSee.PMML.Definition.Models.Regression.PredictorTerm
			for j = 1:1:tRegTable.PredictorTerms.Count() {
				set tPredictorTerm = tRegTable.PredictorTerms.GetAt(j)
				
				for k = 1:1:tPredictorTerm.FieldRefs.Count() {
					set tFieldRef = tPredictorTerm.FieldRefs.GetAt(k)
					if '$d(pDictionary("fields", tFieldRef.field)) {
						set tSC = $$$ERROR($$$GeneralError, "PredictorTerm references a field not found in the Data Dictionary: '"_tFieldRef.field_"'")
						quit
					}
				}
				quit:$$$ISERR(tSC)
				
				if (tPredictorTerm.name'="") && $d(pDictionary("fields", tPredictorTerm.name)) {
					set tSC = $$$ERROR($$$GeneralError, "PredictorTerm name should be unique: '"_tPredictorTerm.name_"'")
					quit
				}
			}
		}
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.RuleSet.CompoundRule">
<Super>Rule</Super>
<System>3</System>
<TimeCreated>63126,42503.568905</TimeCreated>

<Property name="Rules">
<Type>Rule</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
<Parameter name="XMLTYPECONSTRAINT" value="CHOICE"/>
</Property>

<Method name="%OnValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tRuleCount = ..Rules.Count() 
		for i = 1:1:tRuleCount {
			set tSC = ..Rules.GetAt(i).%ValidateNames(.pDictionary)
			quit:$$$ISERR(tSC)
		}
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.RuleSet.Rule">
<Abstract>1</Abstract>
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>63126,42445.44963</TimeCreated>

<Property name="Predicate">
<Type>%DeepSee.PMML.Definition.Util.Predicate</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
<Parameter name="XMLTYPECONSTRAINT" value="CHOICE"/>
</Property>

<Method name="%ValidateNames">
<Final>1</Final>
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tSC = ..Predicate.%ValidateNames(.pDictionary)
		quit:$$$ISERR(tSC)
		
		set tSC = ..%OnValidateNames(.pDictionary)
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%OnValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.RuleSet.RuleSelectionMethod">
<Super>%DeepSee.PMML.Definition.node</Super>
<System>3</System>
<TimeCreated>63126,42430.065274</TimeCreated>

<Property name="criterion">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",weightedSum,weightedMax,firstHit"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.RuleSet.RuleSet">
<Super>%DeepSee.PMML.Definition.node</Super>
<System>3</System>
<TimeCreated>63126,42401.957903</TimeCreated>

<Property name="RuleSelectionMethod">
<Type>RuleSelectionMethod</Type>
<Collection>list</Collection>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ScoreDistributions">
<Type>%DeepSee.PMML.Definition.Models.Trees.ScoreDistribution</Type>
<Parameter name="XMLNAME" value="ScoreDistribution"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Rules">
<Type>Rule</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
<Parameter name="XMLTYPECONSTRAINT" value="CHOICE"/>
</Property>

<Property name="recordCount">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="nbCorrect">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="defaultScore">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="defaultConfidence">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Method name="%OnValidateObject">
<Description>
Adds node-specific validation checks</Description>
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if '..RuleSelectionMethod.Count() {
			set tSC = $$$ERROR($$$GeneralError, "RuleSetModel requires a RuleSelectionMethod element")
			quit
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.RuleSet.SimpleRule">
<Super>Rule</Super>
<System>3</System>
<TimeCreated>63126,42478.507036</TimeCreated>

<Property name="ScoreDistributions">
<Type>%DeepSee.PMML.Definition.Models.Trees.ScoreDistribution</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="ScoreDistribution"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="id">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="score">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="recordCount">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="nbCorrect">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="confidence">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="weight">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.RuleSetModel">
<Super>AbstractModel</Super>
<System>3</System>
<TimeCreated>63126,43187.06184</TimeCreated>

<Property name="MiningSchema">
<Type>%DeepSee.PMML.Definition.MiningSchema</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Output">
<Type>%DeepSee.PMML.Definition.Output</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelStats">
<Type>%DeepSee.PMML.Definition.ModelStats</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelExplanation">
<Type>%DeepSee.PMML.Definition.ModelExplanation</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Targets">
<Type>%DeepSee.PMML.Definition.Targets</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="LocalTransformations">
<Type>%DeepSee.PMML.Definition.LocalTransformations</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="RuleSet">
<Type>%DeepSee.PMML.Definition.Models.RuleSet.RuleSet</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelVerification">
<Type>%DeepSee.PMML.Definition.ModelVerification</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%OnValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if $isobject(..RuleSet) {
			set tRuleCount = ..RuleSet.Rules.Count()
			for i = 1:1:tRuleCount {
				set tSC = ..RuleSet.Rules.GetAt(i).%ValidateNames(.pDictionary)
				quit:$$$ISERR(tSC)
			}
			quit:$$$ISERR(tSC)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Description>
Adds node-specific validation checks</Description>
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if '$isobject(..RuleSet) {
			set tSC = $$$ERROR($$$GeneralError, "RuleSetModel should have a RuleSet element")
			quit
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.SVM.Coefficient">
<Super>node</Super>
<System>4</System>
<TimeCreated>62966,61069.311912</TimeCreated>

<Property name="value">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.SVM.Coefficients">
<Super>node</Super>
<System>4</System>
<TimeCreated>62966,61133.372558</TimeCreated>

<Property name="numberOfCoefficients">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="absoluteValue">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Coefficients">
<Type>Coefficient</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="Coefficient"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.SVM.KernelType">
<Abstract>1</Abstract>
<Super>node</Super>
<System>4</System>
<TimeCreated>62966,59572.639155</TimeCreated>

<Property name="description">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Method name="%GetKernelFormula">
<Abstract>1</Abstract>
<FormalSpec>pSupportVector:VectorInstance,*pFormula:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.SVM.LinearKernelType">
<Super>KernelType</Super>
<System>4</System>
<TimeCreated>62966,60066.385855</TimeCreated>

<Method name="%GetKernelFormula">
<FormalSpec>pSupportVector:VectorInstance,*pFormula:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK, pFormula = ""
	try {
		
		set tSC = pSupportVector.Array.ValuesAsArray(.tArray)
		quit:$$$ISERR(tSC)
		
		set i = ""
		for {
			set i = $order(tArray(i),1,tValue)
			quit:i=""
			
			set:pFormula'="" pFormula = pFormula _ "+"
			set pFormula = pFormula _ "(x("_i_")*"_tValue_")"
		}
		 
		set pFormula = "("_pFormula_")"
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.SVM.PolynomialKernelType">
<Super>KernelType</Super>
<System>4</System>
<TimeCreated>62966,60236.73503</TimeCreated>

<Property name="gamma">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="coef0">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="degree">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Method name="%GetKernelFormula">
<FormalSpec>pSupportVector:VectorInstance,*pFormula:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK, pFormula = ""
	try {
		
		set tSC = pSupportVector.Array.ValuesAsArray(.tArray)
		quit:$$$ISERR(tSC)
		
		set i = ""
		for {
			set i = $order(tArray(i),1,tValue)
			quit:i=""
			
			set:pFormula'="" pFormula = pFormula _ "+"
			set pFormula = pFormula _ "(x("_i_")*"_tValue_")"
		}
		
		set pFormula = "(" _ $s(..gamma'=1:..gamma _ "*", 1:"") _ "("_pFormula_")" _ $s(..coef0:" + " _ ..coef0, 1:"") _ ")"
		set:..degree'=1 pFormula = "(" _ pFormula _ "**" _ ..degree _")"
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.SVM.RadialBasisKernelType">
<Super>KernelType</Super>
<System>4</System>
<TimeCreated>62966,60233.983579</TimeCreated>

<Property name="gamma">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Method name="%GetKernelFormula">
<FormalSpec>pSupportVector:VectorInstance,*pFormula:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK, pFormula = ""
	try {
		
		set tSC = pSupportVector.Array.ValuesAsArray(.tArray)
		quit:$$$ISERR(tSC)
		
		for i = 1:1:tArray {
			set:i>1 pFormula = pFormula _ "+"
			set pFormula = pFormula _ "((x("_i_")-"_$g(tArray(i),0)_")**2)"
		}
		 
		set pFormula = "$zexp(-"_..gamma _ " * (" _ pFormula_"))"
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.SVM.SigmoidKernelType">
<Super>KernelType</Super>
<System>4</System>
<TimeCreated>62966,60266.083046</TimeCreated>

<Property name="gamma">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="coef0">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Method name="%GetKernelFormula">
<FormalSpec>pSupportVector:VectorInstance,*pFormula:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK, pFormula = ""
	try {
		
		set tSC = pSupportVector.Array.ValuesAsArray(.tArray)
		quit:$$$ISERR(tSC)
		
		set i = ""
		for {
			set i = $order(tArray(i),1,tValue)
			quit:i=""
			
			set:pFormula'="" pFormula = pFormula _ "+"
			set pFormula = pFormula _ "(x("_i_")*"_tValue_")"
		}
		
		set pFormula = "(" _ $s(..gamma'=1:..gamma _ "*", 1:"") _ "("_pFormula_")" _ $s(..coef0:" + " _ ..coef0, 1:"") _ ")"
		
		// hyperbolic tangent
		set pFormula = "(1-$zexp(-2*"_pFormula_"))/(1+$zexp(-2*"_pFormula_"))"
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.SVM.SupportVector">
<Super>node</Super>
<System>4</System>
<TimeCreated>62966,60893.854954</TimeCreated>

<Property name="vectorId">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.SVM.SupportVectorMachine">
<Super>node</Super>
<System>4</System>
<TimeCreated>62966,59683.398727</TimeCreated>

<Property name="targetCategory">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="alternateTargetCategory">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="threshold">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="SupportVectors">
<Type>SupportVectors</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Coefficients">
<Type>Coefficients</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.SVM.SupportVectors">
<Super>node</Super>
<System>4</System>
<TimeCreated>62966,60835.747841</TimeCreated>

<Property name="numberOfSupportVectors">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="numberOfAttributes">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Vectors">
<Type>SupportVector</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="SupportVector"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.SVM.VectorDictionary">
<Super>node</Super>
<System>4</System>
<TimeCreated>62966,59633.035405</TimeCreated>

<Property name="numberOfVectors">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Fields">
<Type>VectorFields</Type>
<Parameter name="XMLNAME" value="VectorFields"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Instances">
<Type>VectorInstance</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="VectorInstance"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.SVM.VectorFields">
<Super>node</Super>
<System>4</System>
<TimeCreated>62966,60390.470882</TimeCreated>

<Property name="numberOfFields">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="FieldRefs">
<Type>%DeepSee.PMML.Definition.Util.FieldRef</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="FieldRef"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.SVM.VectorInstance">
<Super>node</Super>
<System>4</System>
<TimeCreated>62966,60553.405557</TimeCreated>

<Property name="id">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Array">
<Type>%DeepSee.PMML.Definition.Util.AbstractArray</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
<Parameter name="XMLTYPECONSTRAINT" value="CHOICE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.SVM.node">
<Abstract>1</Abstract>
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>4</System>
<TimeCreated>62966,59468.933722</TimeCreated>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.SupportVectorMachineModel">
<Super>AbstractModel</Super>
<System>4</System>
<TimeCreated>62966,59418.432089</TimeCreated>

<Property name="threshold">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="svmRepresentation">
<Type>%DeepSee.PMML.Datatype.String</Type>
<InitialExpression>"SupportVectors"</InitialExpression>
<Parameter name="VALUELIST" value=",Coefficients,SupportVectors"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="classificationMethod">
<Type>%DeepSee.PMML.Datatype.String</Type>
<InitialExpression>"OneAgainstAll"</InitialExpression>
<Parameter name="VALUELIST" value=",OneAgainstAll,OneAgainstOne"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="MiningSchema">
<Type>%DeepSee.PMML.Definition.MiningSchema</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Output">
<Type>%DeepSee.PMML.Definition.Output</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelStats">
<Type>%DeepSee.PMML.Definition.ModelStats</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelExplanation">
<Type>%DeepSee.PMML.Definition.ModelExplanation</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Targets">
<Type>%DeepSee.PMML.Definition.Targets</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="LocalTransformations">
<Type>%DeepSee.PMML.Definition.LocalTransformations</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="KernelType">
<Type>%DeepSee.PMML.Definition.Models.SVM.KernelType</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
<Parameter name="XMLTYPECONSTRAINT" value="CHOICE"/>
</Property>

<Property name="VectorDictionary">
<Type>%DeepSee.PMML.Definition.Models.SVM.VectorDictionary</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="SVMs">
<Type>%DeepSee.PMML.Definition.Models.SVM.SupportVectorMachine</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="SupportVectorMachine"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelVerification">
<Type>%DeepSee.PMML.Definition.ModelVerification</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%OnValidateObject">
<Description>
Adds node-specific validation checks</Description>
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if ..VectorDictionary.numberOfVectors && (..VectorDictionary.numberOfVectors'=..VectorDictionary.Instances.Count()) {
			set tSC = $$$ERROR($$$GeneralError, "If set, numberOfVectors should correspond to the number of VectorInstances defined")
			quit
		}
		
		set tDimensionality = ..VectorDictionary.Fields.FieldRefs.Count()
		if ..VectorDictionary.Fields.numberOfFields && (..VectorDictionary.Fields.numberOfFields '= tDimensionality) {
			set tSC = $$$ERROR($$$GeneralError, "If set in VectorFields, numberOfFields should correspond to the number of FieldRefs defined")
			quit
		}
		
		for i = 1:1:..VectorDictionary.Instances.Count() {
			#dim tInstance As %DeepSee.PMML.Definition.Models.SVM.VectorInstance = ..VectorDictionary.Instances.GetAt(i)
			if (tInstance.Array.n '= tDimensionality) {
				set tSC = $$$ERROR($$$GeneralError, "VectorInstance array length should match the number of fields in VectorFields")
				quit
			}
		}
		quit:$$$ISERR(tSC)
		
		for i = 1:1:..SVMs.Count() {
			
			#dim tSVM as %DeepSee.PMML.Definition.Models.SVM.SupportVectorMachine = ..SVMs.GetAt(i)
			if tSVM.SupportVectors.numberOfSupportVectors && (tSVM.SupportVectors.numberOfSupportVectors '= tSVM.SupportVectors.Vectors.Count()) {
				set tSC = $$$ERROR($$$GeneralError, "If set in SupportVectors, numberOfSupportVectors should equal the number of nested SupportVector elements")
				quit
			}
			
			if tSVM.SupportVectors.numberOfAttributes && (tSVM.SupportVectors.numberOfAttributes '= tDimensionality) {
				set tSC = $$$ERROR($$$GeneralError, "If set in SupportVectors, numberOfAttributes should equal the number of FieldRef elements in VectorFields")
				quit
			}
			
			if tSVM.Coefficients.numberOfCoefficients && (tSVM.Coefficients.numberOfCoefficients '= tSVM.Coefficients.Coefficients.Count()) {
				set tSC = $$$ERROR($$$GeneralError, "If set in Coefficients, numberOfCoefficients should equal the number of nested Coefficient elements")
				quit
			}
			
		}
		quit:$$$ISERR(tSC)
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%GetModelClass">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit "%DeepSee.PMML.Model.SVM"
]]></Implementation>
</Method>

<Method name="%OnValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		for i = 1:1:..VectorDictionary.Fields.FieldRefs.Count() {
			set tSC = ..VectorDictionary.Fields.FieldRefs.GetAt(i).%ValidateNames(.pDictionary)
			quit:$$$ISERR(tSC)
		}
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Text.Corpus">
<Super>%DeepSee.PMML.Definition.node</Super>
<System>3</System>
<TimeCreated>62879,43124.432507</TimeCreated>

<Parameter name="XMLNAME">
<Default>TextCorpus</Default>
</Parameter>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Documents">
<Type>Document</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="TextDocument"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Text.Dictionary">
<Super>%DeepSee.PMML.Definition.node</Super>
<System>3</System>
<TimeCreated>62879,43082.83302</TimeCreated>

<Parameter name="XMLNAME">
<Default>TextDictionary</Default>
</Parameter>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Taxonomy">
<Type>%DeepSee.PMML.Definition.Taxonomy</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Terms">
<Type>%DeepSee.PMML.Definition.Util.Array</Type>
<Parameter name="XMLNAME" value="Array"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Text.Document">
<Super>%DeepSee.PMML.Definition.node</Super>
<System>3</System>
<TimeCreated>62879,43036.702692</TimeCreated>

<Parameter name="XMLNAME">
<Default>TextDocument</Default>
</Parameter>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="id">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="name">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="length">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="file">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Text.DocumentTermMatrix">
<Super>%DeepSee.PMML.Definition.node</Super>
<System>3</System>
<TimeCreated>62879,43402.572393</TimeCreated>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Matrix">
<Type>%DeepSee.PMML.Definition.Util.Matrix</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Text.Normalization">
<Super>%DeepSee.PMML.Definition.node</Super>
<System>3</System>
<TimeCreated>62879,43624.942059</TimeCreated>

<Parameter name="XMLNAME">
<Default>TextModelNormalization</Default>
</Parameter>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="localTermWeights">
<Type>%DeepSee.PMML.Datatype.String</Type>
<InitialExpression>"termFrequency"</InitialExpression>
<Parameter name="VALUELIST" value=",termFrequency,binary,logarithmic,augmentedNormalizedTermFrequency"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="globalTermWeights">
<Type>%DeepSee.PMML.Datatype.String</Type>
<InitialExpression>"inverseDocumentFrequency"</InitialExpression>
<Parameter name="VALUELIST" value=",inverseDocumentFrequency,none,GFIDF,normal,probabilisticInverse"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="documentNormalization">
<Type>%DeepSee.PMML.Datatype.String</Type>
<InitialExpression>"none"</InitialExpression>
<Parameter name="VALUELIST" value=",none,cosine"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Text.Similarity">
<Super>%DeepSee.PMML.Definition.node</Super>
<System>3</System>
<TimeCreated>62879,43720.152787</TimeCreated>

<Parameter name="XMLNAME">
<Default>TextModelSimilarity</Default>
</Parameter>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="similarityType">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",euclidian,cosine"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.TextModel">
<Super>AbstractModel</Super>
<System>3</System>
<TimeCreated>62879,43207.656462</TimeCreated>

<Property name="numberOfTerms">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="numberOfDocuments">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="MiningSchema">
<Type>%DeepSee.PMML.Definition.MiningSchema</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Output">
<Type>%DeepSee.PMML.Definition.Output</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelStats">
<Type>%DeepSee.PMML.Definition.ModelStats</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelExplanation">
<Type>%DeepSee.PMML.Definition.ModelExplanation</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Targets">
<Type>%DeepSee.PMML.Definition.Targets</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="LocalTransformations">
<Type>%DeepSee.PMML.Definition.LocalTransformations</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Dictionary">
<Type>%DeepSee.PMML.Definition.Models.Text.Dictionary</Type>
<Parameter name="XMLNAME" value="TextDictionary"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Corpus">
<Type>%DeepSee.PMML.Definition.Models.Text.Corpus</Type>
<Parameter name="XMLNAME" value="TextCorpus"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="DocumentTermMatrix">
<Type>%DeepSee.PMML.Definition.Models.Text.DocumentTermMatrix</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Normalization">
<Type>%DeepSee.PMML.Definition.Models.Text.Normalization</Type>
<Parameter name="XMLNAME" value="TextModelNormalization"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Similarity">
<Type>%DeepSee.PMML.Definition.Models.Text.Similarity</Type>
<Parameter name="XMLNAME" value="TextModelSimilarity"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelVerification">
<Type>%DeepSee.PMML.Definition.ModelVerification</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%OnValidateObject">
<Description>
Adds node-specific validation checks</Description>
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if (..numberOfDocuments'=..DocumentTermMatrix.Matrix.nbRows) {
			set tSC = $$$ERROR($$$GeneralError, "DocumentTermMatrix row count does not match numberOfDocuments")
			quit
		}
		
		if (..numberOfTerms'=..DocumentTermMatrix.Matrix.nbCols) {
			set tSC = $$$ERROR($$$GeneralError, "DocumentTermMatrix column count does not match numberOfTerms")
			quit
		}
		
		if (..numberOfTerms'=..Dictionary.Terms.Length()) {
			set tSC = $$$ERROR($$$GeneralError, "TextDictionary array length does not match numberOfTerms")
			quit
		}
		
		set tInputMap = ""
		for i = 1:1:..Extension.Count() {
			set tExtension = ..Extension.GetAt(i)
			for j = 1:1:tExtension.iscExtensions.Count() {
				set tExtensionElem = tExtension.iscExtensions.GetAt(j)
				if (tExtensionElem.%IsA("%DeepSee.PMML.Definition.Extension.TextModelInput")) {
					set tInputMap = tExtensionElem
					quit
				}
			}
			quit:$isobject(tInputMap)
		}
		if $isobject(tInputMap) {
			if '$isobject(tInputMap.Fields) || 'tInputMap.Fields.Length() {
				set tSC = $$$ERROR($$$GeneralError, "X-TextModelInput should list at least one input field")
				quit
			}
			
			if (tInputMap.inputType="terms") && (tInputMap.Fields.Length()'=..numberOfTerms) {
				set tSC = $$$ERROR($$$GeneralError, "When X-TextModelInput has inputType=terms, the number of mapped fields should equal the number of terms for this TextModel")
				quit
			}
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%OnValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tInputMap = ""
		for i = 1:1:..Extension.Count() {
			set tExtension = ..Extension.GetAt(i)
			for j = 1:1:tExtension.iscExtensions.Count() {
				set tExtensionElem = tExtension.iscExtensions.GetAt(j)
				if (tExtensionElem.%IsA("%DeepSee.PMML.Definition.Extension.TextModelInput")) {
					set tInputMap = tExtensionElem
					quit
				}
			}
			quit:$isobject(tInputMap)
		}
		if $isobject(tInputMap) {
			set tSC = tInputMap.Fields.ValuesAsArray(.tFields)
			quit:$$$ISERR(tSC)
			
			for i = 1:1:tFields {
				if '$d(pDictionary("fields", tFields(i))) {
					set tSC = $$$ERROR($$$GeneralError, "Unknown text input field: '"_tFields(i)_"'")
					quit
				}
			}
			quit:$$$ISERR(tSC)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.TreeModel">
<Super>AbstractModel</Super>
<System>3</System>
<TimeCreated>62749,52050.539561</TimeCreated>

<Property name="missingValueStrategy">
<Type>%DeepSee.PMML.Datatype.String</Type>
<InitialExpression>"none"</InitialExpression>
<Parameter name="VALUELIST" value=",lastPrediction,nullPrediction,defaultChild,weightedConfidence,aggregateNodes,none"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="missingValuePenalty">
<Type>%DeepSee.PMML.Datatype.ProbNumber</Type>
<InitialExpression>1.0</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="noTrueChildStrategy">
<Type>%DeepSee.PMML.Datatype.String</Type>
<InitialExpression>"returnNullPrediction"</InitialExpression>
<Parameter name="VALUELIST" value=",returnNullPrediction,returnLastPrediction"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="splitCharacteristic">
<Type>%DeepSee.PMML.Datatype.String</Type>
<InitialExpression>"multiSplit"</InitialExpression>
<Parameter name="VALUELIST" value=",binarySplit,multiSplit"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="MiningSchema">
<Type>%DeepSee.PMML.Definition.MiningSchema</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Output">
<Type>%DeepSee.PMML.Definition.Output</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelStats">
<Type>%DeepSee.PMML.Definition.ModelStats</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelExplanation">
<Type>%DeepSee.PMML.Definition.ModelExplanation</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Targets">
<Type>%DeepSee.PMML.Definition.Targets</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="LocalTransformations">
<Type>%DeepSee.PMML.Definition.LocalTransformations</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Node">
<Type>%DeepSee.PMML.Definition.Models.Trees.TreeNode</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModelVerification">
<Type>%DeepSee.PMML.Definition.ModelVerification</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%OnValidateObject">
<Description>
Adds node-specific validation checks</Description>
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		// TODO: if splitCharacteristic = binarySplit, verify all nodes have exactly 2 subnodes
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%OnValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if $isobject(..Node) {
			set tSC = ..Node.%ValidateNames(.pDictionary)
			quit:$$$ISERR(tSC)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Trees.ScoreDistribution">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62749,53086.895288</TimeCreated>

<Property name="value">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="recordCount">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="confidence">
<Type>%DeepSee.PMML.Datatype.ProbNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="probability">
<Type>%DeepSee.PMML.Datatype.ProbNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Models.Trees.TreeNode">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62749,52130.503752</TimeCreated>

<Parameter name="XMLNAME">
<Default>Node</Default>
</Parameter>

<Property name="id">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="score">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="recordCount">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="defaultChild">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Predicate">
<Type>%DeepSee.PMML.Definition.Util.Predicate</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
<Parameter name="XMLTYPECONSTRAINT" value="CHOICE"/>
</Property>

<Property name="ScoreDistributions">
<Description>
TODO Property Partitions As list of %DeepSee.PMML.Definition.Partition(XMLPROJECTION = "ELEMENT", XMLITEMNAME = "Partition");</Description>
<Type>ScoreDistribution</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="ScoreDistribution"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Subnodes">
<Type>TreeNode</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="Node"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%OnValidateObject">
<Description>
TODO Property EmbeddedModel
Adds node-specific validation checks</Description>
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if ..recordCount {
			set tTotal = 0
			for i = 1:1:..ScoreDistributions.Count() {
				set tTotal = tTotal + ..ScoreDistributions.GetAt(i).recordCount
			}
			if (tTotal > ..recordCount) { 
				set tSC = $$$ERROR($$$GeneralError, "The total recordCount of all ScoreDistribution elements in Node '"_..id_"' exceeds the nodes recordCount")
				quit
			}
		}
		
		if ..defaultChild'="" {
			set tFound = 0
			for i = 1:1:..Subnodes.Count() {
				set tFound = (..defaultChild=..Subnodes.GetAt(i).id)
				quit:tFound
			}
			if 'tFound {
				set tSC = $$$ERROR($$$GeneralError, "Default child '"_..defaultChild_"' not found as a direct child in Node '"_..id_"'")
				quit
			}
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%ValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tSC = ..Predicate.%ValidateNames(.pDictionary)
		quit:$$$ISERR(tSC)
		
		for i = 1:1:..Subnodes.Count() {
			set tSC = ..Subnodes.GetAt(i).%ValidateNames(.pDictionary)
			quit:$$$ISERR(tSC)
		}
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Output">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,45818.329525</TimeCreated>

<Property name="OutputFields">
<Type>OutputField</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="OutputField"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%ValidateNames">
<Final>1</Final>
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		for i = 1:1:..OutputFields.Count() {
			set tField = ..OutputFields.GetAt(i)
			
			if $isobject(tField.Expression) {
				set tSC = tField.Expression.%ValidateNames(.pDictionary)
				quit:$$$ISERR(tSC)
			}
			
			if (tField.targetField'="") {
				if '$d(pDictionary("targets", tField.targetField)) &&
					 '$$$PMMLusageTypeIsTarget($g(pDictionary("fields", tField.targetField, "usageType"))) {
					set tSC = $$$ERROR($$$GeneralError, "Unkown output field: '"_tField.targetField_"'")
					quit
				}
			}
			
			// BDB790 - append field name to local dictionary
			// BDB798 - but only if they're not present already
			if '$d(pDictionary("fields", tField.name)) {
				set pDictionary("fields", tField.name) = "Output"
				set pDictionary("fields", tField.name, "dataType") = tField.dataType
				set pDictionary("fields", tField.name, "optype") = tField.optype
				set pDictionary("fields", tField.name, "usageType") = $$$PMMLusageTypePredicted_":"_tField.feature
			}
		}
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.OutputField">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,64682.767634</TimeCreated>

<Property name="name">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="displayName">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="optype">
<Type>%DeepSee.PMML.Datatype.OpType</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="dataType">
<Type>%DeepSee.PMML.Datatype.DataType</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="targetField">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="feature">
<Type>%DeepSee.PMML.Datatype.ResultFeature</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="value">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="ruleFeature">
<Type>%DeepSee.PMML.Datatype.RuleFeature</Type>
<InitialExpression>"consequent"</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="algorithm">
<Type>%DeepSee.PMML.Datatype.String</Type>
<InitialExpression>"exclusiveRecommendation"</InitialExpression>
<Parameter name="VALUELIST" value=",recommendation,exclusiveRecommendation,ruleAssociation"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="rank">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="rankBasis">
<Type>%DeepSee.PMML.Datatype.String</Type>
<InitialExpression>"confidence"</InitialExpression>
<Parameter name="VALUELIST" value=",confidence,support,lift,leverage,affinity"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="rankOrder">
<Type>%DeepSee.PMML.Datatype.String</Type>
<InitialExpression>"descending"</InitialExpression>
<Parameter name="VALUELIST" value=",descending,ascending"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="isMultiValued">
<Type>%DeepSee.PMML.Datatype.BooleanInt</Type>
<InitialExpression>"0"</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="segmentId">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Decisions">
<Type>Decisions</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Expression">
<Type>%DeepSee.PMML.Definition.Util.AbstractExpression</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
<Parameter name="XMLTYPECONSTRAINT" value="CHOICE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.PMML">
<IncludeCode>%occSAX</IncludeCode>
<Super>node</Super>
<System>4</System>
<TimeCreated>62735,41800.954533</TimeCreated>

<Property name="version">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",4.0,4.1,4.2,4.2.1,4.3"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
<Parameter name="XSDTYPE" value="xs:string"/>
</Property>

<Property name="Header">
<Type>Header</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="MiningBuildTask">
<Type>MiningBuildTask</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="DataDictionary">
<Type>DataDictionary</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="TransformationDictionary">
<Type>TransformationDictionary</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Models">
<Type>%DeepSee.PMML.Definition.Models.AbstractModel</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
<Parameter name="XMLTYPECONSTRAINT" value="CHOICE"/>
</Property>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%OnValidateObject">
<Description>
Adds node-specific validation checks</Description>
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		// validate field names used in this PMML definition, starting with reserved names
		kill tNames
		do ##class(%DeepSee.PMML.Definition.Util.Functions).AddToDictionary(.tNames)
		
		if '$isobject(..DataDictionary) {
			set tSC = $$$ERROR($$$GeneralError, "<DataDictionary> is a required element")
			quit
		}
		
		// first build basic dictionary based on ..DataDictionary
		set tSC = ..DataDictionary.%GetDictionary(.tNames)
		quit:$$$ISERR(tSC)
		
		// then validate and append using ..TransformationDictionary
		if $isobject(..TransformationDictionary) {
			set tSC = ..TransformationDictionary.%ValidateNames(.tNames)
			quit:$$$ISERR(tSC)
		}
		
		// now validate model by model
		for i = 1:1:..Models.Count() {
			set tSC = ..Models.GetAt(i).%ValidateNames(.tNames)
			quit:$$$ISERR(tSC)
		}
		quit:$$$ISERR(tSC)
		
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>pVersion:%String,pDescription:%String="",pApplication:%String=""</FormalSpec>
<ReturnType>PMML</ReturnType>
<Implementation><![CDATA[
	set pmml = ..%New()
	set pmml.version = pVersion
	set pmml.Header = ##class(%DeepSee.PMML.Definition.Header).%New()
	set pmml.Header.description = pDescription
	set pmml.Header.Timestamp = ##class(%DeepSee.PMML.Definition.HeaderTimestamp).%New()
	set pmml.Header.Timestamp.value = $zdt($h)
	if (pApplication'="") {
		set pmml.Header.Application = ##class(%DeepSee.PMML.Definition.HeaderApplication).%New()
		set pmml.Header.Application.name = pApplication
	}
	set pmml.DataDictionary = ##class(%DeepSee.PMML.Definition.DataDictionary).%New()
	set pmml.TransformationDictionary = ##class(%DeepSee.PMML.Definition.TransformationDictionary).%New()
	quit pmml
]]></Implementation>
</Method>

<Method name="%ToString">
<FormalSpec>*pString:%String,pFormatted:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tSC = ..XMLExportToString(.pString)
		quit:$$$ISERR(tSC)
		
		set:pFormatted pString = ..FormatXML(pString)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%FromString">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pModel:%DeepSee.PMML.Definition.PMML,pString:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set tReader = ##class(%XML.Reader).%New()
		set tReader.SAXFlags = $$$SAXNOVALIDATION // BDB738
		set tSC = tReader.OpenString(pString)
		quit:$$$ISERR(tSC)
		
		do tReader.Correlate("PMML", "%DeepSee.PMML.Definition.PMML")
		
		if 'tReader.Next(.pModel, .tSC) && $$$ISOK(tSC) {
			set tSC = $$$ERROR($$$GeneralError, "No PMML element in string")
			quit
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%SaveToClass">
<FormalSpec>pClassName:%String,pOverwriteExisting:%Boolean=1,pVerbose:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		// delete any existing class
		if $$$defClassDefined(pClassName) {
			if 'pOverwriteExisting {
				set tSC = $$$ERROR($$$ClassNameExists, pClassName)
				quit
			}
		    set tSC = $$Delete^%apiOBJ(pClassName,"-d")
		    quit:$$$ISERR(tSC)
		}
	    
	    set tClass = ##class(%Dictionary.ClassDefinition).%New()
	    set tClass.Name = pClassName
	    set tClass.Super = "%DeepSee.PMML.Definition"
	    set tClass.ProcedureBlock = 1
	    
	    set tXData = ##class(%Dictionary.XDataDefinition).%New()
	    set tXData.Name = "PMML"
	    set tXData.XMLNamespace = "http://www.intersystems.com/deepsee/pmml"
	    do tClass.XDatas.Insert(tXData)
	    
		set tSC = ..%ToString(.tString)
		quit:$$$ISERR(tSC)
		set tSC = tXData.Data.Write(tString)
		quit:$$$ISERR(tSC)
	    
	    set tSC = tClass.%Save()
	    quit:$$$ISERR(tSC)
	    set tClass="", tXData=""
	    
	    set tSC = $system.OBJ.Compile(pClassName, $s(pVerbose:"ckd", 1:"ck-d"))
	    quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="FormatXML">
<Description>
Some basic XML formatting
Note: this expects nicely formatted attribute content and no surprises in CDATA !</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pString:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set tString = "", tPrevPos=0
	for {
		set tPos = $find(pString,"<",tPrevPos)
		if 'tPos {
			set tString = tString _ $e(pString,tPrevPos,*)
			quit
		}
				
		// first add tag content, if any
		if tPrevPos && (tPrevPos<tPos-2) {
			set tString = tString_$e(pString,tPrevPos,tPos-2)
		}
		
		// catch CDATA
		if ($e(pString,tPos,tPos+6)="!CDATA[") {
			set tEndPos = $find(pString,"]]]]><![CDATA[>",tPos)
			set tString = tString_$e(pString,tPos-1,tEndPos-1)
			set tPrevPos = tEndPos
			set tLastOpenTag = ""
			continue
		}
		
		// process normal tags
		set tFirstSpace = $find(pString," ",tPos), tFirstClose = $find(pString,">",tPos)
		set tTag = $e(pString,tPos,$s(tFirstSpace&&(tFirstSpace<tFirstClose):tFirstSpace, 1:tFirstClose)-2)
		
		// check if we can immediately close the tag
		set tClosing = $e(pString,tFirstClose,tFirstClose+$l(tTag)+2)
		if (tClosing = ("</"_tTag_">")) || (tClosing = ("</"_tTag_" ")) {
			set tString = tString _ $e(pString,tPos-1,tFirstClose-2) _ " />"_$c(13,10)
			set tPrevPos = $find(pString,">",tFirstClose)
		} else {
			// just append tag
			set tString = tString _ $e(pString,tPos-1,tFirstClose-1)
			set tPrevPos = tFirstClose
			
			if ($e(pString,tFirstClose)="<") && ($e(pString,tFirstClose,tFirstClose+7)'="<!CDATA[") {
				set tString = tString _ $c(13,10)
			}
		}
	}
	quit tString
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.SASchema">
<Description><![CDATA[
This class implements SASchema for the PMML model classes.
See also <class>%DeepSee.PMML.ModelDefinition</class>]]></Description>
<Super>%Studio.SASchemaClass</Super>
<System>3</System>
<TimeCreated>62739,34069.518758</TimeCreated>

<Parameter name="XMLNAMESPACE">
<Description>
This is the namespace value used to identify this SA schema.
This corresponds to the XMLNamespace keyword of a Studio XData block.</Description>
<Default>http://www.intersystems.com/deepsee/pmml</Default>
</Parameter>

<Parameter name="ROOTCLASSES">
<Description>
This is comma-separated list of the classes whose xml elements
can be used as the root level element of a document.</Description>
<Type>STRING</Type>
<Default>%DeepSee.PMML.Definition.PMML:PMML</Default>
</Parameter>
</Class>


<Class name="%DeepSee.PMML.Definition.Segment">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>63060,57220.657343</TimeCreated>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Predicate">
<Type>%DeepSee.PMML.Definition.Util.Predicate</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
<Parameter name="XMLTYPECONSTRAINT" value="CHOICE"/>
</Property>

<Property name="Model">
<Type>%DeepSee.PMML.Definition.Models.AbstractModel</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
<Parameter name="XMLTYPECONSTRAINT" value="CHOICE"/>
</Property>

<Property name="id">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="weight">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Segmentation">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>63060,57333.21129</TimeCreated>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Segments">
<Type>Segment</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="Segment"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="multipleModelMethod">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",majorityVote,weightedMajorityVote,average,weightedAverage,median,max,sum,selectFirst,selectAll,modelChain"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Target">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,46079.045758</TimeCreated>

<Property name="field">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="optype">
<Type>%DeepSee.PMML.Datatype.OpType</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="castInteger">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="VALUELIST" value=",round,ceiling,floor"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="min">
<Type>%Double</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
<Parameter name="XSDTYPE" value="xs:double"/>
</Property>

<Property name="max">
<Type>%Double</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
<Parameter name="XSDTYPE" value="xs:double"/>
</Property>

<Property name="rescaleConstant">
<Type>%Double</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
<Parameter name="XSDTYPE" value="xs:double"/>
</Property>

<Property name="rescaleFactor">
<Type>%Double</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
<Parameter name="XSDTYPE" value="xs:double"/>
</Property>

<Property name="Values">
<Type>TargetValue</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="TargetValue"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.TargetValue">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,62322.551806</TimeCreated>

<Property name="value">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="displayValue">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="priorProbability">
<Type>%DeepSee.PMML.Datatype.ProbNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="defaultValue">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<UDLText name="T">
<Content><![CDATA[
// Property Partitions 

]]></Content>
</UDLText>
</Class>


<Class name="%DeepSee.PMML.Definition.Targets">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,61913.391223</TimeCreated>

<Property name="Targets">
<Type>Target</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="Target"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%ValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		for i = 1:1:..Targets.Count() {
			set tTarget = ..Targets.GetAt(i) 
		
			if '$d(pDictionary("fields", tTarget.field), tFieldInfo) {
				set tSC = $$$ERROR($$$GeneralError, "Unknown field: '"_tTarget.field_"'")
				quit
			}
			
			set pDictionary("targets", tTarget.field) = "Target"
			set pDictionary("targets", tTarget.field, "optype") = tTarget.optype
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Taxonomy">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,51332.47007</TimeCreated>

<Property name="name">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="ChildParents">
<Type>TaxonomyChildParent</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="ChildParent"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.TaxonomyChildParent">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,61679.281525</TimeCreated>

<Parameter name="XMLNAME">
<Default>ChildParent</Default>
</Parameter>

<Property name="childField">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="parentField">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="parentLevelField">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="isRecursive">
<Type>%DeepSee.PMML.Datatype.YesNo</Type>
<InitialExpression>"no"</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="TableIdentifier">
<Type>%DeepSee.PMML.Definition.Util.TableIdentifier</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
<Parameter name="XMLTYPECONSTRAINT" value="CHOICE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.TransformationDictionary">
<Super>extendableNode</Super>
<System>3</System>
<TimeCreated>62735,45386.309766</TimeCreated>

<Property name="DefineFunctions">
<Type>DefineFunction</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="DefineFunction"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="DerivedFields">
<Type>DerivedField</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="DerivedField"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%ValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set tSource = "TransformationDictionary"
		
		// verify and append DefineFunction entries
		for i = 1:1:..DefineFunctions.Count() {
			#dim tFunction As DefineFunction = ..DefineFunctions.GetAt(i)
			
			if $d(pDictionary("functions", tFunction.name), tSrc) {
				set tSC = $$$ERROR($$$GeneralError, "Function already defined: '"_tFunction.name_"' ("_tSrc_")")
				quit
			}
			
			set tSC = tFunction.Expression.%ValidateNames(.pDictionary)
			quit:$$$ISERR(tSC)
			
			set pDictionary("functions", tFunction.name) = tSource
			set:tFunction.dataType'="" pDictionary("functions", tFunction.name, "dataType") = tFunction.dataType
			set:tFunction.optype'="" pDictionary("functions", tFunction.name, "optype") = tFunction.optype
		}
		quit:$$$ISERR(tSC)
		
		// verify and append DerivedField entries
		for i = 1:1:..DerivedFields.Count() {
			#dim tField As DerivedField = ..DerivedFields.GetAt(i)
			
			if tField.name="" {
				set tSC = $$$ERROR($$$GeneralError, "Field name is required for DerivedField element")
				quit
			}
			
			if $d(pDictionary("fields", tField.name), tSrc) {
				set tSC = $$$ERROR($$$GeneralError, "Field already defined: '"_tField.name_"' ("_tSrc_")")
				quit
			}
			
			set tSC = tField.Expression.%ValidateNames(.pDictionary)
			quit:$$$ISERR(tSC)
			
			set pDictionary("fields", tField.name) = tSource
			set:tField.dataType'="" pDictionary("fields", tField.name, "dataType") = tField.dataType
			set:tField.optype'="" pDictionary("fields", tField.name, "optype") = tField.optype
		}
		quit:$$$ISERR(tSC)
		
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.AbstractArray">
<Abstract>1</Abstract>
<Super>%DeepSee.PMML.Definition.node</Super>
<System>3</System>
<TimeCreated>62735,46415.403306</TimeCreated>

<Property name="n">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Method name="ValuesAsArray">
<Abstract>1</Abstract>
<FormalSpec>*pArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.AbstractExpression">
<Abstract>1</Abstract>
<Super>%DeepSee.PMML.Definition.node</Super>
<System>3</System>
<TimeCreated>62735,59268.660987</TimeCreated>

<Method name="%ValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		// verify field name usage
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%GetComputeCode">
<Description><![CDATA[
<p>Returns the COS code to compute this expression. Sets <var>pInline</var> to 1 if the returned
string can simply be nested in an enclosing expression. If <var>pInline</var> = 0, the code
returned is assumed to populate a variable <var>tValue</var>, with each line prepended with
appropriate whitespace to allow simple compilation.</p>
<p>If the expression can evaluate to anything other than valid values, an additional variable
<var>tStatus</var> should be populated with the appropriate status (which will likely result in
<var>pInline</var> being 0)</p>
<p>If <var>pOverrideSource</var> is set, it should be used rather than the expected "input"
for this expression (ie: ..field)</p>]]></Description>
<Abstract>1</Abstract>
<FormalSpec>*pInline:%Boolean=0,pOverrideSource:%String="",pThis:%String="."</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit ""
]]></Implementation>
</Method>

<Method name="%GetInputFields">
<Description>
Returns the names of the fields used by this expression.
This method is called recursively on nested expressions so that all fields are appended.</Description>
<Internal>1</Internal>
<FormalSpec><![CDATA[&pFields]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.Aggregate">
<Super>AbstractExpression,%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62735,61186.813459</TimeCreated>

<Property name="field">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="function">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",count,sum,average,min,max,multiset"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="groupField">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="sqlWhere">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Method name="%ValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if '$d(pDictionary("fields", ..field)) {
			set tSC = $$$ERROR($$$GeneralError, "Unknown field: '"_..field_"'")
			quit
		}
		
		if (..groupField'="") && '$d(pDictionary("fields", ..groupField)) {
			set tSC = $$$ERROR($$$GeneralError, "Unknown field: '"_..groupField_"'")
			quit
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%GetComputeCode">
<FormalSpec>*pInline:%Boolean=0,pOverrideSource:%String="",pThis:%String="."</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set pInline = 0 // TODO
	quit "	// <Aggregate> is currently not implemented"
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Description>
Adds node-specific validation checks</Description>
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	quit $$$ERROR($$$NotImplemented)
]]></Implementation>
</Method>

<Method name="%GetInputFields">
<Internal>1</Internal>
<FormalSpec><![CDATA[&pFields]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set pFields(..field) = ""
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.Apply">
<Super>AbstractExpression,%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62738,35424.101917</TimeCreated>

<Property name="function">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="mapMissingTo">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="invalidValueTreatment">
<Type>%DeepSee.PMML.Datatype.InvalidValueTreatmentMethod</Type>
<InitialExpression>"returnInvalid"</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Expressions">
<Type>AbstractExpression</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
<Parameter name="XMLTYPECONSTRAINT" value="CHOICE"/>
</Property>

<Method name="%ValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if '$d(pDictionary("functions", ..function)) {
			set tSC = $$$ERROR($$$GeneralError, "Unknown function: '"_..function_"'")
			quit
		}
		
		// TODO: verify datatype/optype of function corresponds to outcome of nested Expressions?
		
		for i = 1:1:..Expressions.Count() {
			set tSC = ..Expressions.GetAt(i).%ValidateNames(.pDictionary)
			quit:$$$ISERR(tSC)
		}
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%GetComputeCode">
<Description><![CDATA[
Returns the COS code to compute this expression. Sets <var>pInline</var> to 1 if the returned
string can simply be nested in an enclosing expression. If <var>pInline</var> = 0, the code
returned is assumed to populate a variable <var>tValue</var>, with each line prepended with
appropriate whitespace to allow simple compilation.]]></Description>
<FormalSpec>*pInline:%Boolean=0,pOverrideSource:%String="",pThis:%String="."</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#define WriteLine(%s) set tCode = tCode_$c(13,10,9)_%s
	#define WriteBlock(%s) set tCode = tCode_$c(13,10)_%s
	set tFunction = ..function, tCode = ""
	
	// simple maths
	if (tFunction = "+") || (tFunction = "-") || (tFunction = "*") || (tFunction = "/") {
		
		set pInline = 0
		set tUniqueVarName = "tValue"_$i(%varNameCounter), tUniqueStatusName = "tStatus"_%varNameCounter
		for i = 1:1:..Expressions.Count() {
			set tExprCode = ..Expressions.GetAt(i).%GetComputeCode(.tInline, pOverrideSource, pThis)
			if tInline {
				if (i=1) {
					$$$WriteLine("set tValue = "_tExprCode)
				} else {
					$$$WriteLine("set tValue = tValue "_tFunction_" ("_tExprCode_")")
				}
			} else {
				if (i=1) {
					$$$WriteBlock(tExprCode)
				} else {
					$$$WriteLine("set "_tUniqueVarName_" = tValue, "_tUniqueStatusName_" = $g(tStatus,""valid"")")
					$$$WriteBlock(tExprCode)
					$$$WriteLine("set tValue = "_tUniqueVarName_" "_tFunction_" tValue, tStatus = $s(tStatus=""missing"":""missing"", 1:"_tUniqueStatusName_")")
				}
			}
		}
		quit tCode
		
	} elseif (tFunction = "min") || (tFunction = "max") || (tFunction = "sum") || (tFunction = "avg") || (tFunction = "median") || (tFunction = "product") {
		
		set tUni = $i(%varNameCounter)
		set tCode = $c(9)_"set tOneValid"_tUni_" = 0", pInline = 0
		if (tFunction = "sum") {
			$$$WriteLine("set tSum"_tUni_" = 0")
		} elseif (tFunction = "avg") {
			$$$WriteLine("set tSum"_tUni_" = 0, tCount"_tUni_" = 0")
		} elseif (tFunction = "product") {
			$$$WriteLine("set tProduct"_tUni_" = 1")
		} elseif (tFunction = "min") {
			$$$WriteLine("set tMin"_tUni_" = """"")
		} elseif (tFunction = "max") {
			$$$WriteLine("set tMax"_tUni_" = """"")
		} elseif (tFunction = "median") {
			$$$WriteLine("set tCount"_tUni_" = 0")
			$$$WriteLine("kill tMedian"_tUni)
		}
		for i = 1:1:..Expressions.Count() {
			set tExprCode = ..Expressions.GetAt(i).%GetComputeCode(.tInline, pOverrideSource)
			if tInline {
				$$$WriteLine("set tValue = "_tExprCode_", tStatus=""valid"", tOneValid"_tUni_"=1")
			} else {
				$$$WriteLine("set tStatus=""valid""")
				$$$WriteBlock(tExprCode)
				$$$WriteLine("set:'tOneValid"_tUni_" tOneValid"_tUni_" = ($g(tStatus,""valid"")=""valid"")")
			}
			if (tFunction = "sum") {
				$$$WriteLine("set:$g(tStatus)'=""missing"" tSum"_tUni_" = tSum"_tUni_" + tValue")
			} elseif (tFunction = "avg") {
				$$$WriteLine("set:$g(tStatus)'=""missing"" tSum"_tUni_" = tSum"_tUni_" + tValue, tCount"_tUni_" = tCount"_tUni_"+1")
			} elseif (tFunction = "product") {
				$$$WriteLine("set:$g(tStatus)'=""missing"" tProduct"_tUni_" = tProduct"_tUni_" * tValue")
			} elseif (tFunction = "min") {
				$$$WriteLine("set:($g(tStatus)'=""missing"")&&((tMin"_tUni_"="""")||(tMin"_tUni_">tValue)) tMin"_tUni_" = tValue")
			} elseif (tFunction = "max") {
				$$$WriteLine("set:($g(tStatus)'=""missing"")&&((tMax"_tUni_"="""")||(tMax"_tUni_"<tValue)) tMax"_tUni_" = tValue")
			} elseif (tFunction = "median") {
				$$$WriteLine("set:$g(tStatus)'=""missing"" tCount"_tUni_" = tCount"_tUni_"+1, tMedian"_tUni_"(tValue, tCount"_tUni_")=""""")
			}
		}
		if (tFunction = "sum") {
			$$$WriteLine("set tValue = tSum"_tUni_"")
		} elseif (tFunction = "avg") {
			$$$WriteLine("set tValue = tSum"_tUni_" / tCount"_tUni)
		} elseif (tFunction = "product") {
			$$$WriteLine("set tValue = tProduct"_tUni_"")
		} elseif (tFunction = "min") {
			$$$WriteLine("set tValue = tMin"_tUni_"")
		} elseif (tFunction = "max") {
			$$$WriteLine("set tValue = tMax"_tUni_"")
		} elseif (tFunction = "median") {
			$$$WriteLine("set i=0, x="""", tValue=""""")
			$$$WriteLine("kill tMedianValue")
			$$$WriteLine("for {")
			$$$WriteLine(" set x=$order(tMedian"_tUni_"(x))")
			$$$WriteLine(" quit:x=""""")
			$$$WriteLine(" set y=""""")
			$$$WriteLine(" for {")
			$$$WriteLine("  set y=$order(tMedian"_tUni_"(x,y))")
			$$$WriteLine("  quit:y=""""")
			$$$WriteLine("  set tMedianValue($i(i)) = x")
			$$$WriteLine(" }")
			$$$WriteLine("}")
			$$$WriteLine("if (tCount"_tUni_"=1) {")
			$$$WriteLine(" set tValue = tMedianValue(1)")
			$$$WriteLine("} elseif (tCount"_tUni_"#2) {")
			$$$WriteLine(" set tValue = tMedianValue(tCount"_tUni_"/2)")
			$$$WriteLine("} else {") 
			$$$WriteLine(" set tValue = (tMedianValue(tCount"_tUni_"\2) + tMedianValue(tCount"_tUni_"\2+1))/2")
			$$$WriteLine("}")
		}
		$$$WriteLine("set tStatus = $s(tOneValid"_tUni_":""valid"", 1:""missing"")")
		quit tCode
		
	} elseif (tFunction = "log10") || (tFunction = "ln") || (tFunction = "abs") || (tFunction = "exp") || (tFunction = "not") || (tFunction = "uppercase") || (tFunction = "lowercase") || (tFunction = "trimBlanks") {
		
		set tFun = $case(tFunction, "log10":"$zlog", "ln":"$zln", "abs":"$zabs", "exp":"$zexp", "not":"'", "uppercase":"$$$UPPER", "lowercase":"$$$LOWER", "trimBlanks":"$zstrip")
		set tArgs = $case(tFunction, "trimBlanks":",""<>WC"")", :"")
		set tExprCode = ..Expressions.GetAt(1).%GetComputeCode(.pInline, pOverrideSource)
		if pInline {
			quit tFun_"("_tExprCode_tArgs_")"
		} else {
			$$$WriteLine("set tStatus=""valid""")
			$$$WriteBlock(tExprCode)
			$$$WriteLine("set tValue = $s($g(tStatus)=""missing"":"""", 1:"_tFun_"(tValue"_tArgs_"))")
			quit tCode
		}
		
	} elseif (tFunction = "floor") || (tFunction = "round") || (tFunction = "ceil") {
		
		set tExprCode = ..Expressions.GetAt(1).%GetComputeCode(.pInline, pOverrideSource)
		if pInline {
			quit "##class(%DeepSee.PMML.Utils.Math).CastInteger("_tExprCode_","_$$$QUOTE(tFunction)_")"
		} else {
			$$$WriteLine("set tStatus=""valid""")
			$$$WriteBlock(tExprCode)
			$$$WriteLine("set tValue = ##class(%DeepSee.PMML.Utils.Math).CastInteger(tValue,"_$$$QUOTE(tFunction)_")")
			quit tCode
		}
		
	} elseif (tFunction = "pow") {
		
		set tUni = $i(%varNameCounter)
		set tExprCode1 = ..Expressions.GetAt(1).%GetComputeCode(.tInline1, pOverrideSource)
		set tExprCode2 = ..Expressions.GetAt(2).%GetComputeCode(.tInline2, pOverrideSource)
		set pInline = 0
		if 'tInline1 {
			$$$WriteLine("set tStatus=""valid""")
			$$$WriteBlock(tExprCode1)
			$$$WriteLine("set tValue"_tUni_"x1 = tValue, tStatus"_tUni_"x1 = $g(tStatus,""valid"")")
		} else {
			$$$WriteLine("set tValue"_tUni_"x1 = "_tExprCode1_", tStatus"_tUni_"x1=""valid""")
		}
		if 'tInline2 {
			$$$WriteLine("set tStatus=""valid""")
			$$$WriteBlock(tExprCode2)
			$$$WriteLine("set tValue"_tUni_"x2 = tValue, tStatus"_tUni_"x2 = $g(tStatus,""valid"")")
		} else {
			$$$WriteLine("set tValue"_tUni_"x2 = "_tExprCode2_", tStatus"_tUni_"x2=""valid""")
		}
		$$$WriteLine("set tValue = $s((tValue"_tUni_"x1=0)&&(tValue"_tUni_"x2=0):1, 1:tValue"_tUni_"x1**tValue"_tUni_"x2)")
		$$$WriteLine("set tStatus = $s((tStatus"_tUni_"x1=""missing"")||(tStatus"_tUni_"x2=""missing""):""missing"", 1:""valid"")")
		quit tCode
		
	} elseif (tFunction = "threshold") || (tFunction = "equal") || (tFunction = "notEqual") || (tFunction = "greaterThan") || (tFunction = "greaterOrEqual") || (tFunction = "lessThan") || (tFunction = "lessOrEqual") || (tFunction = "and") || (tFunction = "or") {
		
		set tUni = $i(%varNameCounter)
		set tOperator = $case(tFunction, "threshold":">", "equal":"=", "notEqual":"'=", "lessThan":"<", "lessOrEqual":"<=", "greaterThan":">", "greaterOrEqual":">=", "and":"&&", "or":"||")
		set tExprCode1 = ..Expressions.GetAt(1).%GetComputeCode(.tInline1, pOverrideSource)
		set tExprCode2 = ..Expressions.GetAt(2).%GetComputeCode(.tInline2, pOverrideSource)
		if tInline1 && tInline2 {
			set pInline = 1
			quit "(("_tExprCode1_")"_tOperator_"("_tExprCode2_"))"
		} else {
			set pInline = 0
			if 'tInline1 {
				$$$WriteLine("set tStatus=""valid""")
				$$$WriteBlock(tExprCode1)
				$$$WriteLine("set tValue"_tUni_"x1 = tValue, tStatus"_tUni_"x1 = $g(tStatus,""valid"")")
			} else {
				$$$WriteLine("set tValue"_tUni_"x1 = "_tExprCode1_", tStatus"_tUni_"x1=""valid""")
			}
			if 'tInline2 {
				$$$WriteLine("set tStatus=""valid""")
				$$$WriteBlock(tExprCode2)
				$$$WriteLine("set tValue"_tUni_"x2 = tValue, tStatus"_tUni_"x2 = $g(tStatus,""valid"")")
			} else {
				$$$WriteLine("set tValue"_tUni_"x2 = "_tExprCode2_", tStatus"_tUni_"x2=""valid""")
			}
			$$$WriteLine("set tValue = tValue"_tUni_"x1 "_tOperator_" tValue"_tUni_"x2")
			$$$WriteLine("set tStatus = $s((tStatus"_tUni_"x1=""missing"")||(tStatus"_tUni_"x2=""missing""):""missing"", 1:""valid"")")
		quit tCode
		}
		
	} elseif (tFunction = "isMissing") || (tFunction = "isNotMissing") {
		
		set tExprCode = ..Expressions.GetAt(1).%GetComputeCode(.tInline, pOverrideSource)
		set pInline = 0
		if tInline {
			/// maybe we can just return "valid" here?
			$$$WriteLine("set tValue = "_tExprCode)
		} else {
			$$$WriteBlock(tExprCode)
		}
		$$$WriteLine("set tValue = ($g(tStatus,""valid"")"_$s(tFunction="isNotMissing":"'", 1:"")_"=""missing""), tStatus = ""valid""")
		quit tCode
	
	} elseif (tFunction = "isIn") || (tFunction = "isNotIn") {
		
		set tUni = $i(%varNameCounter)
		set pInline = 0
		for i = 2:1:..Expressions.Count() {
			set tExprCode = ..Expressions.GetAt(i).%GetComputeCode(.tInline, pOverrideSource)
			if tInline {
				$$$WriteLine("set tValue = "_tExprCode)
			} else {
				$$$WriteBlock(tExprCode)
			}
			$$$WriteLine("set:$g(tStatus)'=""missing"" tValues"_tUni_"($s(tValue="""":$c(0), 1:tValue)) = """"")
		}
		set tExprCode = ..Expressions.GetAt(1).%GetComputeCode(.tInline, pOverrideSource)
		if tInline {
			$$$WriteLine("set tValue = "_tExprCode_", tStatus = ""valid""")
		} else {
			$$$WriteLine("set tStatus = ""valid""")
			$$$WriteBlock(tExprCode)
		}
		$$$WriteLine("set tValue = "_$s(tFunction="isNotIn":"'", 1:"")_"$d(tValues"_tUni_"($s(tValue="""":$c(0), 1:tValue)))")
		quit tCode
	
	} elseif (tFunction = "if") || (tFunction = "substring") {
		
		set tExprCode1 = ..Expressions.GetAt(1).%GetComputeCode(.tInline1, pOverrideSource)
		set tExprCode2 = ..Expressions.GetAt(2).%GetComputeCode(.tInline2, pOverrideSource)
		set tExprCode3 = ..Expressions.GetAt(3).%GetComputeCode(.tInline3, pOverrideSource)
		if tInline1 && tInline2 && tInline3 {
			set pInline = 1
			if (tFunction = "if") {
				quit "$s(("_tExprCode1_"):("_tExprCode2_"), 1:("_tExprCode3_"))"
			} else {
				quit "$e("_tExprCode1_","_tExprCode2_",("_tExprCode2_")+("_tExprCode3_")-1)"
			}
		} else {
			set pInline = 0
			if 'tInline1 {
				$$$WriteLine("set tStatus=""valid""")
				$$$WriteBlock(tExprCode1)
				$$$WriteLine("set tValue"_tUni_"x1 = tValue, tStatus"_tUni_"x1 = $g(tStatus,""valid"")")
			} else {
				$$$WriteLine("set tValue"_tUni_"x1 = "_tExprCode1_", tStatus"_tUni_"x1 = ""valid""")
			}
			if 'tInline2 {
				$$$WriteLine("set tStatus=""valid""")
				$$$WriteBlock(tExprCode2)
				$$$WriteLine("set tValue"_tUni_"x2 = tValue, tStatus"_tUni_"x2 = $g(tStatus,""valid"")")
			} else {
				$$$WriteLine("set tValue"_tUni_"x2 = "_tExprCode2_", tStatus"_tUni_"x2 = ""valid""")
			}
			if 'tInline3 {
				$$$WriteLine("set tStatus=""valid""")
				$$$WriteBlock(tExprCode3)
				$$$WriteLine("set tValue"_tUni_"x3 = tValue, tStatus"_tUni_"x3 = $g(tStatus,""valid"")")
			} else {
				$$$WriteLine("set tValue"_tUni_"x3 = "_tExprCode3_", tStatus"_tUni_"x3 = ""valid""")
			}
			if (tFunction = "if") {
				$$$WriteLine("set tValue = $s(tValue"_tUni_"x1:tValue"_tUni_"2, 1:tValue"_tUni_"x3)")
				$$$WriteLine("set tStatus = $s((tStatus"_tUni_"x1=""missing""):""missing"", tValue"_tUni_"x1:tStatus"_tUni_"x2, 1:tStatus"_tUni_"x3)")
			} else {
				$$$WriteLine("set tValue = $e(tValue"_tUni_"x1, tValue"_tUni_"x2, tValue"_tUni_"x2+tValue"_tUni_"x3-1)")
				$$$WriteLine("set tStatus = $s((tStatus"_tUni_"x1=""missing"")||(tStatus"_tUni_"x2=""missing"")||(tStatus"_tUni_"x3=""missing""):""missing"", 1:""valid"")")
			}
			quit tCode
		}
		
	} else {
		// TODO: formatNumber, formatDatetime, dateDaysSinceYear, dateSecondsSinceYear, dateSecondsSinceMidnight
		set tSC = $$$ERROR($$$GeneralError, "function not implemented: "_tFunction)
		throw ##class(%Exception.StatusException).CreateFromStatus(tSC)
	}
		
	// user-defined functions are currently
	quit ""
]]></Implementation>
</Method>

<Method name="%GetInputFields">
<Internal>1</Internal>
<FormalSpec><![CDATA[&pFields]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	for i = 1:1:..Expressions.Count() {
		set tSC = ..Expressions.GetAt(i).%GetInputFields(.pFields)
		quit:$$$ISERR(tSC)
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.Array">
<Super>AbstractArray</Super>
<System>3</System>
<TimeCreated>62735,46326.747134</TimeCreated>

<Property name="type">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",int,string,real"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Values">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN"/>
<Parameter name="XMLPROJECTION" value="CONTENT"/>
</Property>

<Method name="ValuesAsArray">
<FormalSpec>*pArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill pArray
	set tSC = $$$OK
	try {
		set pArray = 0
		
		set tValues = $zstrip(..Values,"<>WC"), tQuoted = 0
		quit:tValues=""
		
		while 1 {
			
			// find the next spacer or end quote
			if $e(tValues,1)="""" {
				set tQuoted = 1, tPos=1
				while 1 {
					set tPos = $find(tValues,"""",tPos+1)
					if 'tPos { set tSC = $$$ERROR($$$GeneralError, "unterminated quote in Array values") quit }
					quit:$e(tValues,tPos-2)'="\"
				}
				quit:$$$ISERR(tSC)
				set tPos = tPos+1
			} else {
				set tPos = $find(tValues," ")
			}
			if 'tPos {
				set tValue = tValues
				set tValues=""
			} else {
				set tValue = $e(tValues,1,tPos-2)
				set tValues = $zstrip($e(tValues,tPos,*),"<W")
			}
			
			// un-quote
			if tQuoted {
				set tValue = $e(tValue,2,*-1)
				set tQuoted=0
			}
			set tValue = $replace(tValue,"\""","""")
			
			set pArray($i(pArray)) = tValue
			quit:tValues=""
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="Length">
<FormalSpec>*pSC:%Status=$$$OK</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	set pSC = $$$OK
	quit:..n ..n
	set pSC = ..ValuesAsArray(.tArray)
	quit $s($$$ISERR(pSC):"", 1:$g(tArray,0))
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tSC = ..ValuesAsArray(.tArray)
		quit:$$$ISERR(tSC)
		
		if ..n && (tArray '= ..n) {
			set tSC = $$$ERROR($$$GeneralError, "Array value count does not match n")
			quit
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.CompoundPredicate">
<Super>Predicate</Super>
<System>3</System>
<TimeCreated>62749,60656.159358</TimeCreated>

<Property name="Predicates">
<Type>Predicate</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
<Parameter name="XMLTYPECONSTRAINT" value="CHOICE"/>
</Property>

<Property name="booleanOperator">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",and,or,xor,surrogate"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Method name="%WriteComputeCode">
<FormalSpec>pVar:%String,pObj:%String,pIndent:%String,pStream:%Stream.TmpCharacter</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tCombined = "", tCount = ..Predicates.Count()
	for i = 1:1:tCount {
		set tPredicate = ..Predicates.GetAt(i)
		if (tPredicate.%IsA($classname())) {
			do tPredicate.%WriteComputeCode(pVar_i, pObj, pIndent, pStream)
			do pStream.Write(pIndent_"set x = $i("_pVar_"U("_pVar_i_"))")
		} else {
			do pStream.WriteLine(pIndent_"set "_pVar_i_" = "_tPredicate.%GetComputeCode(pObj)_", x = $i("_pVar_"U("_pVar_i_"))")
		}
		
		if (..booleanOperator="surrogate") {
			if (i<tCount) {
				set tCombined = tCombined _ pVar_i_"'=$c(0):"_pVar_i_", "
			} else {
				set tCombined = "$s("_tCombined_"1:"_pVar_i_")"
			}
		} else {
			set tOperator = $case(..booleanOperator, "and":"&&", "or":"||", "xor":"+")
			set tCombined = tCombined _ $s(tCombined="":"", 1:" "_tOperator_" ") _ "$s("_pVar_i_"=$c(0):0, 1:"_pVar_i_")"
		}
	}
	do pStream.Write(pIndent_"set "_pVar_" = "_tCombined)
	if (..booleanOperator="and") {
		do pStream.Write("  set:$d("_pVar_"U($c(0)))&&'$d("_pVar_"U(0)) "_pVar_" = $c(0)")
	} elseif (..booleanOperator="or") {
		do pStream.Write("  set:$d("_pVar_"U($c(0)))&&'$d("_pVar_"U(1)) "_pVar_" = $c(0)")
	} elseif (..booleanOperator="xor") {
		do pStream.Write("  set:$d("_pVar_"U($c(0))) "_pVar_" = $c(0)")
	} elseif (..booleanOperator="surrogate") {
		do pStream.Write("  set:$d("_pVar_"U($c(0))) pMissingValueCount = pMissingValueCount + 1")
	}
	do pStream.WriteLine("  kill "_pVar_"U")
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetAsTree">
<Internal>1</Internal>
<FormalSpec>*pTree</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		kill pTree
		set pTree = ..booleanOperator
		for i = 1:1:..Predicates.Count() {
			kill tTree
			set tSC = ..Predicates.GetAt(i).%GetAsTree(.tTree)
			quit:$$$ISERR(tSC)
			merge pTree(i) = tTree
		}
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.Constant">
<Super>AbstractExpression</Super>
<System>3</System>
<TimeCreated>62735,59328.125714</TimeCreated>

<Property name="value">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="CONTENT"/>
</Property>

<Property name="dataType">
<Type>%DeepSee.PMML.Datatype.DataType</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Method name="%GetComputeCode">
<FormalSpec>*pInline:%Boolean=0,pOverrideSource:%String="",pThis:%String="."</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set pInline = 1
	quit $s((..dataType="string")||(..dataType=""):$$$QUOTE(..value), 1:..value)
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.DataFieldRange">
<Abstract>1</Abstract>
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62741,40871.081879</TimeCreated>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.Discretize">
<Super>AbstractExpression,%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62735,60178.040655</TimeCreated>

<Property name="field">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="mapMissingTo">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="defaultValue">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="dataType">
<Type>%DeepSee.PMML.Datatype.DataType</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Bins">
<Type>DiscretizeBin</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="DiscretizeBin"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%ValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if (..field'="") && '$d(pDictionary("fields", ..field)) && '$$$DUMMYFIELD(..field) {
			set tSC = $$$ERROR($$$GeneralError, "Unknown field: '"_..field_"'")
			quit
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%GetComputeCode">
<FormalSpec>*pInline:%Boolean=0,pOverrideSource:%String="",pThis:%String="."</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set pInline = 0, tCode = ""
	
	#define WriteLine(%s) set tCode = $s(tCode="":$c(9), 1:tCode_$c(13,10,9)) _ %s
	
	set tQuote = (..dataType="string") || (..dataType="")
	
	set tFirstCondition = 1
	if (pOverrideSource="") {
		$$$WriteLine("set tValue = "_pThis_"."_$$$PROPERTYNAME(..field))
		$$$WriteLine("if ("_pThis_".%IsMissing("""_..field_""")) { // missing value")
		if (..mapMissingTo'="") {
			$$$WriteLine($c(9)_"set tValue = "_$s(tQuote:""""_..mapMissingTo_"""", 1:..mapMissingTo))
		} else {
			$$$WriteLine($c(9)_"set tStatus = ""missing""")
		}
		set tFirstCondition = 0
	} else {
		$$$WriteLine("set tValue = "_pOverrideSource)
	}
	
	for i = 1:1:..Bins.Count() {
		#dim tBin As DiscretizeBin = ..Bins.GetAt(i)
		if (tFirstCondition) {
			$$$WriteLine("if "_tBin.Interval.%GetAsCondition("tValue")_" {")
			set tFirstCondition = 0
		} else {
			$$$WriteLine("} elseif "_tBin.Interval.%GetAsCondition("tValue")_" {")
		}
		$$$WriteLine($c(9)_"set tValue = "_$s(tQuote:""""_tBin.binValue_"""", 1:tBin.binValue))
	}
	
	$$$WriteLine("} else { // no matching interval")
	if (..defaultValue'="") {
		$$$WriteLine($c(9)_"set tValue = "_$s(tQuote:""""_..defaultValue_"""", 1:..defaultValue))
	} else {
		$$$WriteLine($c(9)_"set tValue = """", tStatus = ""missing""")
	}
	$$$WriteLine("}")
	
	quit tCode
]]></Implementation>
</Method>

<Method name="%GetInputFields">
<Internal>1</Internal>
<FormalSpec><![CDATA[&pFields]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set pFields(..field) = ""
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.DiscretizeBin">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62735,60371.879026</TimeCreated>

<Property name="binValue">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Interval">
<Type>Interval</Type>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.False">
<Super>Predicate</Super>
<System>3</System>
<TimeCreated>62749,60561.326335</TimeCreated>

<Method name="%GetMissingCondition">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit 0
]]></Implementation>
</Method>

<Method name="%GetCondition">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit 0
]]></Implementation>
</Method>

<Method name="%GetComputeCode">
<FormalSpec>pObj:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit 0
]]></Implementation>
</Method>

<Method name="%GetTrace">
<Internal>1</Internal>
<FormalSpec>*pTree</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.FieldColumnPair">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62735,60636.802721</TimeCreated>

<Property name="field">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="column">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.FieldRef">
<Super>AbstractExpression,%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62735,59402.01101</TimeCreated>

<Property name="field">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="mapMissingTo">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Method name="%ValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if '$d(pDictionary("fields", ..field)) && '$$$DUMMYFIELD(..field) {
			set tSC = $$$ERROR($$$GeneralError, "Unknown field: '"_..field_"'")
			quit
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%GetComputeCode">
<FormalSpec>*pInline:%Boolean=0,pOverrideSource:%String="",pThis:%String="."</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if pOverrideSource'="" {
		set pInline = 1
		quit pOverrideSource
	}
	
	if ..mapMissingTo'="" {
		set pInline=1
		quit "$s("_pThis_".%IsMissing("""_..field_"""):"_$$$QUOTE(..mapMissingTo)_", 1:"_pThis_"."_$$$PROPERTYNAME(..field)_")"
	} else {
		set pInline=0
		quit $c(9)_"set tValue = "_pThis_"."_$$$PROPERTYNAME(..field)_", tStatus = "_pThis_".%GetPropertyStatus("_$$$QUOTE(..field)_")"
	}
]]></Implementation>
</Method>

<Method name="%GetInputFields">
<Internal>1</Internal>
<FormalSpec><![CDATA[&pFields]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set pFields(..field) = ""
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.Functions">
<System>3</System>
<TimeCreated>62865,41682.704065</TimeCreated>

<Method name="IsBuiltIn">
<ClassMethod>1</ClassMethod>
<FormalSpec>pFunction:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	do ..AddToDictionary(.tDict)
	quit $g(tDict("functions",pFunction))="built-in"
]]></Implementation>
</Method>

<Method name="AddToDictionary">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set pDictionary("functions","+") = "built-in"
    set pDictionary("functions","-") = "built-in"
    set pDictionary("functions","*") = "built-in"
    set pDictionary("functions","/") = "built-in"
    
    set pDictionary("functions","min") = "built-in"
    set pDictionary("functions","max") = "built-in"
    set pDictionary("functions","sum") = "built-in"
    set pDictionary("functions","avg") = "built-in"
    set pDictionary("functions","median") = "built-in"
    set pDictionary("functions","product") = "built-in"
    
    set pDictionary("functions","log10") = "built-in"
    set pDictionary("functions","ln") = "built-in"
    set pDictionary("functions","sqrt") = "built-in"
    set pDictionary("functions","abs") = "built-in"
    set pDictionary("functions","exp") = "built-in"
    set pDictionary("functions","pow") = "built-in"
    set pDictionary("functions","threshold") = "built-in"
    set pDictionary("functions","floor") = "built-in"
    set pDictionary("functions","ceil") = "built-in"
    set pDictionary("functions","round") = "built-in"
    
    set pDictionary("functions","isMissing") = "built-in"
    set pDictionary("functions","isNotMissing") = "built-in"
    
    set pDictionary("functions","equal") = "built-in"
    set pDictionary("functions","notEqual") = "built-in"
    set pDictionary("functions","lessThan") = "built-in"
    set pDictionary("functions","lessOrEqual") = "built-in"
    set pDictionary("functions","greaterThan") = "built-in"
    set pDictionary("functions","greaterOrEqual") = "built-in"
    
    set pDictionary("functions","isIn") = "built-in"
    set pDictionary("functions","isNotIn") = "built-in"
    
    set pDictionary("functions","and") = "built-in"
    set pDictionary("functions","or") = "built-in"
    
    set pDictionary("functions","not") = "built-in"
    
    set pDictionary("functions","if") = "built-in"
    
    set pDictionary("functions","uppercase") = "built-in"
    set pDictionary("functions","lowercase") = "built-in"
    set pDictionary("functions","substring") = "built-in"
    set pDictionary("functions","trimBlanks") = "built-in"
    
    set pDictionary("functions","formatNumber") = "built-in"
    set pDictionary("functions","formatDatetime") = "built-in"
    
    set pDictionary("functions","dateDaysSinceYear") = "built-in"
    set pDictionary("functions","dateSecondsSinceYear") = "built-in"
    set pDictionary("functions","dateSecondsSinceMidnight") = "built-in"
    
    quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.InlineTable">
<Super>TableIdentifier</Super>
<System>3</System>
<TimeCreated>62735,60841.72287</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// Property Rows As list Of InlineTableRow(XMLNAME = "row", XMLPROJECTION = "ELEMENT");

]]></Content>
</UDLText>

<Property name="Content">
<Type>%Stream.TmpCharacter</Type>
<Parameter name="CONTENT" value="MIXED"/>
<Parameter name="XMLPROJECTION" value="CONTENT"/>
</Property>

<Method name="%GetRows">
<Description>
Returns the contents of this Inline Table as two-dimensional array:
		pRows(rowNumber, columnName) = columnValue</Description>
<FormalSpec>*pRows</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		kill pRows
		set pRows = 0
		
		set tLen = 7
		if ..Content.Read(.tLen)'="<table>" {
			set tStream = ##class(%Stream.TmpCharacter).%New()
			do tStream.Write("<table>")
			do tStream.CopyFrom(..Content)
			do tStream.Write("</table>")
		} else {
			set tStream = ..Content
		}
		
		set tSC = ##class(%XML.Document).GetDocumentFromStream(tStream, .tDocument)
		quit:$$$ISERR(tSC)
		
		set tNode = tDocument.GetDocumentElement() // get <table> element
		quit:'tNode.MoveToFirstChild(1) // first <row> element
		for {
			set pRows = pRows+1
			
			continue:'tNode.MoveToFirstChild(1) // first <column>
			for {
				set tName = tNode.LocalName, tText = ""
				if (tName'="") && tNode.GetText(.tText) {
					set pRows(pRows, tName) = tText
				}
				quit:'tNode.MoveToNextSibling(1) // next <column>
			}
			
			do tNode.MoveToParent() // back up to <row> element
			quit:'tNode.MoveToNextSibling(1) // next <row> element
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Description>
Adds node-specific validation checks</Description>
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		// try to parse the table as a validation check
		set tSC = ..%GetRows(.tRows)
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.InlineTableRow">
<Super>%DeepSee.PMML.Definition.node</Super>
<System>3</System>
<TimeCreated>62735,60816.608144</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// Parameter XMLIGNOREINVALIDTAG As BOOLEAN = 1;

]]></Content>
</UDLText>

<Property name="value">
<Description>
Free-form</Description>
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="CONTENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.Interval">
<Super>DataFieldRange</Super>
<System>3</System>
<TimeCreated>62735,60269.979325</TimeCreated>

<Property name="closure">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="VALUELIST" value=",openClosed,openOpen,closedOpen,closedClosed"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="leftMargin">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="rightMargin">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Method name="%GetAsCondition">
<FormalSpec>pVarName:%String="tValue"</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set tCondition = ""
	set tOpenL = ($e(..closure,1,4)="open")
	set tOpenR = ($e(..closure,*-4,*)="Open")
	set:..leftMargin'="" tCondition = "("_pVarName_$s(tOpenL:">",1:">=")_..leftMargin_")"
	set:..rightMargin'="" tCondition = $s(tCondition="":"", 1:tCondition_" && ") _ "("_pVarName_$s(tOpenR:"<",1:"<=")_..rightMargin_")"
	set:(..leftMargin'="")&&(..rightMargin'="") tCondition = "("_tCondition_")"
	quit tCondition
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.LinearNorm">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62735,59517.960918</TimeCreated>

<Property name="orig">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="norm">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.MapValues">
<Super>AbstractExpression,%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62735,60404.151314</TimeCreated>

<Property name="mapMissingTo">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="defaultValue">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="outputColumn">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="dataType">
<Type>%DeepSee.PMML.Datatype.DataType</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="FieldColumnPairs">
<Type>FieldColumnPair</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="FieldColumnPair"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="TableIdentifier">
<Type>TableIdentifier</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
<Parameter name="XMLTYPECONSTRAINT" value="CHOICE"/>
</Property>

<Method name="%ValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		for i = 1:1:..FieldColumnPairs.Count() {
			set tPair = ..FieldColumnPairs.GetAt(i)
			
			if '$d(pDictionary("fields", tPair.field)) && '$$$DUMMYFIELD(tPair.field) {
				set tSC = $$$ERROR($$$GeneralError, "Unknown field: '"_tPair.field_"'")
				quit
			}
		}
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%GetComputeCode">
<FormalSpec>*pInline:%Boolean=0,pOverrideSource:%String="",pThis:%String="."</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#define WriteLine(%s) set tCode = $s(tCode="":$c(9), 1:tCode_$c(13,10,9)) _ %s
	
	if ..TableIdentifier.%IsA("%DeepSee.PMML.Definition.Util.TableLocator") {
		
		// TODO
		quit "	// <TableLocator> is currently not implemented" 
		
	} else {
		
		set pInline = 0, tCode = ""
		set tQuote = (..dataType="string") || (..dataType="")
		
		if (pOverrideSource="") {
			if (..mapMissingTo="") {
				set tMissingValue = "set tValue = """", tStatus = ""missing"""
			} else {
				set tMissingvalue = "set tValue = "_$s(tQuote:$$$QUOTE(..mapMissingTo), 1:..mapMissingTo)
			}
			
			set tIndexCols = "", tIndexFields = "", tIndexCount = ..FieldColumnPairs.Count()
			for i = 1:1:tIndexCount {
				set tIndexCols = tIndexCols _ $lb(..FieldColumnPairs.GetAt(i).column)
				set tField = ..FieldColumnPairs.GetAt(i).field
				if i=1 {
					$$$WriteLine("if "_pThis_".%IsMissing("""_tField_""") { "_tMissingValue_" } ")
				} else {
					$$$WriteLine("elseif "_pThis_".%IsMissing("""_tField_""") { "_tMissingValue_" } ")
				}
				set tIndexFields = $s(tIndexFields="":"", 1:tIndexFields _ ",") _ "$s("_pThis_"."_$$$PROPERTYNAME(tField)_"="""":$c(0), 1:"_pThis_"."_$$$PROPERTYNAME(tField)_")"
			}
		
			$$$WriteLine("else {")
		} else {
			set tIndexCols = "", tIndexFields = "", tIndexCount = ..FieldColumnPairs.Count()
			for i = 1:1:tIndexCount {
				set tIndexCols = tIndexCols _ $lb(..FieldColumnPairs.GetAt(i).column)
				set tOverrideSourcePiece = $p(pOverrideSource,",",i)
				set tIndexFields = $s(tIndexFields="":"", 1:tIndexFields _ ",") _ "$s("_tOverrideSourcePiece_"="""":$c(0), 1:"_tOverrideSourcePiece_")"
			}
		}
		
		// this method has been verified as part of its %OnValidateObject()
		do ..TableIdentifier.%GetRows(.tRows)
		
		$$$WriteLine($c(9)_"set tStatus = ""valid""")
		
		for i = 1:1:tRows {
			set tIndex = ""
			for j = 1:1:tIndexCount {
				set tIndexValue = $g(tRows(i,$li(tIndexCols,j)))
				set tIndexValue = $s(tIndexValue="":$c(0), 1:$$$QUOTE(tIndexValue))
				set tIndex = $s(tIndex="":"", 1:tIndex_",") _ tIndexValue
			}
			set tValue = $g(tRows(i,..outputColumn))
			$$$WriteLine($c(9)_"set tMap("_tIndex_") = "_$s(tQuote:$$$QUOTE(tValue), 1:tValue))
		}
		
		if ..defaultValue="" {
			set tDefault = """"", tStatus = ""missing"""
		} else {
			set tDefault = $s(tQuote:$$$QUOTE(..defaultValue),1:..defaultValue)
		}
		$$$WriteLine($c(9)_"set:'$d(tMap("_tIndexFields_"),tValue) tValue = "_tDefault)
		
		if (pOverrideSource="") {
			$$$WriteLine("}")
		}
		
		quit tCode
	}
]]></Implementation>
</Method>

<Method name="%GetInputFields">
<Internal>1</Internal>
<FormalSpec><![CDATA[&pFields]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	for i = 1:1:..FieldColumnPairs.Count() {
		set pFields(..FieldColumnPairs.GetAt(i).field) = ""
	}
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.MatCell">
<Super>%DeepSee.PMML.Definition.node</Super>
<System>3</System>
<TimeCreated>62735,50225.881244</TimeCreated>

<Property name="row">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="col">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="value">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="CONTENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.Matrix">
<Super>%DeepSee.PMML.Definition.node</Super>
<System>3</System>
<TimeCreated>62735,50244.866858</TimeCreated>

<Property name="kind">
<Type>%DeepSee.PMML.Datatype.String</Type>
<InitialExpression>"any"</InitialExpression>
<Parameter name="VALUELIST" value=",diagnoal,symmetric,any"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="nbRows">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="nbCols">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Arrays">
<Type>Array</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="Array"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="diagDefault">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="offDiagDefault">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Cells">
<Type>MatCell</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="MatCell"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%OnValidateObject">
<Description>
Adds node-specific validation checks</Description>
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if ..kind = "any" {
			if ..Cells.Count() && ..Arrays.Count() {
				set tSC = $$$ERROR($$$GeneralError, "A Matrix should be represented through MatCell OR Array elements, not both")
				quit
			}
		} elseif ..Cells.Count() {
			set tSC = $$$ERROR($$$GeneralError, "A symmetric or diagonal matrix cannot be represented through MatCell elements")
			quit
		}
		
		if ..Arrays.Count() && (..diagDefault || ..offDiagDefault) {
			set tSC = $$$ERROR($$$GeneralError, "diagDefault and offDiagDefault can only be used when using MatCell representation")
			quit
		}
		
		set tSC = ..ValuesAsArray(.tArray)
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="ValuesAsArray">
<Description>
Returns the values of this matrix as a two-dimensional array, where pArray(i,j) contains
the value of the j'th column on the i'th row of the matrix. the top node of pArray contains
$lb(nbOfRows, nbOfColumns)</Description>
<FormalSpec>*pArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill pArray
	set tSC = $$$OK
	try {
		set tRows = ..nbRows, tCols = ..nbCols
		
		if ..Arrays.Count() {
			
			if ..kind = "any" {
				
				set pArray = ..Arrays.Count()
				if tRows && (pArray '= tRows) {
					set tSC = $$$ERROR($$$GeneralError, "Array count does not match nbRows")
					quit
				}
				set:'tRows tRows = pArray
				
				for i = 1:1:pArray {
					#dim tRow As AbstractArray = ..Arrays.GetAt(i)
					
					if tCols && (tRow.Length() '= tCols) {
						set tSC = $$$ERROR($$$GeneralError, "Array length at row "_i_" does not match column count")
						quit
					}
					set:'tCols tCols = tRow.Length()
					
					set tSC = tRow.ValuesAsArray(.tRowArray)
					quit:$$$ISERR(tSC)
					
					merge pArray(i) = tRowArray
				}
				quit:$$$ISERR(tSC)
				
			} elseif ..kind = "symmetric" {
				
				set pArray = ..Arrays.Count()
				if tRows && (pArray '= tRows) {
					set tSC = $$$ERROR($$$GeneralError, "Array count does not match nbRows")
					quit
				}
				set:'tRows tRows = pArray
				set:'tCols tCols = pArray
				
				for i = 1:1:pArray {
					set tRow = ..Arrays.GetAt(i)
					
					if (tRow.Length() '= i) {
						set tSC = $$$ERROR($$$GeneralError, "Array length at row "_i_" does not match column count for lower triangle")
						quit
					}
					
					set tSC = tRow.ValuesAsArray(.tRowArray)
					quit:$$$ISERR(tSC)
					
					for j = 1:1:i {
						set pArray(i,j) = $g(tRowArray(j))
						set pArray(j,i) = $g(tRowArray(j))
					}
				}
				quit:$$$ISERR(tSC)
				
			} elseif ..kind = "diagonal" {
				
				set tRow = ..Arrays.GetAt(1)
				
				if tRow="" {
					set tSC = $$$ERROR($$$GeneralError, "No array specified for Matrix diagonal values")
					quit
				}
				
				if tRows && (tRows '= tRow.Length()) {
					set tSC = $$$ERROR($$$GeneralError, "Diagonal values array length does not correspond to ..nbRows")
					quit
				}
				set:'tRows tRows = tRow.Length()
				
				set tSC = tRow.ValuesAsArray(.tRowArray)
				quit:$$$ISERR(tSC)
					
				for i = 1:1:tRows {
					set pArray(i,i) = tRowArray(i)
				}
			}
			
		} else { // MatCell representation
			
			// loop through cells first as row and column count may not be defined
			set tCellCount = ..Cells.Count(), tMaxRow = 0, tMaxCol = 0
			for i = 1:1:tCellCount {
				#dim tCell As MatCell = ..Cells.GetAt(i)
				
				if tCols && (tCell.col > tCols) {
					set tSC = $$$ERROR($$$GeneralError, "MatCell column index exceeds ..nbCols")
					quit
				}
				
				if tRows && (tCell.row > tRows) {
					set tSC = $$$ERROR($$$GeneralError, "MatCell row index exceeds ..nbRows")
					quit
				}
				
				set:tMaxRow<tCell.row tMaxRow = tCell.row
				set:tMaxCol<tCell.col tMaxCol = tCell.col
				
				set pArray(tCell.row, tCell.col) = tCell.value
				set:..kind="symmetric" pArray(tCell.col, tCell.row) = tCell.value
			}
			set:'tRows tRows = tMaxRow
			set:'tCols tCols = tMaxCol
			
			for i = 1:1:tRows {
				for j = 1:1:tCols {
					continue:$d(pArray(i,j))
					
					if (i=j) {
						set:..diagDefault'="" pArray(i,j) = ..diagDefault
					} else {
						set:..offDiagDefault'="" pArray(i,j) = ..offDiagDefault
					}
				}
			}
			
		}
		
		set pArray = $lb(tRows, tCols)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.NormContinuous">
<Super>AbstractExpression,%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62735,59449.164237</TimeCreated>

<Property name="mapMissingTo">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="field">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="outliers">
<Type>%DeepSee.PMML.Datatype.OutlierTreatmentMethod</Type>
<InitialExpression>"asIs"</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="LinearNorms">
<Type>LinearNorm</Type>
<Collection>list</Collection>
<Required>1</Required>
<Parameter name="XMLNAME" value="LinearNorm"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%ValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if (..field'="") && '$d(pDictionary("fields", ..field)) && '$$$DUMMYFIELD(..field) {
			set tSC = $$$ERROR($$$GeneralError, "Unknown field: '"_..field_"'")
			quit
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%GetComputeCode">
<FormalSpec>*pInline:%Boolean=0,pOverrideSource:%String="",pThis:%String="."</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set pInline = 0, tCode = ""
	
	#define WriteLine(%s) set tCode = $s(tCode="":$c(9), 1:tCode_$c(13,10,9)) _ %s
	
	if (pOverrideSource'="") {
		$$$WriteLine("set tValue = "_pOverrideSource)
	} elseif (..mapMissingTo'="") {
		$$$WriteLine("set tValue = $s("_pThis_".%IsMissing("""_..field_"""):"_..mapMissingTo_", 1:"_pThis_"."_$$$PROPERTYNAME(..field)_")")
	} else {
		$$$WriteLine("set tValue = "_pThis_"."_$$$PROPERTYNAME(..field)_", tStatus = "_pThis_".%GetPropertyStatus("""_..field_""")")
	}
	
	set tCount = ..LinearNorms.Count()
	$$$WriteLine("if (tValue = """") {}")
	$$$WriteLine("elseif (tValue < "_..LinearNorms.GetAt(1).orig_") {")
	if (..outliers = "asMissingValues") {
		$$$WriteLine($c(9)_"set tValue = """", tStatus = ""missing""")
	} elseif (..outliers = "asExtremeValues") {
		$$$WriteLine($c(9)_"set tValue = "_..LinearNorms.GetAt(1).norm)
	} else {
		set n1 = ..LinearNorms.GetAt(1), n2 = ..LinearNorms.GetAt(2)
		set x1 = n1.orig, x2 = n2.orig, y1 = n1.norm, y2 = n2.norm
		if (y1=y2) {
			$$$WriteLine($c(9)_"set tValue = "_y1)
		} else {
			$$$WriteLine($c(9)_"set tValue = "_y1_" + (((tValue-"_x1_")/("_x2_"-"_x1_"))*("_y2_"-"_y1_"))")
		}
	}
	
	for i = 1:1:..LinearNorms.Count()-1 {
		set n1 = ..LinearNorms.GetAt(i), n2 = ..LinearNorms.GetAt(i+1)
		set x1 = n1.orig, x2 = n2.orig, y1 = n1.norm, y2 = n2.norm
		
		$$$WriteLine("} elseif (tValue <= "_x2_") {")
		if (y1=y2) {
			$$$WriteLine($c(9)_"set tValue = "_y1)
		} else {
			$$$WriteLine($c(9)_"set tValue = "_y1_" + (((tValue-"_x1_")/("_x2_"-"_x1_"))*("_y2_"-"_y1_"))")
		}
	}
	
	$$$WriteLine("} else {")
	if (..outliers = "asMissingValues") {
		$$$WriteLine($c(9)_"set tValue = """", tStatus = ""missing""")
	} elseif (..outliers = "asExtremeValues") {
		$$$WriteLine($c(9)_"set tValue = "_..LinearNorms.GetAt(tCount).norm)
	} else {
		set n1 = ..LinearNorms.GetAt(tCount-1), n2 = ..LinearNorms.GetAt(tCount)
		set x1 = n1.orig, x2 = n2.orig, y1 = n1.norm, y2 = n2.norm
		if (y1=y2) {
			$$$WriteLine($c(9)_"set tValue = "_y1)
		} else {
			$$$WriteLine($c(9)_"set tValue = "_y1_" + (((tValue-"_x1_")/("_x2_"-"_x1_"))*("_y2_"-"_y1_"))")
		}
	}
	$$$WriteLine("}")
	
	quit tCode
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Description>
Adds node-specific validation checks</Description>
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		 if ..LinearNorms.Count() < 2 {
			set tSC = $$$ERROR($$$GeneralError, "NormContinuous should have at least 2 nested LinearNorm elements") 
			quit
		 }
		 
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%GetInputFields">
<Internal>1</Internal>
<FormalSpec><![CDATA[&pFields]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set pFields(..field) = ""
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.NormDiscrete">
<Super>AbstractExpression,%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62735,60032.813615</TimeCreated>

<Property name="field">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="mapMissingTo">
<Type>%DeepSee.PMML.Datatype.Number</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="value">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="method">
<Type>%DeepSee.PMML.Datatype.String</Type>
<InitialExpression>"indicator"</InitialExpression>
<Parameter name="VALUELIST" value=",indicator"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Method name="%ValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if (..field'="") && '$d(pDictionary("fields", ..field)) && '$$$DUMMYFIELD(..field) {
			set tSC = $$$ERROR($$$GeneralError, "Unknown field: '"_..field_"'")
			quit
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%GetComputeCode">
<FormalSpec>*pInline:%Boolean=0,pOverrideSource:%String="",pThis:%String="."</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if pOverrideSource'="" {
		set pInline = 1
		quit "("_pOverrideSource_"="""_..value_""")"
	} elseif ..mapMissingTo="" {
		set pInline=0
		quit $c(9)_"set tValue = $s(("_pThis_"."_$$$PROPERTYNAME(..field)_"="""_..value_"""):1, 1:0), tStatus = $s("_pThis_".%IsMissing("""_..field_"""):""missing"", 1:""valid"")"
	} else {
		set pInline=1
		quit "$s("_pThis_".%IsMissing("""_..field_"""):"_..mapMissingTo_", ("_pThis_"."_$$$PROPERTYNAME(..field)_"="""_..value_"""):1, 1:0)"
	}
]]></Implementation>
</Method>

<Method name="%GetInputFields">
<Internal>1</Internal>
<FormalSpec><![CDATA[&pFields]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set pFields(..field) = ""
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.ParameterField">
<Super>%DeepSee.PMML.Definition.node</Super>
<System>3</System>
<TimeCreated>62738,35534.317329</TimeCreated>

<Property name="name">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="optype">
<Type>%DeepSee.PMML.Datatype.OpType</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="dataType">
<Type>%DeepSee.PMML.Datatype.DataType</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.Partition">
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>63125,39870.021166</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// TODO 

]]></Content>
</UDLText>

<Parameter name="XMLIGNOREINVALIDATTRIBUTE">
<Default>1</Default>
</Parameter>

<Parameter name="XMLIGNOREINVALIDTAG">
<Default>1</Default>
</Parameter>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.Predicate">
<Abstract>1</Abstract>
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62749,60455.406822</TimeCreated>

<Method name="%WriteComputeCode">
<FormalSpec>pVar:%String,pObj:%String,pIndent:%String,pStream:%Stream.TmpCharacter</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	quit pStream.WriteLine(pIndent_"set "_pVar_" = "_..%GetComputeCode(pObj))
]]></Implementation>
</Method>

<Method name="%GetComputeCode">
<Abstract>1</Abstract>
<FormalSpec>pObj:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit ""
]]></Implementation>
</Method>

<Method name="%GetAsTree">
<Internal>1</Internal>
<Abstract>1</Abstract>
<FormalSpec>*pTree</FormalSpec>
<ReturnType>%Status</ReturnType>
</Method>

<Method name="%ValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.SimplePredicate">
<Super>Predicate</Super>
<System>3</System>
<TimeCreated>62749,60616.986582</TimeCreated>

<Property name="field">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="operator">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="VALUELIST" value=",equal,notEqual,lessThan,lessOrEqual,greaterThan,greaterOrEqual,isMissing,isNotMissing"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="value">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Method name="%GetComputeCode">
<FormalSpec>pObj:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	quit:..operator="isMissing" $$$PropMissing(pObj,..field)
	quit:..operator="isNotMissing" "'"_$$$PropMissing(pObj,..field)
	set tFieldValue = $$$PropValue(pObj,..field)
	if ($g(%PMML("Fields",$$$PROPERTYNAME(..field),"datatype"))="boolean") { // BDB505
		set tValue = $case($$$LOWER(..value), "false":0, "true":1, :..value)
		set tFieldValue = "$case($$$LOWER("_tFieldValue_"), ""false"":0, ""true"":1, :"_tFieldValue_")"
	} else {
		set tValue = $s((..value=+..value):..value, 1:$$$QUOTE(..value))
	}
	quit "$s("_$$$PropMissing(pObj,..field)_":$c(0), 1:("_tFieldValue_$case(..operator, "equal":"=", "notEqual":"'=", "lessThan":"<", "lessOrEqual":"<=", "greaterThan":">", "greaterOrEqual":">=") _ tValue _"))"
]]></Implementation>
</Method>

<Method name="%ValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if '$d(pDictionary("fields", ..field)) {
			set tSC = $$$ERROR($$$GeneralError, "Unknown field: '"_..field_"'")
			quit
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Description>
Adds node-specific validation checks</Description>
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if (..value="") && (..operator'="isMissing") && (..operator'="isNotMissing") {
			set tSC = $$$ERROR($$$GeneralError, "value is a required attribute for operator '"_..operator_"'")
			quit
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="SetOperatorSymbol">
<FormalSpec>pSymbol:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	quit ..operatorSet(..OperatorFromSymbol(pSymbol))
]]></Implementation>
</Method>

<Method name="OperatorFromSymbol">
<ClassMethod>1</ClassMethod>
<FormalSpec>pSymbol:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit $case(pSymbol, "=":"equal", "!=":"notEqual", "<":"lessThan", "<=":"lessOrEqual", ">":"greaterThan", ">=":"greaterOrEqual", :pSymbol)
]]></Implementation>
</Method>

<Method name="SymbolFromOperator">
<ClassMethod>1</ClassMethod>
<FormalSpec>pOperator:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit $case(pOperator, "equal":"=", "notEqual":"!=", "lessThan":"<", "lessOrEqual":"<=", "greaterThan":">", "greaterOrEqual":">=", :pOperator)
]]></Implementation>
</Method>

<Method name="%GetAsTree">
<Internal>1</Internal>
<FormalSpec>*pTree</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set pTree = $lb(..field, ..operator, ..value)
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.SimpleSetPredicate">
<Super>Predicate</Super>
<System>3</System>
<TimeCreated>62749,60688.885025</TimeCreated>

<Property name="field">
<Type>%DeepSee.PMML.Datatype.FieldName</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="booleanOperator">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",isIn,isNotIn"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Array">
<Type>%DeepSee.PMML.Definition.Util.Array</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="%GetComputeCode">
<FormalSpec>pObj:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	do ..Array.ValuesAsArray(.tArray)
	set tList = "", i=""
	for {
		set i = $order(tArray(i),1,tValue)
		quit:i=""
		
		set tList = tList _ $s(tList="":"", 1:",") _ $s(tValue=+tValue:tValue, 1:$$$QUOTE(tValue))
	}
	quit "$s("_$$$PropMissing(pObj,..field)_":$c(0), 1:$lf($lb("_tList_"), "_$$$PropValue(pObj,..field)_"))"
]]></Implementation>
</Method>

<Method name="%ValidateNames">
<FormalSpec><![CDATA[&pDictionary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if '$d(pDictionary("fields", ..field)) {
			set tSC = $$$ERROR($$$GeneralError, "Unknown field: '"_..field_"'")
			quit
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%GetAsTree">
<Internal>1</Internal>
<FormalSpec>*pTree</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set pTree = $lb(..field, ..booleanOperator, ..Array.Values)
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.SparseArray">
<Abstract>1</Abstract>
<Super>AbstractArray</Super>
<System>3</System>
<TimeCreated>62735,46417.603037</TimeCreated>

<Property name="Indices">
<Type>%String</Type>
<Parameter name="MAXLEN" value="32000"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Method name="ValuesAsArray">
<FormalSpec>*pArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill pArray
	set tSC = $$$OK
	try {
		
		set pArray = ..n
		set tIndices = $zstrip(..Indices,"<=>W")
		set tEntries = $zstrip(..Entries,"<=>W")
		
		set tIndicesLength = $l(tIndices," ")
		set tEntriesLength = $l(tEntries," ")
		
		if tIndicesLength '= tEntriesLength {
			set tSC = $$$ERROR($$$GeneralError, "SparseArray index count does not match entry count")
			quit
		}
		
		for i = 1:1:pArray {
			set pArray(i) = ..defaultValue
		}
		
		for i = 1:1:tIndicesLength {
			set pArray($p(tIndices," ",i)) = $p(tEntries," ",i)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.SparseArrayInt">
<Super>SparseArray</Super>
<System>3</System>
<TimeCreated>62735,46618.809888</TimeCreated>

<Parameter name="XMLNAME">
<Default>INT-SparseArray</Default>
</Parameter>

<Property name="defaultValue">
<Type>%DeepSee.PMML.Datatype.IntNumber</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Entries">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="32000"/>
<Parameter name="XMLNAME" value="INT-Entries"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.SparseArrayReal">
<Super>SparseArray</Super>
<System>3</System>
<TimeCreated>62735,46616.369589</TimeCreated>

<Parameter name="XMLNAME">
<Default>REAL-SparseArray</Default>
</Parameter>

<Property name="defaultValue">
<Type>%DeepSee.PMML.Datatype.RealNumber</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Entries">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="20000"/>
<Parameter name="XMLNAME" value="REAL-Entries"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.TableIdentifier">
<Abstract>1</Abstract>
<Super>%DeepSee.PMML.Definition.extendableNode</Super>
<System>3</System>
<TimeCreated>62735,60731.234658</TimeCreated>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.TableLocator">
<Super>TableIdentifier</Super>
<System>3</System>
<TimeCreated>62735,60758.626527</TimeCreated>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.True">
<Super>Predicate</Super>
<System>3</System>
<TimeCreated>62749,60514.223599</TimeCreated>

<Method name="%GetMissingCondition">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit 0
]]></Implementation>
</Method>

<Method name="%GetCondition">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit 1
]]></Implementation>
</Method>

<Method name="%GetComputeCode">
<FormalSpec>pObj:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit 1
]]></Implementation>
</Method>

<Method name="%GetAsTree">
<Internal>1</Internal>
<FormalSpec>*pTree</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.Util.Value">
<Super>DataFieldRange</Super>
<System>3</System>
<TimeCreated>62738,39260.878213</TimeCreated>

<Property name="value">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="displayValue">
<Type>%DeepSee.PMML.Datatype.String</Type>
<Parameter name="MAXLEN" value="2000"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="property">
<Type>%DeepSee.PMML.Datatype.String</Type>
<InitialExpression>"valid"</InitialExpression>
<Parameter name="VALUELIST" value=",valid,invalid,missing"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.abstractNode">
<Abstract>1</Abstract>
<IncludeCode>%PMML</IncludeCode>
<Super>%RegisteredObject,%XML.Adaptor</Super>
<System>3</System>
<TimeCreated>62739,33299.859558</TimeCreated>
<Inheritance>right</Inheritance>

<Method name="%ValidatePMML">
<Description><![CDATA[
Ensures <method>%ValidateObject</method> is called for this node and all its nested
%PMML subnodes.
This works depth-first, so all nested elements are validated before the nesting element
itself gets validated. Therefore, <method>%OnValidateObject</method> methods may assume
nested elements are fully validated.]]></Description>
<Final>1</Final>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pForce:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<ForceGenerate>1</ForceGenerate>
<Implementation><![CDATA[
	#define Write(%c) do %code.WriteLine($c(9)_%c)
	set tSC = $$$OK
	try {
		$$$Write("set tSC = $$$OK")
		
		for i = 1:1:%compiledclass.Properties.Count() {
			#dim tProp As %Dictionary.CompiledProperty = %compiledclass.Properties.GetAt(i)
			continue:'$$IsDerivedFrom^%occLibrary(tProp.Type,"%DeepSee.PMML.Definition.abstractNode")
			
			if tProp.Collection = "list" {
				
				$$$Write("if $isobject(i%"_tProp.Name_") {")
				$$$Write("	for j = 1:1:i%"_tProp.Name_".Count() {")
				$$$Write("		set tPropObj = i%"_tProp.Name_".GetAt(j)")
				$$$Write("		continue:tPropObj=""""")
				$$$Write("		set tSC = tPropObj.%ValidatePMML(pForce)")
				$$$Write("		quit:$$$ISERR(tSC)")
				$$$Write("	}")
				$$$Write("	quit:$$$ISERR(tSC) tSC")
				$$$Write("}")
				
			} else {
				
				$$$Write("set:i%"_tProp.Name_"'="""" tSC = i%"_tProp.Name_".%ValidatePMML(pForce)")
				$$$Write("quit:$$$ISERR(tSC) tSC")	
							
			}
		}
		quit:$$$ISERR(tSC)
		
		$$$Write("quit ..%ValidateObject(pForce)")
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Description>
Adds node-specific validation checks</Description>
<FormalSpec>force:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition">
<Copyright>/* Copyright (c) 2018 by InterSystems Corporation.
   Cambridge, Massachusetts, U.S.A.  All rights reserved.
   Confidential property of InterSystems Corporation. */</Copyright>
<Description><![CDATA[
<p>This class represents a predictive model described in PMML (Predictive Modelling Markup Language),
an XML standard managed by the Data Mining Group (<a href="http://www.dmg.org/" target="_new">www.dmg.org</a>)
for describing Predictive Analytics models.</p>
<p>Subclasses of this class should provide this XML in an XData block named <XData>PMML</XData>,
so it will be validated and interpreted upon compiling the class. Upon compilation, additional
helper classes will be automatically generated:
<ul>
<li>A single <class>%DeepSee.PMML.Data</class> class representing the data fields required by this model.</li>
<li>A class for each model described in this PMML fragment (can be more than one), with dedicated
code to execute this model.</li>
<li><class>%DeepSee.PMML.ModelInput</class> and <class>%DeepSee.PMML.ModelOutput</class> classes
for each model, which are instantiated and managed automatically by the model class.</li>
</ul>
<p>In addition to the generated classes, subclasses of this class are also available
as Zen pages so the models they define can be run from a User Interface.</p>
<p>Use this class' <method>%GetModelClassName</method> to retrieve the model class for a named
model in the PMML definition and then invoke its %Execute* methods as desired. See also the
<class>%DeepSee.PMML.Model.AbstractModel</class> class reference for more information about 
these execution options, or <class>%DeepSee.PMML.Utils</class> for executing the model against
a batch of records at once.</p>]]></Description>
<Abstract>1</Abstract>
<CompileAfter>%DeepSee.PMML.Definition.PMML</CompileAfter>
<IncludeCode>%PMML,%DeepSee,%occSAX</IncludeCode>
<Super>%ZEN.Component.page</Super>
<System>4</System>
<TimeCreated>62738,61653.80257</TimeCreated>

<Parameter name="DOMAIN">
<Default>PMML</Default>
</Parameter>

<Parameter name="DISABLETRACING">
<Description>
Set to 1 to disable the use of tracing model output altogether</Description>
<Internal>1</Internal>
<Default>0</Default>
</Parameter>

<XData name="PMML">
<Description>
The XData block containing the actual PMML specification.</Description>
<XMLNamespace>http://www.intersystems.com/deepsee/pmml</XMLNamespace>
</XData>

<Method name="%GetDefinition">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>*pPMML:%DeepSee.PMML.Definition.PMML</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set tSC = $$$OK
    try {
        
        // exit if we're not in an actual PMML definition
        if (%class.Abstract || (%class.Name = "%DeepSee.PMML.Definition")) {
            do %code.WriteLine(" quit """"")
            quit
        }
        
        // first locate the PMML XData block
        set tXDataIndex = %compiledclass.XDatas.FindObjectId(%class.Name_"||PMML")
        if (tXDataIndex="") {
            set tSC = $$$ERROR($$$GeneralError, "No PMML XData block")
            quit
        }
        set tXDataStream = %compiledclass.XDatas.GetAt(tXDataIndex).Data
        do tXDataStream.Rewind()
        if (tXDataStream.Size <= 0) {
            set tSC = $$$ERROR($$$GeneralError, "PMML XData block is empty")
            quit
        }
        
        // correlate the XData stream with %DeepSee.PMML.Definition.PMML
        set tReader = ##class(%XML.Reader).%New()
        set tReader.SAXFlags = $$$SAXNOVALIDATION // BDB738
        set tSC = tReader.OpenStream(tXDataStream)
        quit:$$$ISERR(tSC)
        
        do tReader.Correlate("PMML","%DeepSee.PMML.Definition.PMML")
        
        do tReader.Next(.tPMML,.tSC)
        quit:$$$ISERR(tSC)
        
        #dim tPMML As %DeepSee.PMML.Definition.PMML
        if '$isobject(tPMML) {
            set tSC = $$$ERROR($$$GeneralError,"No <PMML> element in XData.")
            quit
        }
        
        // validate PMML contents
        set tSC = tPMML.%ValidatePMML(1)
        quit:$$$ISERR(tSC)
        
        set tSC = ##class(%DeepSee.PMML.Generator).%CreateClasses(tPMML, %class.Name)
        quit:$$$ISERR(tSC)
        
        // now output actual implementation in case code would need %DeepSee.PMML.Definition object
        #define WriteLine(%c) do %code.WriteLine($c(9)_%c)
        $$$WriteLine("set tSC = $$$OK")
        $$$WriteLine("try {")
        $$$WriteLine("	set tXData = ##class(%Dictionary.CompiledXData).%OpenId("""_%compiledclass.Name_"||PMML"")")
        $$$WriteLine("	set tReader = ##class(%XML.Reader).%New()")
        $$$WriteLine("	set tReader.SAXFlags = $$$SAXNOVALIDATION") // BDB738
        $$$WriteLine("	set tSC = tReader.OpenStream(tXData.Data)")
        $$$WriteLine("	quit:$$$ISERR(tSC)")
        $$$WriteLine("	do tReader.Correlate(""PMML"",""%DeepSee.PMML.Definition.PMML"")")
        $$$WriteLine("	do tReader.Next(.pPMML,.tSC)")
        $$$WriteLine("	quit:$$$ISERR(tSC)")
        $$$WriteLine("} catch (ex) {")
        $$$WriteLine("	set tSC = ex.AsStatus()")
        $$$WriteLine("}")
        $$$WriteLine("quit tSC")
    } catch (ex) {
        set tSC = ex.AsStatus()
    }
    quit tSC
]]></Implementation>
</Method>

<Method name="%GetModelInstance">
<Description><![CDATA[
This method returns a <class>%DeepSee.PMML.Model.AbstractModel</class> instance for the model in
this definition corresponding to <var>pModelName</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pModelName:%String="",&pModel:%DeepSee.PMML.Model.AbstractModel]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set tModelClassName = ..%GetModelClassName(.pModelName)
		if (tModelClassName="") {
			set tSC = $$$ERROR($$$GeneralError, "Unknown model name: '"_pModelName_"'")
			quit
		}
		set pModel = $classmethod(tModelClassName, "%New")
		set:pModel="" tSC = %objlasterror
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%GetModelClassName">
<Description><![CDATA[
Returns the class name of the model identified by <var>pModelName</var> in <xdata>PMML</xdata>.
If left blank, returns the class name of the first model in the model definition, setting
<var>pModelName</var> to its logical name at the same time.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec><![CDATA[&pModelName:%String=""]]></FormalSpec>
<GenerateAfter>%GetDefinition</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    // default to the first one
    set i = "", tIsFirst=1
	for {
		set i = $order(%PMML("Models",i), 1, tModelClassName)
		quit:i=""
		continue:i="DATA"
		set tModelName = %PMML("Classes",$$$UPPER(tModelClassName))
		if (tIsFirst) {
			do %code.WriteLine("	if (pModelName="""") || (pModelName = "_$$$QUOTE(tModelName)_") {")
			do %code.WriteLine("		set pModelName = "_$$$QUOTE(tModelName))
		} else {
			do %code.WriteLine("	} elseif (pModelName = "_$$$QUOTE(tModelName)_") {")
		}
		set tIsFirst=0
		do %code.WriteLine("		quit "_$$$QUOTE(tModelClassName))
	}
	do:'tIsFirst %code.WriteLine("	}")
	do %code.WriteLine("	quit """"")
    quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetDataClassName">
<Description><![CDATA[
Returns the name of the <class>%DeepSee.PMML.Data</class> class generated upon compiling
this PMML definiton.]]></Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[    quit $classname()_".Data"
]]></Implementation>
</Method>

<Method name="%CreateDataset">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDataSource:%String="",*pDataset:%DeepSee.PMML.Dataset</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	quit $classmethod(..%GetDataClassName(), "%CreateDataset", pDataSource, .pDataset)
]]></Implementation>
</Method>

<Method name="%GetModels">
<Description><![CDATA[
<p>Returns pModels(n) = $lb(modelName, class, type)</p>
<p>If <var>pIncludeSecondary</var>=1, models nested within composite models will also be returned.
Note that these cannot necessarily be invoked separately.</p>]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>*pModels,pIncludeSecondary:%Boolean=0</FormalSpec>
<GenerateAfter>%GetModelClassName</GenerateAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	do %code.WriteLine("	kill pModels")
    set i = ""
	for {
		set i = $order(%PMML("Models",i), 1, tModelClassName)
		quit:i=""
		continue:i="DATA"
		set tModelName = %PMML("Classes",$$$UPPER(tModelClassName))
		set tModelType = $g(%PMML("Classes",$$$UPPER(tModelClassName),"type"))
		set tIsSecondary = ($g(%PMML("Models",i,"parent"))'="")
		do %code.WriteLine("	set"_$s(tIsSecondary:":pIncludeSecondary", 1:"")_" pModels($i(pModels)) = $lb("_$$$QUOTE(tModelName)_", "_$$$QUOTE(tModelClassName)_", "_$$$QUOTE(tModelType)_")")
	}
	do %code.WriteLine("	quit $$$OK")
	kill %PMML
	quit $$$OK
]]></Implementation>
</Method>

<XData name="Contents">
<Description><![CDATA[
XData block defining the contents of the GUI presenting a manual interfacte for running the
models described in <xdata>PMML</xdata>]]></Description>
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<page xmlns="http://www.intersystems.com/zen" enclosingStyle="padding-top:30px;"
     title="PMML Model test page" width="100%" height="100%" layout="horizontal">
<jsonProvider id="json" OnGetTargetObject="OnGetData" OnSubmitContent="OnSubmitData" />
<spacer width="15%" />
<vgroup width="70%">
<titleBox title="PMML Model test page" />
<spacer height="15" />
<hgroup width="100%" cellVAlign="top">

<vgroup width="45%" cellVAlign="top" height="100%">
<titleBox title="Data object" />
<spacer height="10" />
<form labelPosition="left" id="frmProperties" controllerId="json" />
<spacer height="10" />
<link caption="Go to batch test page" id="lnkBatchTestPage" />
</vgroup>

<spacer width="25" />

<vgroup width="45%" cellVAlign="top" height="100%">
<select id="selModel" label="Model" onchange="zenPage.onChangeModel(zenThis.getValue());" />
<spacer height="20" />
<label label="Predicted value:" />
<html id="htmlOutput" OnDrawContent="DrawOutput" />
<spacer height="20" />
<label label="Trace info:" />
<html id="htmlTrace" OnDrawContent="DrawTrace" />
</vgroup>

</hgroup>
</vgroup>
<spacer width="15%" />
</page>
]]></Data>
</XData>

<Method name="OnGetData">
<Internal>1</Internal>
<FormalSpec><![CDATA[&pParameters,*pObject:%RegisteredObject]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set pObject = $classmethod(..%GetDataClassName(), "%New")
    quit $$$OK
]]></Implementation>
</Method>

<Method name="OnSubmitData">
<Internal>1</Internal>
<FormalSpec>pCommand:%String,pProvider:%ZEN.Auxiliary.jsonProvider,pObject:%RegisteredObject,*pResponse:%RegisteredObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set tSC = $$$OK 
    try {
        if '$isobject(pObject) {
	        set %session.Data("pmml", $zcrc($classname(),7)) = ""
	        quit
        }
        
        // first ensure all getters are called to populate derived fields
        do pObject.%GetAsArray(.tArray,.tStatusArray)
        set tSC = pObject.%SerializeObject(.tSerial)
	    quit:$$$ISERR(tSC)
	    
	    // store serialized form for pickup by DrawOutput() and DrawTrace()
        set %session.Data("pmml", $zcrc($classname(),7)) = $g(tSerial)
        
        // send back the response, which should contain updated derived fields
        set pResponse = pObject
        
        // update status hints
        set tField = ""
        for {
	        set tField = $order(tStatusArray(tField),1, tStatus)
	        quit:tField=""
	        set tInputName = "input"_$$$PROPERTYNAME(tField)
	        &js<zen('#(tInputName)#').setProperty('hint','#(tStatus)#');>
        }
        
    } catch (ex) {
        set tSC = ex.AsStatus()
    }
    quit tSC
]]></Implementation>
</Method>

<Method name="%OnAfterCreatePage">
<Description><![CDATA[
Populates the properties and models on this Zen page according to the contents of <xdata>PMML</xdata>]]></Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set tSC = $$$OK 
    try {
        
        // populate properties form
        set tSC = ..%AddProperties()
        quit:$$$ISERR(tSC)
        
        
        // populate selModel
        set tSC = ..%GetModels(.tModels)
        quit:$$$ISERR(tSC)
        set (tValueList,tDisplayList) = ""
        for i = 1:1:$g(tModels) {
	        set tValueList = tValueList _ "," _ $li(tModels(i),1)
	        set tDisplayList = tDisplayList _ "," _ $li(tModels(i),1) _ " ("_$li(tModels(i),3)_")"
        }
        set tSelModel = ..%GetComponentById("selModel")
        set tSelModel.valueList = $e(tValueList,2,*)
        set tSelModel.displayList = $e(tDisplayList,2,*)
        set tSelModel.value = $g(%request.Data("MODEL",1))
        
        // populate link to batch test page
        set tLink = ..%GetComponentById("lnkBatchTestPage")
        if $g(%request.Data("EMBEDDED",1)) {
	        set tLink.hidden = 1
        } else {
	        set tLink.href = "_DeepSee.PMML.UI.ModelTester.zen?CLASS="_$classname()
        }
        
    } catch (ex) {
        set tSC = ex.AsStatus()
    }
    quit tSC
]]></Implementation>
</Method>

<Method name="%AddProperties">
<Internal>1</Internal>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
	    set tForm = ..%GetComponentById("frmProperties")
	    
	    set tSC = ..%GetDefinition(.tDefinition)
	    quit:$$$ISERR(tSC)
	    quit:'$isobject(tDefinition.DataDictionary)
	    
	    #dim tDataField As %DeepSee.PMML.Definition.DataField
	    #dim tValue As %DeepSee.PMML.Definition.Util.Value
	    set tAllPropNames = ""
	    for i = 1:1:tDefinition.DataDictionary.DataFields.Count() {
		    set tDataField = tDefinition.DataDictionary.DataFields.GetAt(i)
			
		    if (tDataField.dataType="boolean") {
			    
		        set tInput = ##class(%ZEN.Component.select).%New()
		        set tInput.valueList = "0,1"
		        set tInput.displayList = "false,true"
		        
		    } elseif tDataField.Values.Count() && (tDataField.optype'="continuous") {
		    
		        set tInput = ##class(%ZEN.Component.select).%New()
		        set (tValueList, tDisplayList) = ""
		        for j = 1:1:tDataField.Values.Count() {
			        set tValue = tDataField.Values.GetAt(j)
			        continue:'tValue.%IsA("%DeepSee.PMML.Definition.Util.Value")
			        set tValueList = tValueList_","_tValue.value
			        set tDisplayList = tDisplayList_","_$s(tValue.displayValue'="":tValue.displayValue, 1:tValue.value)
		        }
		        set tInput.valueList = $e(tValueList,2,*)
		        set tInput.displayList = $e(tDisplayList,2,*)
		        
		    } else {
		    
		        set tInput = ##class(%ZEN.Component.text).%New()
		        
		    }
		    
		    set tPropName = $$$PROPERTYNAME(tDataField.name)
		    set tAllPropNames = tAllPropNames _ "," _ tPropName
		    set tInput.id = "input"_tPropName
		    set tLabel = $s(tDataField.displayName'="":tDataField.displayName, 1:tDataField.name)
		    $$$CAMELSPACE(tLabel,tLabelFormatted)
		    set tInput.label = tLabelFormatted
		    set tInput.dataBinding = $$$PROPERTYNAME(tDataField.name)
		    set tInput.hint = "missing"
		    set tInput.labelStyle = "margin-right:10px;"
		    set tInput.onchange = "zenPage.update('"_tPropName_"',zenThis.getValue());"
		    
		    do tForm.%AddChild(tInput)
	    }
	    
	    if $isobject(tDefinition.TransformationDictionary) {
		    #dim tDerivedField As %DeepSee.PMML.Definition.DerivedField
		    for i = 1:1:tDefinition.TransformationDictionary.DerivedFields.Count() {
			    set tDerivedField = tDefinition.TransformationDictionary.DerivedFields.GetAt(i)
				
			    set tInput = ##class(%ZEN.Component.text).%New()
			    set tPropName = $$$PROPERTYNAME(tDerivedField.name)
			    set tAllPropNames = tAllPropNames _ "," _ tPropName
			    set tInput.id = "input"_tPropName
			    set tLabel = $s(tDerivedField.displayName'="":tDerivedField.displayName, 1:tDerivedField.name)
			    $$$CAMELSPACE(tLabel,tLabelFormatted)
		   		set tInput.label = tLabelFormatted
			    set tInput.dataBinding = $$$PROPERTYNAME(tDerivedField.name)
			    set tInput.hint = "missing"
			    set tInput.labelStyle = "margin-right:10px;"
			    set tInput.readOnly = 1
			    set tInput.disabled = 1
			    
			    do tForm.%AddChild(tInput)
		    }
	    }
	    
	    set tButton = ##class(%ZEN.Component.button).%New()
	    set tButton.caption="reset", tButton.id="reset", tButton.onclick="zenPage.reset();"
	    do tForm.%AddChild(tButton)
	    
	    set tHidden = ##class(%ZEN.Component.hidden).%New()
	    set tHidden.id = "hidPropNames"
	    set tHidden.value = $e(tAllPropNames,2,*)
	    do tForm.%AddChild(tHidden)
	    
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
    quit $$$OK
]]></Implementation>
</Method>

<Method name="GetInputFieldsForModel">
<Internal>1</Internal>
<FormalSpec>pModel:%String,pSeparator:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tFieldList = ""
	quit:pModel="" ""
	
	do $classmethod(..%GetModelClassName(pModel), "%GetDefinition", .tModelDef)
	
	// first build a list of all the fields used by this model
	kill tModelFields
	for i = 1:1:tModelDef.MiningSchema.MiningFields.Count() {
		set tMiningField = tModelDef.MiningSchema.MiningFields.GetAt(i)
		continue:$$$PMMLusageTypeIsTarget(tMiningField.usageType)
		set tModelFields(tMiningField.name) = ""
	}
	if ($isobject(tModelDef.LocalTransformations)) {
		for i = 1:1:tModelDef.LocalTransformations.DerivedFields.Count() {
			set tDerivedField = tModelDef.LocalTransformations.DerivedFields.GetAt(i)
			set tModelFields(tDerivedField.name) = ""
			do tDerivedField.Expression.%GetInputFields(.tModelFields)
		}
	}
	
	// append eventual inputs found through TransformationDictionary
	do ..%GetDefinition(.tPMML)
	if $isobject(tPMML.TransformationDictionary) {
		for i = 1:1:tPMML.TransformationDictionary.DerivedFields.Count() {
			set tDerivedField = tPMML.TransformationDictionary.DerivedFields.GetAt(i)
			continue:'$d(tModelFields(tDerivedField.name))
			do tDerivedField.Expression.%GetInputFields(.tModelFields)
		}
	}
	
	// now build the actual list based on the DataDictionary
	for i = 1:1:tPMML.DataDictionary.DataFields.Count() {
		set tDataField = tPMML.DataDictionary.DataFields.GetAt(i)
		continue:'$d(tModelFields(tDataField.name))
		set tFieldList = tFieldList _ pSeparator _ $$$PROPERTYNAME(tDataField.name)
	}
	quit $e(tFieldList,1+$l(pSeparator),*)
]]></Implementation>
</Method>

<Method name="update">
<Description>
Update test page contents based on user input</Description>
<FormalSpec>id,value</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
    var sc = zen('json').submitContent('save');
    zen('htmlOutput').refreshContents();
    zen('htmlTrace').refreshContents();
	zenPage.disableUnusedFields();
]]></Implementation>
</Method>

<Method name="reset">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zen('json').reloadContents();
	
	// reset hints
	var ctrls = zen('frmProperties').getControlList();
	for (var i = 0; i < ctrls.length; i++) {
		var id = ctrls[i].id;
		if (id == 'reset') continue;
		zen(id).setProperty('hint', 'missing'); 
	}
	
    zenPage.update();
]]></Implementation>
</Method>

<Method name="disableUnusedFields">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var model = zen('selModel').getValue();
	var fieldsInUse = this._inputFields;
	// disable all controls not used for this model
	var ctrls = zen('frmProperties').getControlList();
	for (var i = 0; i < ctrls.length; i++) {
		var id = ctrls[i].id;
		if (id == 'reset') continue;
		zen(id).setProperty('disabled', !fieldsInUse || (fieldsInUse.indexOf('^'+id.substring(5)+'^') < 0)); 
	}
]]></Implementation>
</Method>

<Method name="onloadHandler">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// initialize input fields if model is set through URL parameter
    var model = zen('selModel').getValue();
    if ((model!='') && (model!=null)) {
	    this._inputFields = '^'+zenPage.GetInputFieldsForModel(model,'^')+'^';
    }
    
    // invoke update() so status information is initialized
	zenPage.update();
]]></Implementation>
</Method>

<Method name="onChangeModel">
<Description>
Invoked when selecting a model in the GUI</Description>
<FormalSpec>model</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	this._inputFields = '^'+zenPage.GetInputFieldsForModel(model,'^')+'^';
	var sc = zen('htmlOutput').setProperty('seed', model);
	var sc = zen('htmlTrace').setProperty('seed', model);
	
	zenPage.reset();
]]></Implementation>
</Method>

<Method name="GetTestOutput">
<Internal>1</Internal>
<FormalSpec>pModelName:%String,*pModel:%DeepSee.PMML.Model.AbstractModel,*pOutput:%DeepSee.PMML.ModelOutput,pTrace:%Boolean=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set tSC = $$$OK
    try {
        set tSerial = $g(%session.Data("pmml", $zcrc($classname(),7)))
        set tDataObject = $classmethod(..%GetDataClassName(), "%Open", tSerial)
        if (tDataObject="") {
	        set tSC = %objlasterror
	        quit
        }
        
        set tSC = ..%GetModelInstance(pModelName, .pModel)
        quit:$$$ISERR(tSC)
        
        // execute model
     	set:'..#DISABLETRACING pModel.Tracing = pTrace
        set tSC = pModel.%ExecuteModel(tDataObject, .pOutput)
        quit:$$$ISERR(tSC)
        
    } catch (ex) {
        set tSC = ex.AsStatus()
    }
    quit tSC
]]></Implementation>
</Method>

<Method name="DrawTrace">
<Internal>1</Internal>
<FormalSpec>pSeed:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set tSC = $$$OK
    try {
	    quit:pSeed=""
	    
	    #dim tOutput As %DeepSee.PMML.ModelOutput
	    set tSC = ..GetTestOutput(pSeed, .tModel, .tOutput, '..#DISABLETRACING)
	    quit:$$$ISERR(tSC)
	    
	    if ..#DISABLETRACING {
		    &html<<p>disabled</p>>
	    } else {
		    set tSC = tModel.%DrawTraceInfo(tOutput)
		    quit:$$$ISERR(tSC)
	    }
	        
    } catch (ex) {
        set tSC = ex.AsStatus()
    }
    quit tSC
]]></Implementation>
</Method>

<Method name="DrawOutput">
<Internal>1</Internal>
<FormalSpec>pSeed:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set tSC = $$$OK
    try {
	    quit:pSeed=""
	    
	    #dim tOutput As %DeepSee.PMML.ModelOutput
	    set tSC = ..GetTestOutput(pSeed,, .tOutput)
	    quit:$$$ISERR(tSC)
	    quit:$g(tOutput)=""
	    
	    set tPredictedValue = $zconvert(tOutput.%GetFeatureValue("predictedValue"),"O","HTML")
	    set tPredictedValue = $$FormatValue(tPredictedValue)
	    write "<div style='font-size:25px;font-weight:bold;'>"_tPredictedValue_"</div>"
        
        do tOutput.%GetFields(.tFields)
        
        // don't display anything else if there is only one output field
        quit:$o(tFields(""))=$o(tFields(""),-1) 
        
	    &html<<table style="margin-top:20px;">>
        set tPropName = ""
        for {
            set tPropName = $order(tFields(tPropName),1,tInfo)
            quit:tPropName=""
            set tFeature = $li(tInfo,1), tDisplayName = $li(tInfo,3)
            set tValue = $$FormatValue($property(tOutput, $$$PROPERTYNAME(tPropName)))
            
            &html<<tr><td>#(tDisplayName)#:</td><td width="10">&nbsp;</td><td>#(tValue)#</td></tr>>
        }
        &html<</table>>
        
    } catch (ex) {
        set tSC = ex.AsStatus()
    }
    quit tSC
    
FormatValue(tValue)
    set:tValue="" tValue = "[null]"
    set:+tValue&&(tValue#1) tValue = $fnumber(tValue,"",4)
    quit tValue
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Definition.extendableNode">
<Abstract>1</Abstract>
<Super>node</Super>
<System>3</System>
<TimeCreated>62777,57635.394168</TimeCreated>

<Property name="Extension">
<Type>%DeepSee.PMML.Definition.Extension</Type>
<Collection>list</Collection>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%DeepSee.PMML.Definition.node">
<Abstract>1</Abstract>
<Super>abstractNode</Super>
<System>3</System>
<TimeCreated>62735,41773.186607</TimeCreated>

<Parameter name="XMLIGNOREINVALIDATTRIBUTE">
<Default>0</Default>
</Parameter>

<Parameter name="XMLSEQUENCE">
<Default>1</Default>
</Parameter>
</Class>


<Class name="%DeepSee.PMML.Generator">
<Copyright>/* Copyright (c) 2018 by InterSystems Corporation.
   Cambridge, Massachusetts, U.S.A.  All rights reserved.
   Confidential property of InterSystems Corporation. */</Copyright>
<Description><![CDATA[
System class generating PMML model code, called as part of compiling a 
<class>%DeepSee.PMML.Definition</class> class. Although undoubtly tempting, do not invoke
this class directly!]]></Description>
<Hidden>1</Hidden>
<IncludeCode>%PMML,%DeepSee</IncludeCode>
<System>4</System>
<TimeCreated>63060,36129.615882</TimeCreated>

<Method name="%CreateClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>pPMML:%DeepSee.PMML.Definition.PMML,pDefinitionClassName:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		quit:pDefinitionClassName=""
		
		kill %PMML
		set %PMML("DefinitionClass") = pDefinitionClassName
		set %PMML("DisableTracing") = $g(%parameter("DISABLETRACING"),0) // BDB823
		
		set tSC = ..%CreateDataClass(pPMML)
		quit:$$$ISERR(tSC)
		
		for i = 1:1:pPMML.Models.Count() {
			set tSC = ..%CreateModelClasses(pPMML.Models.GetAt(i))
			quit:$$$ISERR(tSC)
		}
		quit:$$$ISERR(tSC)
		
		// PPG gets cleaned up when compiling %DeepSee.PMML.Definition.%GetModels()
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%CreateDataClass">
<Description><![CDATA[
Creates the <class>%DeepSee.PMML.Data</class> subclass for this PMML definition]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pPMML:%DeepSee.PMML.Definition.PMML</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #define QuoteIf(%if,%v) $s(%if:$$$QUOTE(%v), (%v=""):"""""", 1:%v)
    #define WriteLine(%m,%c) do %m.Implementation.WriteLine($c(9)_%c)
    
	set tSC = $$$OK
	try {
		set tDefinitionClassName = %PMML("DefinitionClass")
        
        // create data class
        set tDataClassName = tDefinitionClassName_".Data"
        if $$$defClassDefined(tDataClassName) {
            set tSC = $$Delete^%apiOBJ(tDataClassName,"-d")
            quit:$$$ISERR(tSC)
        }
        
        set %PMML("Models", "DATA") = tDataClassName
        set %PMML("Classes", $$$UPPER(tDataClassName)) = "DATA"
        
        set tDataClass = ##class(%Dictionary.ClassDefinition).%New()
        set tDataClass.Name = tDataClassName
        set tDataClass.ProcedureBlock = 1
        set tDataClass.Super = "%DeepSee.PMML.Data"
        set tDataClass.GeneratedBy = tDefinitionClassName
        
        // %GetAsArray() method simply translates values into array
        set tGAMethod = ##class(%Dictionary.MethodDefinition).%New()
        set tGAMethod.Name = "%GetAsArray"
        set tGAMethod.ReturnType = "%Status"
        set tGAMethod.FormalSpec = "*pArray,*pStatus,pSkipMissing:%Boolean=1"
        set tGAMethod.Internal = 1
        $$$WriteLine(tGAMethod,"set tSC = $$$OK")
        $$$WriteLine(tGAMethod,"try {")
        
        // %OnOpen() method ensures property status is set upon deserialize
        set tOOMethod = ##class(%Dictionary.MethodDefinition).%New()
        set tOOMethod.Name = "%OnOpen"
        set tOOMethod.ReturnType = "%Status"
        set tOOMethod.Private = 1
        set tOOMethod.ServerOnly = 1
        
        // %LoadData() method loads values from array
        set tLDMethod = ##class(%Dictionary.MethodDefinition).%New()
        set tLDMethod.Name = "%LoadData"
        set tLDMethod.ReturnType = "%Status"
        set tLDMethod.FormalSpec = "&pArray"
        set tLDMethod.Internal = 1
        $$$WriteLine(tLDMethod,"set tSC = $$$OK")
        $$$WriteLine(tLDMethod,"try {")
        
        // %LoadObject() method loads values from object
        set tLOMethod = ##class(%Dictionary.MethodDefinition).%New()
        set tLOMethod.Name = "%LoadObject"
        set tLOMethod.ReturnType = "%Status"
        set tLOMethod.FormalSpec = "pObject"
        set tLOMethod.Internal = 1
        $$$WriteLine(tLOMethod,"set tSC = $$$OK")
        $$$WriteLine(tLOMethod,"try {")
        $$$WriteLine(tLOMethod,"	set tClassDef = ##class(%Dictionary.ClassDefinition).%OpenId($classname(pObject))")
        $$$WriteLine(tLOMethod,"	for i = 1:1:tClassDef.Properties.Count() {")
        $$$WriteLine(tLOMethod,"		set tPropDef = tClassDef.Properties.GetAt(i)")
        $$$WriteLine(tLOMethod,"		continue:tPropDef.Private")
        $$$WriteLine(tLOMethod,"		continue:$e(tPropDef.Name)=""%""")
        $$$WriteLine(tLOMethod,"		set tPropNames(tPropDef.Name) = """"")
        $$$WriteLine(tLOMethod,"	}")
        
        kill tBuilderSpecs
        for i = 1:1:pPMML.DataDictionary.DataFields.Count() {
            #dim tDataField As %DeepSee.PMML.Definition.DataField = pPMML.DataDictionary.DataFields.GetAt(i)
            
            set tPropName = $$$PROPERTYNAME(tDataField.name)
            if $d(%PMML("PropNamesI", $$$UPPER(tPropName)), tConflictingName) {
	            set tSC = $$$ERROR($$$GeneralError, "DataField '"_tDataField.name_"' name conflicts with prior field '"_tConflictingName_"'")
	            quit
            }
            set %PMML("PropNamesI", $$$UPPER(tPropName)) = tDataField.name
            
            set tPropType = ##class(%DeepSee.PMML.Datatype.DataType).GetClassname(tDataField.dataType)
            set tQuote = (tDataField.dataType="string") || (tDataField.dataType="")
            set tDisplayName = $s(tDataField.displayName'="":tDataField.displayName, 1:tDataField.name)
            
            set %PMML("Fields",tPropName,"object") = tDataField
            set %PMML("Fields",tPropName,"type") = tPropType
            set %PMML("Fields",tPropName,"datatype") = tDataField.dataType
            set %PMML("Fields",tPropName,"optype") = tDataField.optype
            set %PMML("Fields",tPropName,"displayname") = tDisplayName
            
            set tProp = ##class(%Dictionary.PropertyDefinition).%New()
            set tProp.Name = tPropName
            set tProp.Type = tPropType
            set tProp.Description = "Property for field: """_tDisplayName_""""_$c(13,10)_"   name="""_tDataField.name_""""_$c(13,10)_"   optype="""_tDataField.optype_""""_$c(13,10)_"   dataType="""_tDataField.dataType_""""
            do tDataClass.Properties.Insert(tProp)
            set %PMML("Fields",tPropName,"prop") = tProp
            
            $$$WriteLine(tLDMethod,$c(9)_"set:$d(pArray("_$$$QUOTE(tDataField.name)_"),tValue) .."_tPropName_" = tValue")
            $$$WriteLine(tLOMethod,$c(9)_"set:$d(tPropNames("_$$$QUOTE(tPropName)_")) .."_tPropName_" = pObject."_tPropName)
            $$$WriteLine(tOOMethod,"set .."_tPropName_" = i%"_tPropName)
            
            set tSetter = ##class(%Dictionary.MethodDefinition).%New()
            set tSetter.Name = tPropName_"Set"
            set tSetter.Internal = 1
            set tSetter.ServerOnly = 1
            set tSetter.ReturnType = "%Status"
            set tSetter.FormalSpec = "pValue:"_tPropType
            set tSetter.Description = "Setter method to populate the "_tDataField.name_" property."_$c(13,10)_"Verifies the supplied value according to &lt;DataField&gt; specifications"
            set tSC = ..%GenerateSetterCode(tSetter, tDataField)
            quit:$$$ISERR(tSC)
            $$$WriteLine(tSetter,"set i%"_tPropName_" = pValue")
            $$$WriteLine(tSetter,"do ..%ResetDerivedFields()")
            $$$WriteLine(tSetter,"quit ..%SetPropertyStatus("_$$$QUOTE(tPropName)_",tStatus)")
            do tDataClass.Methods.Insert(tSetter)
            set tProp="", tGetter="", tSetter=""
            
            $$$WriteLine(tGAMethod,"	set:'pSkipMissing||'..%IsMissing("_$$$QUOTE(tDataField.name)_") pArray("_$$$QUOTE(tDataField.name)_") = .."_tPropName_", pStatus("_$$$QUOTE(tDataField.name)_") = ..%GetPropertyStatus("_$$$QUOTE(tPropName)_")")
        }
        quit:$$$ISERR(tSC)
        
        $$$WriteLine(tLDMethod,"} catch (ex) {")
        $$$WriteLine(tLDMethod,$c(9)_"set tSC = ex.AsStatus()")
        $$$WriteLine(tLDMethod,"}")
        $$$WriteLine(tLDMethod,"quit tSC")
        do tDataClass.Methods.Insert(tLDMethod)
        
        $$$WriteLine(tLOMethod,"} catch (ex) {")
        $$$WriteLine(tLOMethod,$c(9)_"set tSC = ex.AsStatus()")
        $$$WriteLine(tLOMethod,"}")
        $$$WriteLine(tLOMethod,"quit tSC")
        do tDataClass.Methods.Insert(tLOMethod)
        
        $$$WriteLine(tOOMethod,"quit $$$OK")
        do tDataClass.Methods.Insert(tOOMethod)
        
        set tRDFMethod = ##class(%Dictionary.MethodDefinition).%New()
        set tRDFMethod.Name = "%ResetDerivedFields"
        set tRDFMethod.ReturnType = "%Status"
        set tRDFMethod.Internal = 1
        
        set tGDFMethod = ##class(%Dictionary.MethodDefinition).%New()
        set tGDFMethod.Name = "%GetDerivedFields"
        set tGDFMethod.ReturnType = "%Status"
        set tGDFMethod.FormalSpec = "&pArray"
        set tGDFMethod.Internal = 1
        
        if $isobject(pPMML.TransformationDictionary) {
            for i = 1:1:pPMML.TransformationDictionary.DerivedFields.Count() {
                #dim tDerivedField as %DeepSee.PMML.Definition.DerivedField = pPMML.TransformationDictionary.DerivedFields.GetAt(i)
                
                set tPropName = $$$PROPERTYNAME(tDerivedField.name)
	            if $d(%PMML("PropNamesI", $$$UPPER(tPropName)), tConflictingName) {
		            set tSC = $$$ERROR($$$GeneralError, "DataField '"_tDerivedField.name_"' name conflicts with prior field '"_tConflictingName_"'")
		            quit
	            }
	            set %PMML("PropNamesI", $$$UPPER(tPropName)) = tDerivedField.name
	            
                set tPropType = ##class(%DeepSee.PMML.Datatype.DataType).GetClassname(tDerivedField.dataType)
                set tDisplayName = $s(tDerivedField.displayName'="":tDerivedField.displayName, 1:tDerivedField.name)
                
                set %PMML("Fields",tPropName,"object") = tDerivedField
                set %PMML("Fields",tPropName,"type") = tPropType
                set %PMML("Fields",tPropName,"datatype") = tDerivedField.dataType
                set %PMML("Fields",tPropName,"optype") = tDerivedField.optype
                set %PMML("Fields",tPropName,"displayname") = tDisplayName
                set %PMML("Fields",tPropName,"isderived") = 1
                set %PMML("Fields",tPropName,"complex") = 1
                
                set tProp = ##class(%Dictionary.PropertyDefinition).%New()
                set tProp.Name = tPropName
                set tProp.Type = tPropType
                set tProp.Description = "Property for derived field: """_tDisplayName_""""_$c(13,10)_"   name="""_tDerivedField.name_""""_$c(13,10)_"   optype="""_tDerivedField.optype_""""_$c(13,10)_"   dataType="""_tDerivedField.dataType_""""
                //set tProp.Calculated = 1
                set tProp.ReadOnly = 1
                do tDataClass.Properties.Insert(tProp)
                set %PMML("Fields",tPropName, "prop") = tProp
                
                set tGetter = ##class(%Dictionary.MethodDefinition).%New()
                set tGetter.Name = tPropName_"Get"
                set tGetter.Internal = 1
                set tGetter.ServerOnly = 1
                set tGetter.ReturnType = tPropType
                set tGetter.Description = "Getter method to retrieve the value of the "_tDerivedField.name_" property."_$c(13,10)_"Implementation based on the EXPRESSION element within &lt;DerivedField&gt;."
                
                set tInline = 1
                set tDerivedFieldCode = tDerivedField.Expression.%GetComputeCode(.tInline)
                
                $$$WriteLine(tGetter,"quit:$d(..%Properties("""_tPropName_""")) i%"_tPropName)
                if tInline {
                    $$$WriteLine(tGetter,"set tValue = "_tDerivedFieldCode)
                } else {
                    do tGetter.Implementation.WriteLine(tDerivedFieldCode)
                }
                $$$WriteLine(tGetter,"set i%"_tPropName_" = tValue")
                $$$WriteLine(tGetter,"do ..%SetPropertyStatus("""_tPropName_""", $g(tStatus,""valid""))")
                $$$WriteLine(tGetter,"quit tValue")
                
                do tDataClass.Methods.Insert(tGetter)
                set %PMML("Fields",tPropName, "getter") = tGetter
                
                $$$WriteLine(tRDFMethod,"kill i%"_tPropName_", i%%Properties("_$$$QUOTE(tPropName)_")")
                $$$WriteLine(tGDFMethod,"set pArray("_$$$QUOTE(tDerivedField.name)_") = .."_tPropName)
                
            	$$$WriteLine(tGAMethod,"	set:'pSkipMissing||'..%IsMissing("_$$$QUOTE(tDerivedField.name)_") pArray("_$$$QUOTE(tDerivedField.name)_") = .."_tPropName_", pStatus("_$$$QUOTE(tDataField.name)_") = ..%GetPropertyStatus("_$$$QUOTE(tPropName)_")")
            }
        }
        $$$WriteLine(tRDFMethod,"quit $$$OK")
        do tDataClass.Methods.Insert(tRDFMethod)
        $$$WriteLine(tGDFMethod,"quit $$$OK")
        do tDataClass.Methods.Insert(tGDFMethod)
        
        $$$WriteLine(tGAMethod,"} catch (ex) {")
        $$$WriteLine(tGAMethod,$c(9)_"set tSC = ex.AsStatus()")
        $$$WriteLine(tGAMethod,"}")
        $$$WriteLine(tGAMethod,"quit tSC")
        do tDataClass.Methods.Insert(tGAMethod)
        
        // now look for any Data Source mappings in the DataDictionary Extension elements
    	// and generate %CreateDataset() code
        set tCDSMethod = ##class(%Dictionary.MethodDefinition).%New()
        set tCDSMethod.Name = "%CreateDataset"
        set tCDSMethod.FormalSpec = "pDataSource:%String="""",*pDataset:%DeepSee.PMML.Dataset"
        set tCDSMethod.ReturnType = "%Status"
        set tCDSMethod.ClassMethod = 1
        set tCDSMethod.Internal = 1
        $$$WriteLine(tCDSMethod,"set tSC = $$$OK")
        $$$WriteLine(tCDSMethod,"try {")
            
        kill tXDataSource
        set tIsFirstDS = 1
        for i = 1:1:pPMML.DataDictionary.Extension.Count() {
	        set tExtension = pPMML.DataDictionary.Extension.GetAt(i)
	        if (tExtension.name="isc:datasource") {
		        for j = 1:1:tExtension.iscExtensions.Count() {
			      	set tDataSource = tExtension.iscExtensions.GetAt(j)
			      	continue:'tDataSource.%IsA("%DeepSee.PMML.Definition.Extension.DataSource")
			      	
			      	set c = $classname(tDataSource)
			      	set tXDataSource(c, $i(tXDataSource(c))) = tDataSource
			      	
			      	// generate code to re-generate the Dataset
		            if (tIsFirstDS) {
			            set tIsFirstDS = 0
			            $$$WriteLine(tCDSMethod,"	if (pDataSource="""") || (pDataSource="_$$$QUOTE(tDataSource.name)_") {")
			        } else {
			            $$$WriteLine(tCDSMethod,"	} elseif (pDataSource="_$$$QUOTE(tDataSource.name)_") {")
			        }
			        for k = 1:1:tDataSource.Fields.Count() {
				        set tField = tDataSource.Fields.GetAt(k)
				        $$$WriteLine(tCDSMethod,"		set tFields($i(tFields)) = $lb("_$$$QUOTE(tField.fieldName)_", "_$$$QUOTE(tField.spec)_", "_$$$QUOTE(%PMML("Fields",$$$PROPERTYNAME(tField.fieldName),"datatype"))_", "_$$$QUOTE(%PMML("Fields",$$$PROPERTYNAME(tField.fieldName),"optype"))_")")
			        }
			      	if (c = "%DeepSee.PMML.Definition.Extension.DeepSeeDataSource") {
				      	$$$WriteLine(tCDSMethod,"		set pDataset = ##class(%DeepSee.PMML.Dataset.Cube).%Create("_$$$QUOTE(tDataSource.name)_", "_$$$QUOTE(tDataSource.cubeName)_", .tFields, "_$$$QUOTE(tDataSource.filter)_", .tSC)")
			      	} elseif (c = "%DeepSee.PMML.Definition.Extension.SQLDataSource") {
				      	$$$WriteLine(tCDSMethod,"		set tSQL = "_$$$QUOTE($zstrip(tDataSource.SQL,"<>WC")))
				      	$$$WriteLine(tCDSMethod,"		set pDataset = ##class(%DeepSee.PMML.Dataset.SQL).%Create("_$$$QUOTE(tDataSource.name)_", tSQL, .tFields,, "_$$$QUOTE(tDataSource.idField)_", .tSC)")
			      	}
		        }
	        }
        }
        if ($d(tXDataSource)) {
        	$$$WriteLine(tCDSMethod,"	} else { set tSC = $$$ERROR($$$GeneralError, ""Unknown Data Source: '""_pDataSource_""'"") }")
        }
        $$$WriteLine(tCDSMethod,"} catch (ex) {")
        $$$WriteLine(tCDSMethod,"  set tSC = ex.AsStatus()")
        $$$WriteLine(tCDSMethod,"}")
        $$$WriteLine(tCDSMethod,"quit tSC")
        do tDataClass.Methods.Insert(tCDSMethod)
    
        // create %CreateFromDeepSee() and %GetDeepSeeSpec() methods
        if $d(tXDataSource("%DeepSee.PMML.Definition.Extension.DeepSeeDataSource"), tMapCount) {
            
            set tFDSFMethod = ##class(%Dictionary.MethodDefinition).%New()
            set tFDSFMethod.Name = "%CreateFromDeepSee"
            set tFDSFMethod.FormalSpec = "pFactId:%Integer,*pData:%DeepSee.PMML.Data,pDataSource:%String="""""
            set tFDSFMethod.ReturnType = "%Status"
            set tFDSFMethod.ClassMethod = 1
            
            set tGDSSMethod = ##class(%Dictionary.MethodDefinition).%New()
            set tGDSSMethod.Name = "%GetDeepSeeSpec"
            set tGDSSMethod.FormalSpec = "pPropertyName:%String,pDataSource:%String="""""
            set tGDSSMethod.ReturnType = "%String"
            set tGDSSMethod.ClassMethod = 1
            set tGDSSMethod.Internal = 1
            
            $$$WriteLine(tFDSFMethod,"set tSC = $$$OK, pData = """"")
            $$$WriteLine(tFDSFMethod,"try {")
            $$$WriteLine(tFDSFMethod,"  set pData = ..%New()")
            
            for i = 1:1:tMapCount {
	            set tDSMap = tXDataSource("%DeepSee.PMML.Definition.Extension.DeepSeeDataSource",i)
	            
	            set tCubeName = $$$DeepSeeIndex(tDSMap.cubeName)
	            set tCubeFactClass = ##class(%DeepSee.Utils).%GetCubeFactClass(tCubeName, .tSC)
	            quit:$$$ISERR(tSC)
	            
	            $$$WriteLine(tFDSFMethod,"")
	            if (i=1) {
		            $$$WriteLine(tFDSFMethod,"	if (pDataSource="""") || (pDataSource="_$$$QUOTE(tDSMap.name)_") {")
		            $$$WriteLine(tGDSSMethod,"if (pDataSource="""") || (pDataSource="_$$$QUOTE(tDSMap.name)_") {")
		        } else {
		            $$$WriteLine(tFDSFMethod,"	} elseif (pDataSource="_$$$QUOTE(tDSMap.name)_") {")
		            $$$WriteLine(tGDSSMethod,"} elseif (pDataSource="_$$$QUOTE(tDSMap.name)_") {")
		        }
	            $$$WriteLine(tFDSFMethod,"  		set tFact = ##class("_tCubeFactClass_").%OpenId(pFactId)")
	            
	            for j = 1:1:tDSMap.Fields.Count() {
	                set tField = tDSMap.Fields.GetAt(j)
	                set tPropName = tField.fieldName, tSpec = tField.spec
	                
	                $$$WriteLine(tGDSSMethod,"	quit:($$$PROPERTYNAME(pPropertyName)="_$$$QUOTE(tPropName)_") "_$$$QUOTE(tSpec))
	                
	                set tSC = ##class(%DeepSee.PMML.Utils.DeepSee).GetFactPropertyForSpec(tCubeName, tSpec, 0, .tGetCode)
	                quit:$$$ISERR(tSC)
	                $$$WriteLine(tFDSFMethod,"  		set tPropValue = tFact."_tGetCode)
	                $$$WriteLine(tFDSFMethod,"  		set pData."_$$$PROPERTYNAME(tPropName)_" = $s(tPropValue="_$$$QUOTE($$$DeepSeeNullMarker)_":"""", 1:tPropValue)")
	            }
	            quit:$$$ISERR(tSC)
	        }
	        quit:$$$ISERR(tSC)
	            
	        $$$WriteLine(tGDSSMethod,"}")
            $$$WriteLine(tGDSSMethod,"quit """"")
	        
	        $$$WriteLine(tFDSFMethod,"	} else { set tSC = $$$ERROR($$$GeneralError, ""Unknown Data Source: '""_pDataSource_""'"") }")
            $$$WriteLine(tFDSFMethod,"} catch (ex) {")
            $$$WriteLine(tFDSFMethod,"  set tSC = ex.AsStatus()")
            $$$WriteLine(tFDSFMethod,"}")
            $$$WriteLine(tFDSFMethod,"quit tSC")
            
            do tDataClass.Methods.Insert(tGDSSMethod)
            do tDataClass.Methods.Insert(tFDSFMethod)
        }
        
        
        // create/extend %CreateFromResultSet() and %GetResultSetColumn() methods
        // default implementation for %CreateFromResultSet is independent of pDataSource presence
        set tFSQMethod = ##class(%Dictionary.MethodDefinition).%New()
        set tFSQMethod.Name = "%CreateFromResultSet"
        set tFSQMethod.FormalSpec = "pResultSet:%SQL.StatementResult,*pData:%DeepSee.PMML.Data,&pFieldMap,pDataSource:%String="""""
        set tFSQMethod.ReturnType = "%Status"
        set tFSQMethod.ClassMethod = 1
        set tFSQMethod.Internal = 1
        $$$WriteLine(tFSQMethod,"set tSC = $$$OK, pData = """"")
        $$$WriteLine(tFSQMethod,"try {")
        $$$WriteLine(tFSQMethod,$c(9)_"set pData = ..%New()")
        $$$WriteLine(tFSQMethod,$c(9)_"merge tMeta = pResultSet.%GetMetadata().columnIndex")
        $$$WriteLine(tFSQMethod,"")
        $$$WriteLine(tFSQMethod,$c(9)_"if $d(pFieldMap) {")
        set tField = "" // write mapping for all fields
        for {
            set tField = $order(%PMML("Fields", tField))
            quit:tField=""
            continue:$g(%PMML("Fields",tField,"isderived"))
            set tFieldName = %PMML("Fields",tField,"object").name
            $$$WriteLine(tFSQMethod,$c(9,9)_"if $d(pFieldMap("_$$$QUOTE(tFieldName)_"), tColName) { set pData."_tField_" = pResultSet.%Get(tColName) }")
            $$$WriteLine(tFSQMethod,$c(9,9)_"elseif $d(tMeta("_$$$QUOTE($$$UPPER(tFieldName))_"), tInfo) { set pData."_tField_" = pResultSet.%GetData($li(tInfo,1)) }")
        }
            
        if $d(tXDataSource("%DeepSee.PMML.Definition.Extension.SQLDataSource"), tMapCount) {
            
            set tGSQCMethod = ##class(%Dictionary.MethodDefinition).%New()
            set tGSQCMethod.Name = "%GetResultSetColumn"
            set tGSQCMethod.FormalSpec = "pPropertyName:%String,pDataSource:%String="""",*pImplicit:%Boolean"
            set tGSQCMethod.ReturnType = "%String"
            set tGSQCMethod.ClassMethod = 1
            set tGSQCMethod.Internal = 1
            $$$WriteLine(tGSQCMethod,"set pImplicit = 0")
            
            for i = 1:1:tMapCount {
	            set tSQLMap = tXDataSource("%DeepSee.PMML.Definition.Extension.SQLDataSource",i)
	            
	            $$$WriteLine(tFSQMethod,"")
	            if (i=1) {
		            $$$WriteLine(tFSQMethod,$c(9)_"} elseif (pDataSource="""") || (pDataSource="_$$$QUOTE(tSQLMap.name)_") {")
		            $$$WriteLine(tGSQCMethod,"if (pDataSource="""") || (pDataSource="_$$$QUOTE(tSQLMap.name)_") {")
		        } else {
		            $$$WriteLine(tFSQMethod,$c(9)_"} elseif (pDataSource="_$$$QUOTE(tSQLMap.name)_") {")
		            $$$WriteLine(tGSQCMethod,"} elseif (pDataSource="_$$$QUOTE(tSQLMap.name)_") {")
		        }
		        
		        kill tSQLFieldMap
	            for j = 1:1:tSQLMap.Fields.Count() {
	                set tField = tSQLMap.Fields.GetAt(j)
	                set tSQLFieldMap(tField.fieldName) = tField.spec
	            }
	            set tField = "" // write mapping for all fields, 
		        for {
		            set tField = $order(%PMML("Fields", tField))
		            quit:tField=""
		            continue:$g(%PMML("Fields",tField,"isderived"))
		            // default to field name if no mapping found
		            set tFieldName = %PMML("Fields", tField, "object").name
		            if $d(tSQLFieldMap(tFieldName), tColumn) {
		                $$$WriteLine(tGSQCMethod,$c(9)_"quit:($$$PROPERTYNAME(pPropertyName)="_$$$QUOTE(tField)_") "_$$$QUOTE(tColumn))
		                $$$WriteLine(tFSQMethod,$c(9,9)_"set pData."_tField_" = pResultSet.%Get("_$$$QUOTE(tColumn)_")")
		            } else {
			            $$$WriteLine(tFSQMethod,$c(9,9)_"set:$d(tMeta("_$$$QUOTE($$$UPPER(tField))_"), tColInfo) pData."_$$$PROPERTYNAME(tField)_" = pResultSet.%GetData($li(tColInfo,1))")
		            }
	            }
	            quit:$$$ISERR(tSC)
            }
            quit:$$$ISERR(tSC)
            
	        $$$WriteLine(tGSQCMethod,"}")
            $$$WriteLine(tGSQCMethod,"set pImplicit = 1")
            $$$WriteLine(tGSQCMethod,"quit pPropertyName")
            do tDataClass.Methods.Insert(tGSQCMethod)
        }
        
        // write remainder of %CreateFromResultSet()
        $$$WriteLine(tFSQMethod,$c(9)_"} else { set tSC = $$$ERROR($$$GeneralError, ""Unknown Data Source: '""_pDataSource_""'"") }")
        $$$WriteLine(tFSQMethod,"} catch (ex) {")
        $$$WriteLine(tFSQMethod,$c(9)_"set tSC = ex.AsStatus()")
        $$$WriteLine(tFSQMethod,"}")
        $$$WriteLine(tFSQMethod,"quit tSC")
        do tDataClass.Methods.Insert(tFSQMethod)
        
        
        set tSC = tDataClass.%Save()
        quit:$$$ISERR(tSC)
        set tDataClass=""
            
        // queue class to be compiled along
        do QueueClass^%occCompile(tDataClassName)
        
        // mark class for deletion when PMML definition is deleted
        $$$comClassArraySet(tDefinitionClassName,$$$cCLASSclasses,tDataClassName_".CLS","")
        $$$defClassKeySet(tDataClassName,$$$cCLASSgeneratedby,tDefinitionClassName_".CLS")
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%CreateModelClasses">
<Description><![CDATA[
Creates the <class>%DeepSee.PMML.Models.AbstractModel</class> subclass for a given PMML model,
including its input and output classes.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pModel:%DeepSee.PMML.Definition.Models.AbstractModel,&pModelName:%String="",*pModelClassName:%String,pParentModel:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #define QuoteIf(%if,%v) $s(%if:$$$QUOTE(%v), (%v=""):"""""", 1:%v)
    #define WriteLine(%m,%c) do %m.Implementation.WriteLine($c(9)_%c)
    new %PMMLModelClass
	set tSC = $$$OK
	try {
		set tDefinitionClassName = %PMML("DefinitionClass")
		
		// first resolve model name
		set:pModelName="" pModelName = $zstrip($zstrip(pModel.modelName,"*C"), "<>W")
		if (pModelName'="") {
			if $d(%PMML("Models",$$$UPPER(pModelName))) {
				set tSC = $$$ERROR($$$GeneralError, "Naming conflict for model: '"_pModel.modelName_"'")
				quit
			}
		} else {
			// generate new unique name
			set n = $piece($classname(pModel),".",*), pModelName=n, i=""
			while $d(%PMML("Models",$$$UPPER(pModelName))) {
				set pModelName = (n_$i(i))
			}
		}
		
		// BDB827
		set %PMML("CurrentModel",$i(%PMML("CurrentModel"))) = pModelName
		
		// now create unique classname
		set n = tDefinitionClassName_"."_$tr($zstrip($tr(pModelName,".",$c(0)),"*PW"),$c(0),"."), pModelClassName=n, i=""
		while $d(%PMML("Classes",$$$UPPER(pModelClassName))) {
			set pModelClassName = (n_$i(i))
		}
		
		set %PMML("Models",$$$UPPER(pModelName)) = pModelClassName
		set:pParentModel'="" %PMML("Models",$$$UPPER(pModelName),"parent") = pParentModel
		
		set %PMML("Classes",$$$UPPER(pModelClassName)) = pModelName
		set %PMML("Classes", $$$UPPER(pModelClassName), "type") = $piece(pModel.%GetModelClass(),".",*)
		
		// BDB731
		set %PMMLModelClass = pModelClassName
		set %PMML("Classes",$$$UPPER(pModelClassName),"simple") = +$parameter(pModel.%GetModelClass() ,"SUPPORTSSIMPLEMODE")
		
        if $$$defClassDefined(pModelClassName) {
            set tSC = $$Delete^%apiOBJ(pModelClassName,"-d")
            quit:$$$ISERR(tSC)
        }
        
        set tSC = ..%CreateModelInputClass(pModelClassName, pModel, .tModelInputClassName, .tPredictedFields)
        quit:$$$ISERR(tSC)
        set tSC = ..%CreateModelOutputClass(pModelClassName, pModel, .tModelOutputClassName, .tPredictedFields)
        quit:$$$ISERR(tSC)
        
        set %PMML("Classes",$$$UPPER(pModelClassName),"input") = tModelInputClassName
        set %PMML("Classes",$$$UPPER(pModelClassName),"output") = tModelOutputClassName
        
        
        // 3.3:  create model class
        set tModelClass = ##class(%Dictionary.ClassDefinition).%New()
        set tModelClassSuper = pModel.%GetModelClass() 
        set tModelClass.Name = pModelClassName
        set tModelClass.Super = tModelClassSuper // can be overwritten later on
        set tModelClass.ProcedureBlock = 1
        set tModelClass.Final = 1
        set tModelClass.GeneratedBy = tDefinitionClassName
        
        do AddParameter(tModelClass, "MODELNAME", pModel.modelName)
        do AddParameter(tModelClass, "DATACLASS", %PMML("Models","DATA"))
        do AddParameter(tModelClass, "INPUTCLASS", tModelInputClassName)
        do AddParameter(tModelClass, "OUTPUTCLASS", tModelOutputClassName)
        do AddParameter(tModelClass, "DEFINITIONCLASS", tDefinitionClassName)
        
        set tPredictedField = $classmethod(tModelClassSuper, "%GetPredictedFieldFromDef", pModel)
        // BDB827: inherit target field if not specified in submodel
        if (tPredictedField="") && (pParentModel'="") {
	        set tParentModelClassName = %PMML("Models",$$$UPPER(pParentModel))
	        set tPredictedField = $g(%PMML("Classes",$$$UPPER(tParentModelClassName),"targetFields"))
        }
        if (tPredictedField="") {
            set tSC = $$$ERROR($$$GeneralError, "Model has no predicted field")
            quit
        }
        do AddParameter(tModelClass, "PREDICTEDFIELD", tPredictedField)
        set %PMML("Classes",$$$UPPER(pModelClassName),"targetFields") = tPredictedField
        
        
        // BDB823: disable tracing
        if $g(%PMML("DisableTracing")) {
	    	set tTSet = ##class(%Dictionary.MethodDefinition).%New()
	    	set tTSet.Name = "TracingSet"
	    	set tTSet.FormalSpec = "pValue:%Boolean"
	    	set tTSet.Internal = 1
	    	set tTSet.ServerOnly = 1
	    	set tTSet.ReturnType = "%Status"
	    	do tTSet.Implementation.WriteLine("	quit $$$ERROR($$$GeneralError, ""Tracing has been disabled for this PMML definition"")")
	    	set tTSet.parent = tModelClass
        }
        
        set tGPFInfo = ##class(%Dictionary.MethodDefinition).%New()
        set tGPFInfo.Name = "%GetPredictedFieldInfo"
        set tGPFInfo.FormalSpec = "*pFieldName:%String,*pDataType:%String,*pOpType:%String"
        set tGPFInfo.ReturnType = "%Status"
        set tGPFInfo.ClassMethod = 1
        set tPFInfo = $get(tPredictedFields(tPredictedField))
        $$$WriteLine(tGPFInfo,"set pFieldName = "_$$$QUOTE($li(tPFInfo,2))_", pDataType = "_$$$QUOTE($li(tPFInfo,3))_", pOpType = "_$$$QUOTE($li(tPFInfo,4)))
        $$$WriteLine(tGPFInfo,"quit $$$OK")
        do tModelClass.Methods.Insert(tGPFInfo)
        
        // now forward to %DeepSee.PMML.Models.* class
        set tSC = $classmethod(tModelClassSuper, "%CreateModelClass", tModelClass, pModel)
        quit:$$$ISERR(tSC)
        
        // BDB823 - only add after generating model implementation 
        do AddParameter(tModelClass, "SUPPORTSSIMPLEMODE", %PMML("Classes",$$$UPPER(pModelClassName),"simple"), 1)
        
        // add SQL stored procedure
        set tSQLMethod = ##class(%Dictionary.MethodDefinition).%New()
        set tSQLMethod.Name = "%ExecuteSQL"
        set tSQLMethod.SqlName = $p(pModelClassName,".",*)
        set tSQLMethod.SqlProc = 1
        set tSQLMethod.ClassMethod = 1
        set tSQLMethod.SequenceNumber = 1
        set tSQLMethod.Description = "<p>SQL procedure to execute the predictive model named '"_pModelName_"' defined in <class>"_$piece(tDefinitionClassName,".",1,*-1)_"</class></p>"
        set tSQLMethod.Description = tSQLMethod.Description_$c(13,10)_"<p>This method has the following input parameters:</p>"_$c(13,10)_"<ol>"
        
        // build formal spec
        kill tInputFields
        for i = 1:1:pModel.MiningSchema.MiningFields.Count() {
	        #dim tMiningField As %DeepSee.PMML.Definition.MiningField = pModel.MiningSchema.MiningFields.GetAt(i)
	        
	        continue:$$$PMMLusageTypeIsTarget(tMiningField.usageType)
            set tPropName = $$$PROPERTYNAME(tMiningField.name)
	        
            // if this is a derived field, identify any input fields used indirectly
	        if $g(%PMML("Fields",tPropName,"isderived")) {
		    	if $d(%PMML("Fields", tPropName, "object"), tDerivedField) {
	            	set tSC = tDerivedField.Expression.%GetInputFields(.tInputFields)
                	quit:$$$ISERR(tSC)
	            }
            } else {
	            set tInputFields(tMiningField.name) = ""
            }
        }
        set tField="", tFormalSpec="", c=0
        for {
	    	set tField = $order(tInputFields(tField))
	    	quit:tField=""
	    	set tPropName = $$$PROPERTYNAME(tField)
	    	continue:$g(%PMML("Fields",tPropName,"isderived"))
	    	continue:'$d(%PMML("Fields",tPropName, "object"), tPropObj)
	    	set tArgName = "p"_tPropName, tArgNames($$$UPPER(tArgName))=""
	    	set tArgType = ##class(%DeepSee.PMML.Datatype.DataType).GetClassname(tPropObj.dataType)
	    	set tFormalSpec = tFormalSpec _ $s(tFormalSpec="":"", 1:",") _ tArgName_":"_tArgType
	    	do tSQLMethod.Implementation.WriteLine("	set tInput("_$$$QUOTE(tField)_") = $g("_tArgName_")")
	    	set tSQLMethod.Description = tSQLMethod.Description_$c(13,10,9)_"<li><var>"_tArgName_"</var> ("_tArgType_") for DataField '"_tField_"'</li>"
	    	
	        // quit if reaching max # of args
	        if $i(c)>100 {
		        set tSQLMethod.Description = tSQLMethod.Description_$c(13,10)_"<p>WARNING: this method only supports the first 100 mining fields as method arguments</p>"
		        quit
	        }
        }
        do tSQLMethod.Implementation.WriteLine("	set tSC = ..%New().%ExecuteModel(.tInput, .tOutput)")
        set tSQLMethod.Description = tSQLMethod.Description_$c(13,10)_"</ol>"
        
        // use the main predicted field as a return type
        set tPredictedField = $classmethod(pModel.%GetModelClass(), "%GetPredictedFieldFromDef", pModel)
        set tSQLMethod.ReturnType = $lg(tPredictedFields(tPredictedField),1)
        
        // if we have multiple output fields, return them as output params
        if $isobject(pModel.Output) && (pModel.Output.OutputFields.Count()>1) {
	        set tSQLMethod.Description = tSQLMethod.Description_$c(13,10)_"<p>In addition, it has the following output parameters:</p>"_$c(13,10)_"<ul>"
	        for i = 1:1:pModel.Output.OutputFields.Count() {
		        set tOutputField = pModel.Output.OutputFields.GetAt(i)
		        set tPropName = $$$PROPERTYNAME(tOutputField.name)
		        set tArgName = "p"_tPropName, n=0
		        while $d(tArgNames($$$UPPER(tArgName))) { set tArgName = "p"_tPropName_$i(n) }
		        set tArgNames($$$UPPER(tArgName)) = ""
		        if (tOutputField.feature = "predictedValue") {
			        set tArgType = tSQLMethod.ReturnType, tPredictedField = tOutputField.name
		        } elseif (tOutputField.feature = "probability") {
			        set tArgType = "%DeepSee.PMML.Datatype.ProbNumber"
		        } elseif (tOutputField.dataType'="") {
			        set tArgType = ##class(%DeepSee.PMML.Datatype.DataType).GetClassname(tOutputField.dataType)
		        } else {
			        set tArgType = ""
		        }
		        set tFormalSpec = tFormalSpec _ ",*" _ tArgName_$s(tArgType="":"", 1:":"_tArgType)
		        do tSQLMethod.Implementation.WriteLine("	set "_tArgName_" = tOutput."_tPropName)
		        set tSQLMethod.Description = tSQLMethod.Description_$c(13,10,9)_"<li><var>"_tArgName_"</var>"_$s(tArgType="":"",1:" ("_tArgType_")")_" for OutputField '"_tOutputField.name_"'</li>"
	        }
	        set tSQLMethod.Description = tSQLMethod.Description_$c(13,10)_"</ul>"
        }
        set tSQLMethod.FormalSpec = tFormalSpec
        
        do tSQLMethod.Implementation.WriteLine("	quit $s('$isobject(tOutput):"""", 1:tOutput."_$$$PROPERTYNAME(tPredictedField)_")")
        do tModelClass.Methods.Insert(tSQLMethod)
        
        
        
    
        set tSC = tModelClass.%Save()
        quit:$$$ISERR(tSC)
        set tModelClass=""
        
        // queue classes to be compiled along
        do QueueClass^%occCompile(pModelClassName)
        
        // mark class for deletion when PMML definition is deleted
        $$$comClassArraySet(tDefinitionClassName,$$$cCLASSclasses,pModelClassName_".CLS","")
        $$$defClassKeySet(pModelClassName,$$$cCLASSgeneratedby,tDefinitionClassName_".CLS")
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	
	if $g(%PMML("CurrentModel")) {
		kill %PMML("CurrentModel",%PMML("CurrentModel"))
		set %PMML("CurrentModel") = %PMML("CurrentModel")-1
	}
	
	quit tSC
	
AddParameter(pClass, pName, pValue, pInternal=0) 
    set tParam = ##class(%Dictionary.ParameterDefinition).%New()
    set tParam.Name = pName
    set tParam.Default = pValue
    set tParam.Internal = pInternal
    do pClass.Parameters.Insert(tParam)
    set tParam=""
]]></Implementation>
</Method>

<Method name="%CreateModelInputClass">
<ClassMethod>1</ClassMethod>
<FormalSpec>pModelClassName:%String,pModel:%DeepSee.PMML.Definition.Models.AbstractModel,*pModelInputClassName:%String,*pPredictedFields</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #define QuoteIf(%if,%v) $s(%if:$$$QUOTE(%v), (%v=""):"""""", 1:%v)
    #define WriteLine(%m,%c) do %m.Implementation.WriteLine($c(9)_%c)
	set tSC = $$$OK
	try {
		set tDefinitionClassName = %PMML("DefinitionClass")
		
		// find unique name for this input class
		set n = pModelClassName_"Input", pModelInputClassName=n, i=""
		while $d(%PMML("Classes",$$$UPPER(pModelInputClassName))) {
			set pModelInputClassName = (n_$i(i))
		}
		set %PMML("Classes",$$$UPPER(pModelInputClassName)) = "INPUT"
		
        if $$$defClassDefined(pModelInputClassName) {
            set tSC = $$Delete^%apiOBJ(pModelInputClassName,"-d")
            quit:$$$ISERR(tSC)
        }
        
        set tModelInputClass = ##class(%Dictionary.ClassDefinition).%New()
        set tModelInputClass.Name = pModelInputClassName
        set tModelInputClass.Super = "%DeepSee.PMML.ModelInput"
        set tModelInputClass.ProcedureBlock = 1
        set tModelInputClass.GeneratedBy = tDefinitionClassName
        
        set tDataClassName = %PMML("Models","DATA")
	    set tParam = ##class(%Dictionary.ParameterDefinition).%New()
	    set tParam.Name = "DATACLASS"
	    set tParam.Default = tDataClassName
	    do tModelInputClass.Parameters.Insert(tParam)
	    set tParam = ##class(%Dictionary.ParameterDefinition).%New()
	    set tParam.Name = "MODELNAME"
	    set tParam.Default = %PMML("Classes",$$$UPPER(pModelClassName))
	    do tModelInputClass.Parameters.Insert(tParam)
	    set tParam = ##class(%Dictionary.ParameterDefinition).%New()
	    set tParam.Name = "MODELCLASS"
	    set tParam.Default = pModelClassName
	    do tModelInputClass.Parameters.Insert(tParam)
        
        set tGetFields = ##class(%Dictionary.MethodDefinition).%New()
        set tGetFields.Name = "%GetFields"
        set tGetFields.FormalSpec = "*pArray"
        set tGetFields.ReturnType = "%Status"
        set tGetFields.ClassMethod = 1
        set m("%GetFields") = tGetFields
        
        // %LoadData() method loads values from array
        set tLDMethod = ##class(%Dictionary.MethodDefinition).%New()
        set tLDMethod.Name = "%LoadData"
        set tLDMethod.ReturnType = "%Status"
        set tLDMethod.FormalSpec = "&pArray"
        set tLDMethod.Internal = 1
        $$$WriteLine(tLDMethod,"set tSC = $$$OK")
        $$$WriteLine(tLDMethod,"try {")
        set m("%LoadData") = tLDMethod
        
        // %GetAsArray() method simply translates values into array
        set tGAMethod = ##class(%Dictionary.MethodDefinition).%New()
        set tGAMethod.Name = "%GetAsArray"
        set tGAMethod.ReturnType = "%Status"
        set tGAMethod.FormalSpec = "*pArray,*pStatus,pSkipMissing:%Boolean=1"
        set tGAMethod.Internal = 1
        $$$WriteLine(tGAMethod,"set tSC = $$$OK")
        $$$WriteLine(tGAMethod,"try {")
        set m("%GetAsArray") = tGAMethod
        
        // %LoadObject() method loads values from object
        set tLOMethod = ##class(%Dictionary.MethodDefinition).%New()
        set tLOMethod.Name = "%LoadObject"
        set tLOMethod.ReturnType = "%Status"
        set tLOMethod.FormalSpec = "pObject"
        set tLOMethod.Internal = 1
        $$$WriteLine(tLOMethod,"set tSC = $$$OK")
        $$$WriteLine(tLOMethod,"try {")
        $$$WriteLine(tLOMethod,"	set tClassDef = ##class(%Dictionary.ClassDefinition).%OpenId($classname(pObject))")
        $$$WriteLine(tLOMethod,"	for i = 1:1:tClassDef.Properties.Count() {")
        $$$WriteLine(tLOMethod,"		set tPropDef = tClassDef.Properties.GetAt(i)")
        $$$WriteLine(tLOMethod,"		continue:tPropDef.Private")
        $$$WriteLine(tLOMethod,"		continue:$e(tPropDef.Name)=""%""")
        $$$WriteLine(tLOMethod,"		set tPropNames(tPropDef.Name) = """"")
        $$$WriteLine(tLOMethod,"	}")
        set m("%LoadObject") = tLOMethod
        
        // %OnOpen() method ensures property status is set upon deserialize
        set tOOMethod = ##class(%Dictionary.MethodDefinition).%New()
        set tOOMethod.Name = "%OnOpen"
        set tOOMethod.ReturnType = "%Status"
        set tOOMethod.Private = 1
        set tOOMethod.ServerOnly = 1
        set m("%OnOpen") = tOOMethod
        
        set tRDFMethod = ##class(%Dictionary.MethodDefinition).%New()
        set tRDFMethod.Name = "%ResetDerivedFields"
        set tRDFMethod.ReturnType = "%Status"
        set tRDFMethod.Internal = 1
        set m("%ResetDerivedFields") = tRDFMethod
        
        set tGDFMethod = ##class(%Dictionary.MethodDefinition).%New()
        set tGDFMethod.Name = "%GetDerivedFields"
        set tGDFMethod.ReturnType = "%Status"
        set tGDFMethod.FormalSpec = "&pArray"
        set tGDFMethod.Internal = 1
        set m("%GetDerivedFields") = tGDFMethod
        
        for j = 1:1:pModel.MiningSchema.MiningFields.Count() {
            #dim tMiningField As %DeepSee.PMML.Definition.MiningField = pModel.MiningSchema.MiningFields.GetAt(j)
            
            set tPropName = $$$PROPERTYNAME(tMiningField.name)
            if $$$PMMLusageTypeIsTarget(tMiningField.usageType) {
            	set tOpType = $s(tMiningField.optype'="":tMiningField.optype, 1:%PMML("Fields",tPropName,"optype"))
                set pPredictedFields(tMiningField.name) = $lb(%PMML("Fields",tPropName,"type"), tMiningField.name, %PMML("Fields",tPropName,"datatype"), tOpType)
                continue
            }
            
            // if this is a derived field, identify any input fields used indirectly
            if $g(%PMML("Fields",tPropName,"isderived")) && $d(%PMML("Fields", tPropName, "object"), tDerivedField) {
	            set tSC = tDerivedField.Expression.%GetInputFields(.tInputFields)
                quit:$$$ISERR(tSC)
            }
            
            // BDB731 - if this is a complex field (derived or with missing/invalid value specs),
            // simple mode is not supported
            set:$g(%PMML("Fields",tPropName,"complex")) %PMML("Classes",$$$UPPER(pModelClassName),"simple") = 0
            
            set tSC = ..%AddModelInputField(tMiningField, pModelClassName, tModelInputClass, .m)
            quit:$$$ISERR(tSC)
        }
        quit:$$$ISERR(tSC)
        
        if $isobject(pModel.LocalTransformations) && pModel.LocalTransformations.DerivedFields.Count() {
           
            // BDB731 - no simple mode when derived fields are used
            set %PMML("Classes",$$$UPPER(pModelClassName),"simple") = 0
                
            for j = 1:1:pModel.LocalTransformations.DerivedFields.Count() {
                set tDerivedField = pModel.LocalTransformations.DerivedFields.GetAt(j)
                
                set tPropName = $$$PROPERTYNAME(tDerivedField.name)
                if $d(%PMML("PropNamesI", $$$UPPER(tPropName)), tConflict) || $d(tDerivedFieldNames($$$UPPER(tPropName)), tConflict) {
	                set tSC = $$$ERROR($$$GeneralError, "Name conflict for derived field '"_tDerivedField.name_"' with prior field '"_tConflict_"'")
	                quit
                }
                set tDerivedFieldNames($$$UPPER(tPropName)) = tDerivedField.name
                
                set tPropType = ##class(%DeepSee.PMML.Datatype.DataType).GetClassname(tDerivedField.dataType)
                
                set tProp = ##class(%Dictionary.PropertyDefinition).%New()
                set tProp.Name = tPropName
                set tProp.Type = tPropType
                set tDisplayName = $s(tDerivedField.displayName'="":tDerivedField.displayName, 1:tDerivedField.name)
                set tProp.Description = "Property for derived field: """_tDisplayName_""""_$c(13,10)_"   name="""_tDerivedField.name_""""_$c(13,10)_"   optype="""_tDerivedField.optype_""""_$c(13,10)_"   dataType="""_tDerivedField.dataType_""""
                //set tProp.Calculated = 1
                set tProp.ReadOnly = 1
                do tModelInputClass.Properties.Insert(tProp)
            	set %PMML("Classes",$$$UPPER(pModelClassName),"input", tPropName) = ""
                
                set tGetter = ##class(%Dictionary.MethodDefinition).%New()
                set tGetter.Name = tPropName_"Get"
                set tGetter.Internal = 1
                set tGetter.ServerOnly = 1
                set tGetter.ReturnType = tPropType
                set tGetter.Description = "Getter method to retrieve the value of the "_tDerivedField.name_" property."_$c(13,10)_"Implementation based on the EXPRESSION element within &lt;DerivedField&gt;."
                
                set tInline = 1
                set tDerivedFieldCode = tDerivedField.Expression.%GetComputeCode(.tInline)
                
                $$$WriteLine(tGetter,"quit:$d(..%Properties("""_tPropName_""")) i%"_tPropName)
                if tInline {
                    $$$WriteLine(tGetter,"set tValue = "_tDerivedFieldCode)
                } else {
                    do tGetter.Implementation.WriteLine(tDerivedFieldCode)
                }
                $$$WriteLine(tGetter,"set i%"_tPropName_" = tValue")
                $$$WriteLine(tGetter,"do:'$d(..%Properties("""_tPropName_""")) ..%SetPropertyStatus("""_tPropName_""", $g(tStatus,""valid""))")
                $$$WriteLine(tGetter,"quit tValue")
                
                do tModelInputClass.Methods.Insert(tGetter)
                
                $$$WriteLine(tGetFields,"set pArray("_$$$QUOTE(tPropName)_") = $lb(""derived"", "_$$$QUOTE(tDisplayName)_")")
                
                $$$WriteLine(tRDFMethod,"kill i%"_tPropName_", i%%Properties("_$$$QUOTE(tPropName)_")")
                $$$WriteLine(tGDFMethod,"set pArray("_$$$QUOTE(tMiningField.name)_") = .."_tPropName)
                $$$WriteLine(tGAMethod,"	set:'pSkipMissing||'..%IsMissing("_$$$QUOTE(tDerivedField.name)_") pArray("_$$$QUOTE(tDerivedField.name)_") = .."_tPropName_", pStatus("_$$$QUOTE(tDerivedField.name)_") = ..%GetPropertyStatus("_$$$QUOTE(tPropName)_")")
                
                
               	// identify any input fields used by this DerivedField indirectly
               	set tSC = tDerivedField.Expression.%GetInputFields(.tInputFields)
               	quit:$$$ISERR(tSC)
            }
        }
        
        // BDB827
        if ('$d(pPredictedFields)) && $d(%PMML("Models",$$$UPPER(%PMML("Classes",$$$UPPER(pModelClassName))),"parent"),tParentModelName) {
	        set tParentModelClassName = %PMML("Models",$$$UPPER(tParentModelName))
	        merge pPredictedFields = %PMML("Classes",$$$UPPER(tParentModelClassName),"targetFields")
        }
        merge %PMML("Classes",$$$UPPER(pModelClassName),"targetFields") = pPredictedFields
        
        set tInputFieldName = ""
        for {
	        set tInputFieldName = $order(tInputFields(tInputFieldName))
	        quit:tInputFieldName=""
	        
	        set tPropName = $$$PROPERTYNAME(tInputFieldName)
	        continue:$d(%PMML("Classes",$$$UPPER(pModelClassName),"input",tPropName))
	        
	        set tSC = ..%AddModelInputField(tInputFieldName, pModelClassName, tModelInputClass, .m)
	        quit:$$$ISERR(tSC)
        }
        
        $$$WriteLine(tGAMethod,"} catch (ex) {")
        $$$WriteLine(tGAMethod,$c(9)_"set tSC = ex.AsStatus()")
        $$$WriteLine(tGAMethod,"}")
        $$$WriteLine(tGAMethod,"quit tSC")
        do tModelInputClass.Methods.Insert(tGAMethod)
        
        $$$WriteLine(tLDMethod,"} catch (ex) {")
        $$$WriteLine(tLDMethod,$c(9)_"set tSC = ex.AsStatus()")
        $$$WriteLine(tLDMethod,"}")
        $$$WriteLine(tLDMethod,"quit tSC")
        do tModelInputClass.Methods.Insert(tLDMethod)
        
        $$$WriteLine(tLOMethod,"} catch (ex) {")
        $$$WriteLine(tLOMethod,$c(9)_"set tSC = ex.AsStatus()")
        $$$WriteLine(tLOMethod,"}")
        $$$WriteLine(tLOMethod,"quit tSC")
        do tModelInputClass.Methods.Insert(tLOMethod)
        
        $$$WriteLine(tRDFMethod,"quit $$$OK")
        do tModelInputClass.Methods.Insert(tRDFMethod)
        $$$WriteLine(tGDFMethod,"quit $$$OK")
        do tModelInputClass.Methods.Insert(tGDFMethod)
        $$$WriteLine(tGetFields,"quit $$$OK")
        do tModelInputClass.Methods.Insert(tGetFields)
        $$$WriteLine(tOOMethod,"quit $$$OK")
        do tModelInputClass.Methods.Insert(tOOMethod)
        
        set tSC = tModelInputClass.%Save()
        quit:$$$ISERR(tSC)
		
        do QueueClass^%occCompile(pModelInputClassName)
        
        $$$comClassArraySet(tDefinitionClassName,$$$cCLASSclasses,pModelInputClassName_".CLS","")
        $$$defClassKeySet(pModelInputClassName,$$$cCLASSgeneratedby,tDefinitionClassName_".CLS")
        
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%AddModelInputField">
<Description>
Adds a DataField or DerivedField from the main PMML definition to this ModelInput</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pField,pModelClassName:%String,pClassDef:%Dictionary.ClassDefinition,&pMethods]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #define QuoteIf(%if,%v) $s(%if:$$$QUOTE(%v), (%v=""):"""""", 1:%v)
    #define WriteLine(%m,%c) do %m.Implementation.WriteLine($c(9)_%c)
    
	set tSC = $$$OK
	try {
		
		set tFieldName = $s($isobject(pField):pField.name, 1:pField)
        set tPropName = $$$PROPERTYNAME(tFieldName)
        set tDataType = %PMML("Fields",tPropName,"datatype")
        set tPropType = %PMML("Fields",tPropName,"type")
        set tOpType = $s($isobject(pField)&&(pField.optype'=""):pField.optype, 1:%PMML("Fields",tPropName,"optype"))
        set tQuote = (tPropType="string")||(tPropType="")
        
        set tIsDerived = +$g(%PMML("Fields",tPropName,"isderived"))
        
        set tProp = ##class(%Dictionary.PropertyDefinition).%New()
        set tProp.Name = tPropName
        set tProp.Type = tPropType
        set tProp.ReadOnly = tIsDerived
        set tProp.Description = "Property for field: """_tFieldName_""""
        set:$isobject(pField) tProp.Description = tProp.Description_$c(13,10)_"   usageType="""_pField.usageType_""""_$c(13,10)_"   optype="""_pField.optype_""""
        do pClassDef.Properties.Insert(tProp)
        set %PMML("Classes",$$$UPPER(pModelClassName),"input", tPropName) = ""
        
        $$$WriteLine(pMethods("%GetFields"),"set pArray("_$$$QUOTE(tFieldName)_") = $lb("_$$$QUOTE($s($isobject(pField):pField.usageType, 1:""))_","_$$$QUOTE($g(%PMML("Fields",tPropName,"displayname")))_")")
        
        if ('tIsDerived) {
            
            // provide setter method including default DataField validation AND MiningField validation code
            set tSetter = ##class(%Dictionary.MethodDefinition).%New()
            set tSetter.Name = tPropName_"Set"
            set tSetter.Internal = 1
            set tSetter.ServerOnly = 1
            set tSetter.ReturnType = "%Status"
            set tSetter.FormalSpec = "pValue:"_tPropType
            set tSetter.Description = "Setter method to populate the "_tFieldName_" property."_$c(13,10)_"Verifies the supplied value according to &lt;DataField&gt; specifications"
            
            // default setter code
            if $d(%PMML("Fields", tPropName, "object"), tDataField) {
	            set tSC = ..%GenerateSetterCode(tSetter, tDataField)
            	quit:$$$ISERR(tSC)
            } else {
	            $$$WriteLine(tSetter,"set tStatus = $s($g(pValue)="""":""missing"", 1:""valid"")")
            }
        
        	// MiningField input treatment
            if $isobject(pField) {
	            // invalid value treatment
	            if (pField.invalidValueTreatment="asMissing") {
	                $$$WriteLine(tSetter,"set:tStatus=""invalid"" tStatus = ""missing""")
	            } elseif (pField.invalidValueTreatment="returnInvalid") {
	                $$$WriteLine(tSetter,"if (tStatus=""invalid"") { $$$ThrowStatus($$$ERROR($$$GeneralError, ""Invalid value for field '"_pField.name_"': '""_pValue_""'"")) }")
	            }
	            
	            // outlier treatment
	            if (pField.outliers'="asIs") {
	                if (pField.lowValue'="") {
	                    $$$WriteLine(tSetter,"set:pValue<"_pField.lowValue_" "_$s(pField.outliers="asMissing":"tStatus = ""missing""", 1:"pValue = "_pField.lowValue))
	                }
	                if (pField.highValue'="") {
	                    $$$WriteLine(tSetter,"set:pValue>"_pField.highValue_" "_$s(pField.outliers="asMissing":"tStatus = ""missing""", 1:"pValue = "_pField.highValue))
	                }
	            }
	            
	            // missing value treatment
	            if (pField.missingValueReplacement'="") {
	                $$$WriteLine(tSetter,"set:tStatus=""missing"" pValue = "_$$$QuoteIf(tQuote,pField.missingValueReplacement)_", tStatus = ""valid""")
	                
	                // BDB731 - save replacement for simple mode
	                set %PMML("Classes",$$$UPPER(pModelClassName),"input",tPropName,"missingRep") = pField.missingValueReplacement
	            }
            }
            
           	if (tDataType="boolean") { // BDB505: boolean value rewriting
	            $$$WriteLine(tSetter,"set i%"_tPropName_" = $case($$$LOWER(pValue), ""false"":0, ""true"":1, :pValue)")
            } else {
	            $$$WriteLine(tSetter,"set i%"_tPropName_" = pValue")
            }
            $$$WriteLine(tSetter,"do ..%ResetDerivedFields()")
            $$$WriteLine(tSetter,"quit ..%SetPropertyStatus("_$$$QUOTE(tPropName)_",tStatus)")
            do pClassDef.Methods.Insert(tSetter)
            
        	$$$WriteLine(pMethods("%LoadData"),"	set:$d(pArray("_$$$QUOTE(tFieldName)_"),tValue) .."_tPropName_" = tValue")
        	$$$WriteLine(pMethods("%LoadObject"),"	set:$d(tPropNames("_$$$QUOTE(tPropName)_")) .."_tPropName_" = pObject."_tPropName)
        
        } else {
            
            // build getter method, including DerivedField code AND MiningField validation
            set tGetter = ##class(%Dictionary.MethodDefinition).%New()
            set tGetter.Name = tPropName_"Get"
            set tGetter.Internal = 1
            set tGetter.ServerOnly = 1
            set tGetter.ReturnType = tPropType
            set tGetter.Description = "Getter method to retrieve the "_tFieldName_" property."_$c(13,10)_"Verifies the supplied value according to &lt;DataField&gt; specifications"
            
            // default getter code
            if $d(%PMML("Fields", tPropName, "object"), tDerivedField) {
                set tInline = 1
	            set tDerivedFieldCode = tDerivedField.Expression.%GetComputeCode(.tInline)
            
   	        	$$$WriteLine(tGetter,"quit:$d(..%Properties("""_tPropName_""")) i%"_tPropName)
                if tInline {
                    $$$WriteLine(tGetter,"set tValue = "_tDerivedFieldCode_", tStatus = ""valid""")
                } else {
                    do tGetter.Implementation.WriteLine(tDerivedFieldCode)
                }
            }
        
        	// MiningField treatments
        	if $isobject(pField) {
	            // invalid value treatment
	            if (pField.invalidValueTreatment="asMissing") {
	                $$$WriteLine(tGetter,"set:tStatus=""invalid"" tStatus = ""missing""")
	            } elseif (pField.invalidValueTreatment="returnInvalid") {
	                $$$WriteLine(tGetter,"throw:tStatus=""invalid"" ##class(%Exception.StatusException).CreateFromStatus($$$ERROR($$$GeneralError, ""Invalid value for field '"_pField.name_"': '""_tValue_""'""))")
	            }
	            
	            // outlier treatment
	            if (pField.outliers'="asIs") {
	                if (pField.lowValue'="") {
	                    $$$WriteLine(tGetter,"set:tValue<"_pField.lowValue_" "_$s(pField.outliers="asMissing":"tStatus = ""missing""", 1:"tValue = "_pField.lowValue))
	                }
	                if (pField.highValue'="") {
	                    $$$WriteLine(tGetter,"set:tValue>"_pField.highValue_" "_$s(pField.outliers="asMissing":"tStatus = ""missing""", 1:"tValue = "_pField.highValue))
	                }
	            }
	            
	            // missing value treatment
	            if (pField.missingValueReplacement'="") {
	                $$$WriteLine(tGetter,"set:tStatus=""missing"" tValue = "_$$$QuoteIf(tQuote,pField.missingValueReplacement)_", tStatus = ""valid""")
	            }
        	}
            
            $$$WriteLine(tGetter,"set i%"_tPropName_" = tValue")
            $$$WriteLine(tGetter,"do ..%SetPropertyStatus("""_tPropName_""", $g(tStatus,""valid""))")
            $$$WriteLine(tGetter,"quit tValue")
            do pClassDef.Methods.Insert(tGetter)
            
            $$$WriteLine(pMethods("%ResetDerivedFields"),"kill i%"_tPropName_", i%%Properties("_$$$QUOTE(tPropName)_")")
            $$$WriteLine(pMethods("%GetDerivedFields"),"set pArray("_$$$QUOTE(tFieldName)_") = .."_tPropName)
            $$$WriteLine(pMethods("%OnOpen"),"set .."_tPropName_" = i%"_tPropName)
        }
            
        $$$WriteLine(pMethods("%GetAsArray"),"	set:'pSkipMissing||'..%IsMissing("_$$$QUOTE(tFieldName)_") pArray("_$$$QUOTE(tFieldName)_") = .."_tPropName_", pStatus("_$$$QUOTE(tFieldName)_") = ..%GetPropertyStatus("_$$$QUOTE(tPropName)_")")
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%AppendModelInputField">
<Description>
Appends additional input fields to an existing ModelInput class, i.e. from modelChain composites</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pModelClass:%Dictionary.ClassDefinition,pModelInputClass:%Dictionary.ClassDefinition,pFieldName:%String,pDataType:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #define WriteLine(%m,%c) do %m.Implementation.WriteLine($c(9)_%c)
    
	set tSC = $$$OK
	try {
		set tPropName = $$$PROPERTYNAME(pFieldName)
		set tDataProp = ##class(%Dictionary.PropertyDefinition).%New()
		set tDataProp.Name = tPropName
		set tDataProp.Type = ##class(%DeepSee.PMML.Datatype.DataType).GetClassname(pDataType)
		set tDataProp.Internal = 1
		do pModelInputClass.Properties.Insert(tDataProp)
		set tDataPropSetter = ##class(%Dictionary.MethodDefinition).%New()
		set tDataPropSetter.Name = tPropName_"Set"
		set tDataPropSetter.Internal = 1
		set tDataPropSetter.ServerOnly = 1
		set tDataPropSetter.FormalSpec = "pValue:"_tDataProp.Type
		set tDataPropSetter.ReturnType = "%Status"
		$$$WriteLine(tDataPropSetter,"set i%"_tPropName_" = pValue, tStatus = ""valid""")
        $$$WriteLine(tDataPropSetter,"quit ..%SetPropertyStatus("_$$$QUOTE(tPropName)_",tStatus)")
		do pModelInputClass.Methods.Insert(tDataPropSetter)
		set %PMML("Classes",pModelClass.Name,"input",tPropName) = ""
		
		// BDB783 - also add to %GetAsArray() method
		do AppendBeforeCatch("%GetAsArray","set:'pSkipMissing||'..%IsMissing("_$$$QUOTE(pFieldName)_") pArray("_$$$QUOTE(pFieldName)_") = .."_tPropName_", pStatus("_$$$QUOTE(pFieldName)_") = ..%GetPropertyStatus("_$$$QUOTE(tPropName)_")")
        do AppendBeforeCatch("%LoadData","set:$d(pArray("_$$$QUOTE(pFieldName)_"),tValue) .."_tPropName_" = tValue")
        do AppendBeforeCatch("%LoadObject","set:$d(tPropNames("_$$$QUOTE(tPropName)_")) .."_tPropName_" = pObject."_tPropName)

	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
	
AppendBeforeCatch(tMethodName, tCode)
	for i = 1:1:pModelInputClass.Methods.Count() {
		set tMethod = pModelInputClass.Methods.GetAt(i)
		continue:tMethod.Name'=tMethodName
		
		set tOldImplementation = tMethod.Implementation
		set tNewImplementation = ##class(%Stream.TmpCharacter).%New()
		do tOldImplementation.Rewind()
		while 'tOldImplementation.AtEnd {
			set tLine = tOldImplementation.ReadLine()
			if tLine [ "} catch (" {
				do tNewImplementation.WriteLine($c(9,9)_tCode)
			}
			do tNewImplementation.WriteLine(tLine)
			set tMethod.Implementation = tNewImplementation
		}
		quit
	}
]]></Implementation>
</Method>

<Method name="%CreateModelOutputClass">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pModelClassName:%String,pModel:%DeepSee.PMML.Definition.Models.AbstractModel,*pModelOutputClassName:%String,&pPredictedFields]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #define QuoteIf(%if,%v) $s(%if:$$$QUOTE(%v), (%v=""):"""""", 1:%v)
    #define WriteLine(%m,%c) do %m.Implementation.WriteLine($c(9)_%c)
	set tSC = $$$OK
	try {
		set tDefinitionClassName = %PMML("DefinitionClass")
		
		// find unique name for this input class
		set n = pModelClassName_"Output", pModelOutputClassName=n, i=""
		while $d(%PMML("Classes",$$$UPPER(pModelOutputClassName))) {
			set pModelOutputClassName = (n_$i(i))
		}
		set %PMML("Classes",$$$UPPER(pModelOutputClassName)) = "OUTPUT"
		
        if $$$defClassDefined(pModelOutputClassName) {
            set tSC = $$Delete^%apiOBJ(pModelOutputClassName,"-d")
            quit:$$$ISERR(tSC)
        }
        
        set tModelOutputClass = ##class(%Dictionary.ClassDefinition).%New()
        set tModelOutputClass.Name = pModelOutputClassName
        set tModelOutputClass.Super = "%DeepSee.PMML.ModelOutput"
        set tModelOutputClass.ProcedureBlock = 1
        set tModelOutputClass.GeneratedBy = tDefinitionClassName
        
        set tGetFields = ##class(%Dictionary.MethodDefinition).%New()
        set tGetFields.Name = "%GetFields"
        set tGetFields.ClassMethod = 1
        set tGetFields.FormalSpec = "*pFields"
        set tGetFields.ReturnType = "%Status"
        $$$WriteLine(tGetFields,"kill pFields")
        
        set tGetDisplayValue = ##class(%Dictionary.MethodDefinition).%New()
        set tGetDisplayValue.Name = "%GetDisplayValue"
        set tGetDisplayValue.ClassMethod = 1
        set tGetDisplayValue.FormalSpec = "pField:%String,pValue"
        set tGetDisplayValue.ReturnType = "%String"
        
        
        if $isobject(pModel.Targets) {
            for j = 1:1:pModel.Targets.Targets.Count() {
                #dim tTarget As %DeepSee.PMML.Definition.Target = pModel.Targets.Targets.GetAt(j)
                set tPropName = $$$PROPERTYNAME(tTarget.field)
                
                if (tTarget.castInteger'="") || (tTarget.min'="") || (tTarget.max'="") || (+tTarget.rescaleConstant'=0) || (+tTarget.rescaleFactor'=1) {
                    set tSetter = ##class(%Dictionary.MethodDefinition).%New()
                    set tSetter.Name = tPropName_"Set"
                    set tSetter.Internal = 1
                    set tSetter.ServerOnly = 1
                    set tSetter.ReturnType = "%Status"
                    set tSetter.FormalSpec = "pValue"
                    
                    if (tTarget.min'="") {
                        $$$WriteLine(tSetter,"set:pValue<"_tTarget.min_" pValue = "_tTarget.min)
                    }
                    if (tTarget.max'="") {
                        $$$WriteLine(tSetter,"set:pValue>"_tTarget.max_" pValue = "_tTarget.max)
                    }
                    if (tTarget.rescaleFactor'=1) {
                        $$$WriteLine(tSetter,"set pValue = pValue * "_+tTarget.rescaleFactor)
                    }
                    if (+tTarget.rescaleConstant'=0) {
                        $$$WriteLine(tSetter,"set pValue = pValue + "_+tTarget.rescaleConstant)
                    }
                    if (tTarget.castInteger'="") {
                        $$$WriteLine(tSetter,"set pValue = ##class(%DeepSee.PMML.Utils.Math).CastInteger(pValue, "_$$$QUOTE(tTarget.castInteger)_")")
                    }
                    $$$WriteLine(tSetter,"set i%"_tPropName_" = pValue")
                    do tModelOutputClass.Methods.Insert(tSetter)
                }
                
                $$$WriteLine(tGetDisplayValue,"if (pField = "_$$$QUOTE($$$PROPERTYNAME(tTarget.field))_") {")
                for k = 1:1:tTarget.Values.Count() {
                    #dim tTargetValue As %DeepSee.PMML.Definition.TargetValue = tTarget.Values.GetAt(k)
                    
                    if (tTargetValue.displayValue'="") {
                        $$$WriteLine(tGetDisplayValue," quit:(pValue="_$$$QUOTE(tTargetValue.value)_") "_$$$QUOTE(tTargetValue.displayValue))
                        set tFieldsAlreadyInDisplayValue(tPropName) = ""
                    }
                }
                $$$WriteLine(tGetDisplayValue,"}")
            }
        }
        
        if $isobject(pModel.Output) {
            for j = 1:1:pModel.Output.OutputFields.Count() {
                #dim tOutputField As %DeepSee.PMML.Definition.OutputField = pModel.Output.OutputFields.GetAt(j)
                set tPropName = $$$PROPERTYNAME(tOutputField.name)
                
                set tProp = ##class(%Dictionary.PropertyDefinition).%New()
                set tProp.Name = tPropName
                if (tOutputField.dataType'="") {
                    set tProp.Type = ##class(%DeepSee.PMML.Datatype.DataType).GetClassname(tOutputField.dataType)
                } else {
                	set tProp.Type = "%DeepSee.PMML.Datatype."_$s(tOutputField.feature="probability":"ProbNumber", "affinity,residual,standardError,clusterId,clusterAffinity"[tOutputField.feature:"Number", 1:"String")
                }
                set tDisplayName = $s(tOutputField.displayName'="":tOutputField.displayName, 1:tOutputField.name)
                set tProp.Description = "displayName = "_tDisplayName_$c(13,10)_"targetField = "_tOutputField.targetField_$c(13,10)_"feature = "_tOutputField.feature
                do tModelOutputClass.Properties.Insert(tProp)
                
                set tTargetField = $s(tOutputField.targetField'="":$$$PROPERTYNAME(tOutputField.targetField), $d(pPredictedFields):$order(pPredictedFields("")), 1:tOutputField.name)
                $$$WriteLine(tGetFields,"set pFields("_$$$QUOTE(tOutputField.name)_") = $lb("_$$$QUOTE(tOutputField.feature)_", "_$$$QUOTE(tTargetField)_", "_$$$QUOTE(tDisplayName)_")")
                
                // ensure targetField gets included in %GetDisplayValue()
                set:(tOutputField.targetField'="") tFieldsForDisplayValue(tPropName) = ""
                
                // ensure the field is included in pPredictedFields
                if (tOutputField.feature="predictedValue") && (tOutputField.targetField="") && '$d(pPredictedFields(tOutputField.name)) {
	                set pPredictedFields(tOutputField.name) = $lb(tProp.Type, tOutputField.name, tOutputField.dataType, tOutputField.optype)
                }
            }
            
        } else {
            
            // if no <Output> element present, create default one
            set tSC = $classmethod(pModel.%GetModelClass(), "%AppendImplicitOutputFields", .pPredictedFields)
            quit:$$$ISERR(tSC)
            
            set tPropName = ""
            for {
                set tPropName = $order(pPredictedFields(tPropName), 1, tInfo)
                quit:tPropName=""
                
                set tProp = ##class(%Dictionary.PropertyDefinition).%New()
                set tProp.Name = $$$PROPERTYNAME(tPropName)
                set tProp.Type = $li(tInfo,1)
                set tProp.Description = "targetField = "_$li(tInfo,2)_$c(13,10)_"feature = predictedValue"
                do tModelOutputClass.Properties.Insert(tProp)
                
                $$$WriteLine(tGetFields,"set pFields("_$$$QUOTE(tPropName)_") = $lb(""predictedValue"", "_$$$QUOTE(tPropName)_", "_$$$QUOTE($g(tDisplayNames(tPropName)))_")")
            }
        }
        
        $$$WriteLine(tGetFields,"quit $$$OK")
        do tModelOutputClass.Methods.Insert(tGetFields)
        
        
        merge tFieldsForDisplayValue = pPredictedFields
        set tPropName=""
        for {
            set tPropName = $order(tFieldsForDisplayValue(tPropName))
            quit:tPropName=""
            continue:$d(tFieldsAlreadyInDisplayValue(tPropName))
            
            set tDataField = $g(%PMML("Fields",tPropName,"object"))
            continue:'$isobject(tDataField)
            
            $$$WriteLine(tGetDisplayValue,"if (pField="_$$$QUOTE(tPropName)_") {")
            for j = 1:1:tDataField.Values.Count() {
                set tValue = tDataField.Values.GetAt(j)
                continue:'tValue.%IsA("%DeepSee.PMML.Definition.Util.Value")
                if (tValue.displayValue'="") {
                    $$$WriteLine(tGetDisplayValue," quit:(pValue="_$$$QUOTE(tValue.value)_") "_$$$QUOTE(tValue.displayValue))
                }
            }
            $$$WriteLine(tGetDisplayValue,"}")
        }
        $$$WriteLine(tGetDisplayValue,"quit pValue")
        do tModelOutputClass.Methods.Insert(tGetDisplayValue)
        
        set tSC = tModelOutputClass.%Save()
        quit:$$$ISERR(tSC)
        set tModelOutputClass=""
        
        do QueueClass^%occCompile(pModelOutputClassName)
        
        $$$comClassArraySet(tDefinitionClassName,$$$cCLASSclasses,pModelOutputClassName_".CLS","")
        $$$defClassKeySet(pModelOutputClassName,$$$cCLASSgeneratedby,tDefinitionClassName_".CLS")
        
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%GenerateSetterCode">
<ClassMethod>1</ClassMethod>
<FormalSpec>pSetter:%Dictionary.MethodDefinition,pDataField:%DeepSee.PMML.Definition.DataField</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #define QuoteIf(%if,%v) $s(%if:$$$QUOTE(%v), (%v=""):"""""", 1:%v)
    #define WriteLine(%m,%c) do %m.Implementation.WriteLine($c(9)_%c)
    
	set tSC = $$$OK
	try {
		set tQuote = (pDataField.dataType="string") || (pDataField.dataType="")
		
        // strip trailing blanks
        if (pDataField.dataType="string") {
            $$$WriteLine(pSetter,"set pValue = $zstrip(pValue,"">W"")")
        }
        
        $$$WriteLine(pSetter,"if (pValue="""") {")
        $$$WriteLine(pSetter,$c(9)_"set tStatus = ""missing""")
        
        // valid/invalid/missing treatment
        kill tIntervals, tStatusCovered
        set tPropName = $$$PROPERTYNAME(pDataField.name)
        for j = 1:1:pDataField.Values.Count() {
            set tRange = pDataField.Values.GetAt(j)
            if (tRange.%IsA("%DeepSee.PMML.Definition.Util.Value")) {
                #dim tValue As %DeepSee.PMML.Definition.Util.Value = tRange
                set %PMML("Fields", tPropName, "values", $s(tValue.value="":$c(0), 1:tValue.value)) = $i(%PMML("Fields", tPropName, "values"))
                
                // if there are preceding intervals, process them now using this value
                if $d(tIntervals) {
                    set tCondition = ""
                    for k = 1:1:$g(tIntervals) {
                        #dim tInterval As %DeepSee.PMML.Definition.Util.Interval = tIntervals(k)
                        set tCondition = $s(tCondition="":"", 1:tCondition _ " || ") _ tInterval.%GetAsCondition("pValue")
                    }
                    $$$WriteLine(pSetter,"} elseif "_tCondition_" {")
                    if (tValue.value'="") {
                        $$$WriteLine(pSetter,$c(9)_"set pValue = "_$$$QuoteIf(tQuote,tValue.value))
                    }
                    kill tIntervals 
                } elseif (pDataField.dataType="boolean") && '$isvalidnum(tValue.value) {
	                if ($$$LOWER(tValue.value)="false") {
	                    $$$WriteLine(pSetter,"} elseif ($$$LOWER(pValue) = ""false"") || (pValue = 0) {")
	                    $$$WriteLine(pSetter,"	set pValue = 0")
	                } else {
	                    $$$WriteLine(pSetter,"} elseif ($$$LOWER(pValue) = ""true"") || (pValue = 1) {")
	                    $$$WriteLine(pSetter,"	set pValue = 1")
	                }
                } else {
                    $$$WriteLine(pSetter,"} elseif (pValue = "_$$$QuoteIf(tQuote,tValue.value)_") {")
                }
                $$$WriteLine(pSetter,$c(9)_"set tStatus = "_$$$QUOTE(tValue.property))
                
                set x = $i(tStatusCovered(tValue.property))
                
                // BDB731 - no simple mode when "invalid"/"missing" values are specified
                set:(tValue.property="invalid")||(tValue.property="missing") %PMML("Fields", tPropName, "complex") = 1
                
            } else {
                set tIntervals($i(tIntervals)) = tRange
            }
                
            // if there are intervals left, append them as valid values
            if $d(tIntervals) {
                set tCondition = ""
                for k = 1:1:$g(tIntervals) {
                    set tInterval = tIntervals(k)
                    set tCondition = $s(tCondition="":"", 1:tCondition _ " || ") _ tInterval.%GetAsCondition("pValue")
                }
                $$$WriteLine(pSetter,"} elseif "_tCondition_" {")
                $$$WriteLine(pSetter,$c(9)_"set tStatus = ""valid""")
                kill tIntervals 
                set x = $i(tStatusCovered("valid"))
            }
        }
        
        // now treat remaining cases
        $$$WriteLine(pSetter,"} else { set tStatus = """_$s($d(tStatusCovered("valid")):"invalid", 1:"valid")_""" }")
        
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Model.AbstractModel">
<Copyright>/* Copyright (c) 2018 by InterSystems Corporation.
   Cambridge, Massachusetts, U.S.A.  All rights reserved.
   Confidential property of InterSystems Corporation. */</Copyright>
<Description><![CDATA[
This class represents a PMML model as defined in the PMML XData block of a <class>%DeepSee.PMML.Definition</class> class.]]></Description>
<Abstract>1</Abstract>
<IncludeCode>%PMML</IncludeCode>
<IncludeGenerator>%PMML</IncludeGenerator>
<Super>%RegisteredObject</Super>
<System>4</System>
<TimeCreated>62741,61449.664371</TimeCreated>

<Parameter name="DEFINITIONCLASS">
<Description><![CDATA[
The name of the <class>%DeepSee.PMML.Definition</class> class defining this PMML model.]]></Description>
<Type>CLASSNAME</Type>
<Internal>1</Internal>
</Parameter>

<Parameter name="DATACLASS">
<Description><![CDATA[
The name of the root <class>%DeepSee.PMML.Data</class> class for this model's PMML definition]]></Description>
<Type>CLASSNAME</Type>
</Parameter>

<Parameter name="INPUTCLASS">
<Description><![CDATA[
The name of the <class>%DeepSee.PMML.ModelInput</class> class for this model]]></Description>
<Type>CLASSNAME</Type>
</Parameter>

<Parameter name="OUTPUTCLASS">
<Description><![CDATA[
The name of the <class>%DeepSee.PMML.ModelOutput</class> class for this model]]></Description>
<Type>CLASSNAME</Type>
</Parameter>

<Parameter name="MODELNAME">
<Description>
The name of this model as defined in the PMML definition</Description>
<Type>STRING</Type>
</Parameter>

<Parameter name="PREDICTEDFIELD">
<Description><![CDATA[
The field in <parameter>DATACLASS</parameter> predicted by this model.]]></Description>
<Type>STRING</Type>
</Parameter>

<Parameter name="TRACEWEIGHTTYPE">
<Description><![CDATA[
How the weighting info in this models trace output needs to be interpreted.
Either of:
<ul>
	<li>"none": only rank info available</li>
	<li>"tree": trace info is a sequence of tree nodes leading to the prediction</li>
	<li>"add": additive contributions (total score might be a function of this sum)</li>
	<li>"multiply": multiplicative contributions (total score might be a function of this product)</li>
</ul>]]></Description>
<Type>STRING</Type>
<Internal>1</Internal>
<Default>none</Default>
</Parameter>

<Parameter name="SUPPORTSSIMPLEMODE">
<Description>
This parameter defines whether the model type implementation supports "simple mode",
with simple array data structures rather than objects used to pass around observation data.
This parameter is for internal use only.</Description>
<Type>BOOLEAN</Type>
<Internal>1</Internal>
<Default>0</Default>
</Parameter>

<Property name="SimpleMode">
<Description><![CDATA[
Whether or not to use simple arrays to pass observation data around internally.
While faster, data dictionaries with derived fields or requiring specific treatment of 
certain values, as well as certain model types, cannot use simple mode. In these cases
the <parameter>SUPPORTSSIMPLEMODE</parameter> is set to 0. ]]></Description>
<Type>%Boolean</Type>
<Internal>1</Internal>
<InitialExpression>..#SUPPORTSSIMPLEMODE</InitialExpression>
</Property>

<Property name="Tracing">
<Description>
Whether or not to generate trace information in the output object.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="KeepAllClassProbabilities">
<Description>
For classification models only.
If set to 1, the probabilities of each class will be available from the output object,
regardless of the OutputField settings in the definition.</Description>
<Type>%Boolean</Type>
<Internal>1</Internal>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="%CreateModelClass">
<Description><![CDATA[
<p>This method is called as part of compiling a <class>%DeepSee.PMML.Definition</class> Model node and
adds the appropriate properties, methods and other constructs to the model class
<var>pClass</var>. Subclasses are free to forward (parts of) this activity as they see fit and
can even change the superclass of <var>pClass</var>, as long as it remains a subclass of
this class.</p>
<p>The following class parameters are already defined in <var>pClass</var>:
<ul>
 <li>DATACLASS</li>
 <li>INPUTCLASS</li>
 <li>OUTPUTCLASS</li>
 <li>MODELNAME</li>
</ul>]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%Dictionary.ClassDefinition,pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetName">
<Description><![CDATA[
Returns the name of this model (similar to <parameter>MODELNAME</parameter>)]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<ForceGenerate>1</ForceGenerate>
<Implementation><![CDATA[..#MODELNAME
]]></Implementation>
</Method>

<Method name="%GetDataClassName">
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<ForceGenerate>1</ForceGenerate>
<Implementation><![CDATA[..#DATACLASS
]]></Implementation>
</Method>

<Method name="%GetInputClassName">
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<ForceGenerate>1</ForceGenerate>
<Implementation><![CDATA[..#INPUTCLASS
]]></Implementation>
</Method>

<Method name="%GetOutputClassName">
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<ForceGenerate>1</ForceGenerate>
<Implementation><![CDATA[..#OUTPUTCLASS
]]></Implementation>
</Method>

<Method name="%GetPredictedField">
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<ForceGenerate>1</ForceGenerate>
<Implementation><![CDATA[..#PREDICTEDFIELD
]]></Implementation>
</Method>

<Method name="%GetInputObject">
<Description><![CDATA[
Builds a <class>%DeepSee.PMML.ModelInput</class> object based on the root <class>%DeepSee.PMML.Data</class>
for this PMML definition.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pData:%DeepSee.PMML.Data</FormalSpec>
<ReturnType>%DeepSee.PMML.ModelInput</ReturnType>
<Implementation><![CDATA[
	if (%class.Abstract) {
		do %code.WriteLine("	quit """"")
	} else {
		do %code.WriteLine("	quit ##class(" _ %parameter("INPUTCLASS")_").%New(pData)")
	}
]]></Implementation>
</Method>

<Method name="%ExecuteModelInternal">
<Description>
To be implemented by subclasses</Description>
<Abstract>1</Abstract>
<FormalSpec><![CDATA[&pInput:%DeepSee.PMML.ModelInput,*pOutput:%DeepSee.PMML.ModelOutput]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	quit $$$OK
]]></Implementation>
</Method>

<Method name="%ExecuteModelDeepSee">
<Description><![CDATA[
This method runs the model against a fact from the DeepSee fact table of a cube for which
an &lt;X-DeepSeeDataSource&gt; element defines a mapping from the cube's measures and
dimensions to the Data Fields in the PMML definition. If <var>pDataSource</var> is null, 
the first DataSource of the model definition is expected to contain this DeepSee-to-PMML mapping.</p>]]></Description>
<Final>1</Final>
<FormalSpec>pFactId:%Integer,*pOutput:%DeepSee.PMML.ModelOutput,pDataSource:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK, pOutput = ""
	try {
		
		set tSC = $classmethod(..#DATACLASS, "%CreateFromDeepSee", pFactId, .tObservation, pDataSource)
		quit:$$$ISERR(tSC)
		
		set tSC = ..%ExecuteModel(.tObservation, .pOutput)
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%ExecuteModel">
<Description><![CDATA[
<p>Executes this model for a given <class>%DeepSee.PMML.Data</class> data object.
As an alternative to providing the actual Data Class (or model input class) for this model, it
is also possible to supply a simple array containing the data field values indexed by field name.</p>
<p>See also <class>%DeepSee.PMML.Utils</class> for details about running a model against a
whole set of records at once, writing the corresponding results to a table.</p>]]></Description>
<Final>1</Final>
<FormalSpec><![CDATA[&pData:%DeepSee.PMML.Data,*pOutput:%DeepSee.PMML.ModelOutput]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK, pOutput = ""
	try {
		
		if '$d(pData) {
			set tSC = $$$ERROR($$$GeneralError, "supplied data object is empty")
			quit
		}
		
		// BDB731 - check if we can use "simple mode"
		if 'i%SimpleMode {
			
			// if the data comes in as an array, try to turn it into a data class
			if $d(pData)>1 {
				set tData = $classmethod(..#INPUTCLASS, "%CreateFromArray", .pData, .tSC)
				quit:$$$ISERR(tSC)
			}
			
			// check if this is the right data class
			elseif '$isobject(pData) {
				
				set tSC = $$$ERROR($$$GeneralError, "supplied variable is not an object or array")
				quit
				
			} elseif 'pData.%IsA(..#DATACLASS) {
				
				// BDB717 - leverage %GetAsArray code if possible
				if pData.%IsA("%DeepSee.PMML.Data") {
					set tSC = pData.%GetAsArray(.tArray)
					quit:$$$ISERR(tSC)
					set tData = $classmethod(..#INPUTCLASS, "%CreateFromArray", .tArray, .tSC)
					quit:$$$ISERR(tSC)
				} else {
					set tData = $classmethod(..#INPUTCLASS, "%CreateFromObject", pData, .tSC)
					quit:$$$ISERR(tSC)
				}
				
			} 
			
			// if pData is not a model-specific data class, convert it
			elseif 'pData.%IsA(..#INPUTCLASS) {
				set tData = ..%GetInputObject(pData)
				if (tData="") { set tSC = %objlasterror  quit }
			}
			
		} else {
			
			// BDB731 - check if this is already an array
			if $d(pData) > 1 {
				
				set tSC = ..%ExecuteModelInternal(.pData, .pOutput)
				quit
				
			// BDB731 - if not, convert to simple array
			} elseif '$isobject(pData) {
				set tSC = $$$ERROR($$$GeneralError, "supplied variable is not an object or array")
				quit
			} elseif pData.%IsA("%DeepSee.PMML.Data") {
				set tSC = pData.%GetAsArray(.tData)
				quit:$$$ISERR(tSC)
			} else {
				// if an unknown object, convert to input object and then extract array
				set tObjData = $classmethod(..#INPUTCLASS, "%CreateFromObject", pData, .tSC)
				quit:$$$ISERR(tSC)
				set tSC = tObjData.%GetAsArray(.tData)
				quit:$$$ISERR(tSC)
				set tSC = $$$ERROR($$$GeneralError, "unsupported input object for this model")
				quit
			}
		}
			
		// now forward to the real execution method
		set tSC = ..%ExecuteModelInternal(.tData, .pOutput)
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%GetPredictedFieldFromDef">
<Description>
Returns the name of the field whose value is predicted by this model. To be overridden/refined
by subclasses</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	do ..%GetPredictedFieldsFromDef(pDefinition, .tFields)
	quit $g(tFields(1))
]]></Implementation>
</Method>

<Method name="%GetPredictedFieldsFromDef">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel,*pAllFields</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill pAllFields
	for i = 1:1:pDefinition.MiningSchema.MiningFields.Count() {
		set tField = pDefinition.MiningSchema.MiningFields.GetAt(i)
		if $$$PMMLusageTypeIsTarget(tField.usageType) {
			set pAllFields($i(pAllFields)) = tField.name
		}
	}
	if '$d(pAllFields) && $isobject(pDefinition.Output.OutputFields) {
		for i = 1:1:pDefinition.Output.OutputFields.Count() {
			set tOutputField = pDefinition.Output.OutputFields.GetAt(i)
			if (tOutputField.feature="predictedValue") {
				set pAllFields($i(pAllFields)) = $s(tOutputField.targetField="":tOutputField.name, 1:tOutputField.targetField)
			}
		}
	}
	
	// BDB827: predicted fields might be inherited from parent model
	if '$d(pAllFields) && $d(%PMML("CurrentModel"),tCurrentModel) { // tap into compile-time context
		set tCurrentModelName = %PMML("CurrentModel",tCurrentModel)
		if $d(%PMML("Models",$$$UPPER(tCurrentModelName),"parent"),tParentModelName) {
			merge tParentTargets = %PMML("Classes",$$$UPPER(%PMML("Models",$$$UPPER(tParentModelName))),"targetFields")
			set tFieldName = ""
			for {
				set tFieldName = $order(tParentTargets(tFieldName))
				quit:tFieldName=""
				set pAllFields($i(pAllFields)) = tFieldName
			}
		}
	}
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%AppendImplicitOutputFields">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pPredictedFields]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetPredictedFieldInfo">
<Description>
Returns basic info about the data field predicted by this model.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pFieldName:%String,*pDataType:%String,*pOpType:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	quit $$$OK
]]></Implementation>
</Method>

<Method name="%PopulateOutputObject">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel,pMethod:%Stream.Object,pPredictedValueVar:%String="tPredictedValue"</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#define WriteLine(%c) do pMethod.WriteLine($c(9,9)_%c)
	
	set tSC = $$$OK
	try {
		$$$WriteLine("")
		$$$WriteLine("set pOutput = $classmethod(..#OUTPUTCLASS, ""%New"")")
		
		set tPredictedField = ..%GetPredictedFieldFromDef(pDefinition)
		if $isobject(pDefinition.Output) {
			for i = 1:1:pDefinition.Output.OutputFields.Count() {
				#dim tOutputField As %DeepSee.PMML.Definition.OutputField = pDefinition.Output.OutputFields.GetAt(i)
				continue:tOutputField.segmentId'=""
				
				set tTargetField = tOutputField.targetField
				if (tTargetField'="") {
					if (tTargetField'=tPredictedField) {
						set tSC = $$$ERROR($$$GeneralError, "OutputField has a targetField that does not correspond to this model's target field")
						quit
					}
				} else {
					set tTargetField = tPredictedField
				}
				
				if (tOutputField.feature = "predictedValue") {
					
					set tFeatureValueVar = pPredictedValueVar
					
				} elseif (tOutputField.feature = "transformedValue") {
					
					set tExprCode = tOutputField.Expression.%GetComputeCode(.tInline, pPredictedValueVar)
					if (tInline) {
						set tFeatureValueVar = tExprCode
					} else {
						$$$WriteLine("")
						$$$WriteLine("// compute code for expression")
						$$$WriteLine("set tValue = "_pPredictedValueVar_", tStatus = $s("_pPredictedValueVar_"="""":""missing"", 1:""valid"")")
						do pMethod.WriteLine(tExprCode)
						$$$WriteLine("")
						set tFeatureValueVar = "tValue"
					}
						
				} else {
					
					set tFeatureValueVar = "tFeatureValue"
					set tSC = ..%OnGetOutputFeature(pMethod, pDefinition, tOutputField, .tFeatureValueVar, .tSupported)
					quit:$$$ISERR(tSC)
					
					// feature is not supported!
					if 'tSupported {
						
						// some fallback options for select features
						if (tOutputField.feature = "predictedDisplayValue") {
							$$$WriteLine("set "_tFeatureValueVar_" = pOutput.%GetDisplayValue("_$$$QUOTE(tPredictedField)_", "_pPredictedValueVar_")")
						} else {
							set tSC = $$$ERROR($$$GeneralError, "Output field '"_tOutputField.name_"' with feature '"_tOutputField.feature_"' not supported for model type '"_$piece($classname(pDefinition),".",*)_"'")
							quit
						}
					}
					
				}
				$$$WriteLine("set pOutput."_$$$PROPERTYNAME(tOutputField.name)_" = "_tFeatureValueVar)
				
			}
			quit:$$$ISERR(tSC)
		} else {
			$$$WriteLine("set pOutput."_$$$PROPERTYNAME(tPredictedField)_" = "_pPredictedValueVar)
		}
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%OnGetOutputFeature">
<Description><![CDATA[
Write code to compute a nontrivial feature for <var>pOutputField</var> to <var>pMethod</var>,
setting the value to a variable named <var>pFeatureValue</var> (can be updated). The features
"predictedValue" and x are already taken care of.]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pMethod:%Stream.Object,pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel,pOutputField:%DeepSee.PMML.Definition.OutputField,&pFeatureValueVar:%String,*pSupported:%Boolean]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set pSupported = 0
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%IsOutputFieldSupported">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel,pOutputField:%DeepSee.PMML.Definition.OutputField,*pSC:%Status</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set pSC = $$$OK
	set pSC = ..%OnGetOutputFeature(##class(%Stream.TmpCharacter).%New(), pDefinition, pOutputField, "dummy", .tSupported)
	quit tSupported
]]></Implementation>
</Method>

<Method name="%GetDefinition">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pModel:%DeepSee.PMML.Definition.Models.AbstractModel</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		#dim tPMML As %DeepSee.PMML.Definition.PMML
		set tSC = $classmethod(..#DEFINITIONCLASS, "%GetDefinition", .tPMML)
		quit:$$$ISERR(tSC)
		
		for i = 1:1:tPMML.Models.Count() {
			if (tPMML.Models.GetAt(i).modelName = ..#MODELNAME) {
				set pModel = tPMML.Models.GetAt(i)
				quit
			}
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%PopulateTrace">
<Internal>1</Internal>
<FormalSpec><![CDATA[&pOutput:%DeepSee.PMML.ModelOutput,&pWeights]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tWeight = ""
		for {
			set tWeight = $order(pWeights(tWeight))
			quit:tWeight=""
			
			set i = ""
			for {
				set i = $order(pWeights(tWeight, i), 1, tInfo)
				quit:i=""
				
				set pOutput.%Trace($i(pOutput.%Trace)) = $li(tInfo,1,2) _ $lb($i(tRank)) _ $li(tInfo,3,4)
			}
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%DrawTraceInfo">
<Description>
Prints the trace information for this model type in user-friendly HTML.
To be refined by subclasses based on the information available for that model type.</Description>
<Internal>1</Internal>
<FormalSpec>pOutput:%DeepSee.PMML.ModelOutput</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		quit:$g(pOutput)=""
        quit:$$$ISERR(pOutput.%GetTracingInfo(.tTrace))
        
        if (..#TRACEWEIGHTTYPE'="none") {
	        set tMaxWeight = "", tMinWeight = ""
	        set tHasPos = 0, tHasNeg = 0
	        for i = 1:1:tTrace {
		        set tWeight = $lg(tTrace(i),4)
		        continue:'tWeight
		        if (tWeight > 0) {
			        set tHasPos = 1
		        } else {
			        set tHasNeg = 1
		        }
		        set tWeights(tWeight) = ""
		        set tWeight = $zabs(tWeight)
		        set:(tMaxWeight="")||(tMaxWeight<tWeight) tMaxWeight = tWeight
		        set:(tMaxWeight="")||(tMaxWeight<tWeight) tMaxWeight = tWeight
	        }
        	
	        set tMaxBarWidth = 100, tMinBarWidth = 5
	        if tHasPos && tHasNeg {
		        set tMax = $o(tWeights(""),-1), tMin = $o(tWeights(""))
		        set tMaxPosBarWidth = (tMaxBarWidth * tMax / (tMax + $zabs(tMin))) \ 1
		        set tMaxNegBarWidth = (tMaxBarWidth * $zabs(tMin) / (tMax + $zabs(tMin))) \ 1
	        }
        }
        
        &html<<table width="100%">>
        if (..#TRACEWEIGHTTYPE = "tree") {
	        set tSpacerWidth = 0
        } elseif (..#TRACEWEIGHTTYPE = "none") {
		    &html<<tr><th>Rank</th><th>Info</th></tr>>
        } else {
		    &html<<tr><th>Info</th><th>Contribution</th></tr>>
        }
	    for i = 1:1:tTrace {
	        set tFields = $lts($lg(tTrace(i),1))
	        set tValues = $lts($lg(tTrace(i),2))
	        set tRank = $lg(tTrace(i),3)
	        set tWeight = $normalize($lg(tTrace(i),4),4)
	        set tInfo = $lg(tTrace(i),5)
	        
	        set tInfo = $s(tInfo="":tFields, 1:tInfo)
	        if tWeight && (..#TRACEWEIGHTTYPE'="none") && (..#TRACEWEIGHTTYPE'="tree") {
		        
		        if (tHasPos && tHasNeg) {
			        
			        if tWeight>0 {
				        set tWidth = tMaxPosBarWidth * tWeight / tMax
				        set tWeight = "<td width="""_(tMaxNegBarWidth+tMinBarWidth+1)_"""><img src=""images/spacer.gif"" border=""0"" /></td><td width="""_((tWidth+tMinBarWidth)\1)_""" title="""_tWeight_""" style=""background-color: #9cfa7d; border-left:1px solid #333333;""><img src=""images/spacer.gif"" border=""0"" /></td><td width="""_(tMaxPosBarWidth-(tWidth\1)+1)_"""><img src=""images/spacer.gif"" border=""0"" /></td>"
			        } else {
				        set tWidth = tMaxNegBarWidth * tWeight / $zabs(tMin)
				        set tWeight = "<td width="""_(tMaxNegBarWidth-$zabs(tWidth\1)+1)_"""><img src=""images/spacer.gif"" border=""0"" /></td><td width="""_($zabs(tWidth\1)+tMinBarWidth)_""" title="""_tWeight_""" style=""background-color: #eea17d; border-right:1px solid #333333;""><img src=""images/spacer.gif"" border=""0"" /></td><td width="""_(tMaxPosBarWidth+tMinBarWidth)_""" ><img src=""images/spacer.gif"" border=""0"" /></td>"
			        }
			        
		        } else {
			        set tWidth = (tMaxBarWidth * tWeight / (tMaxWeight-tMinWeight)) \ 1
			        set tWeight = "<td width="""_($zabs(tWidth)+tMinBarWidth)_""" title="""_tWeight_""" style=""background-color: "_$s(tWidth>0:"#9cfa7d;", 1:"#eea17d;")_"; border-left:1px solid #333333;""><img src=""images/spacer.gif"" border=""0"" /></td><td width="""_(tMaxBarWidth-tWidth+1)_"""><img src=""images/spacer.gif"" border=""0"" /></td>"
		        }
		        
		        set tWeight = "<table height=""15""><tr>"_tWeight_"</tr></table>"
		        
	        } else {
		        set tWeight=""
	        }
	        
	        if (..#TRACEWEIGHTTYPE = "tree") {
		        &html<<tr><td><img src="images/spacer.gif" width="#(tSpacerWidth)#" height="1" /><img src="images/line-ne.gif" style="vertical-align:text-top;" /> #(tInfo)#</td></tr>>
		        set tSpacerWidth = $i(tSpacerWidth,30)
	        } elseif (..#TRACEWEIGHTTYPE = "none") {
		        &html<<tr><td>#(tRank)#</td><td>#(tInfo)#</td></tr>>
	        } else {
		        &html<<tr><td>#(tInfo)#</td><td>#(tWeight)#</td></tr>>
	        }
        }
        &html<</table>>
        
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="SimpleModeSet">
<Internal>1</Internal>
<FormalSpec>pValue:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	if (pValue && '..#SUPPORTSSIMPLEMODE) {
		quit $$$ERROR($$$GeneralError, "This model does not support simple mode")
	}
	set i%SimpleMode = pValue
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Model.Clustering">
<Abstract>1</Abstract>
<Super>AbstractModel</Super>
<System>4</System>
<TimeCreated>63125,41195.735415</TimeCreated>

<Method name="%CreateModelClass">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%Dictionary.ClassDefinition,pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		#dim tDefinition As %DeepSee.PMML.Definition.Models.ClusteringModel = pDefinition
		#dim tCluster As %DeepSee.PMML.Definition.Models.Clustering.Cluster
		#dim tField As %DeepSee.PMML.Definition.Models.Clustering.ClusteringField
		
		if (tDefinition.modelClass'="centerBased") {
			set tSC = $$$ERROR($$$NotImplemented) // TODO
			quit
		}
		
		/// add %ExecuteModelInternal method
		set tExecute = ##class(%Dictionary.MethodDefinition).%New()
		set tExecute.Name = "%ExecuteModelInternal"
		set tExecute.FormalSpec = "pObservation:%DeepSee.PMML.ModelInput,*pOutput:%DeepSee.PMML.ModelOutput"
		set tExecute.ReturnType = "%Status"
		set tExecute.Private = 1
		
		do tExecute.Implementation.WriteLine("	set tSC = $$$OK, pOutput=""""")
		do tExecute.Implementation.WriteLine("	try {")
		#define WriteLine(%c) do tExecute.Implementation.WriteLine($c(9,9)_%c)
		
		for i = 1:1:tDefinition.Fields.Count() {
			set tField = tDefinition.Fields.GetAt(i)
			continue:'tField.isCenterField
			set tFields($i(tFields)) = tField
		}
		
		set:$isobject(tDefinition.MissingValueWeights) tSC = tDefinition.MissingValueWeights.ValuesAsArray(.tQ)
		set tQ = 0
		for i = 1:1:tFields {
			set:'$d(tQ(i)) tQ(i) = 1
			set tQ = tQ + tQ(i)
		}
		
		set tMetric = $piece($classname(tDefinition.ComparisonMeasure.Metric),".",*)
		set tDefaultFunction = tDefinition.ComparisonMeasure.compareFunction
		set tClusterCount = tDefinition.Clusters.Count()
		for i = 1:1:tClusterCount {
			set tCluster = tDefinition.Clusters.GetAt(i)
			set tSC = tCluster.Coordinates.ValuesAsArray(.tCoords)
			quit:$$$ISERR(tSC)
			
			set tClusterId = $s(tCluster.id="":i, 1:tCluster.id)
			$$$WriteLine("")
			$$$WriteLine("// Calculating "_tDefinition.ComparisonMeasure.kind_" for cluster "_tClusterId_$s(tCluster.name="":"", 1:": '"_tCluster.name_"'"))
			
			if (tDefinition.ComparisonMeasure.kind="distance") {
				$$$WriteLine("set tScore = 0, tAdjustM = 0")
				for j = 1:1:tFields {
					set tField = tFields(j)
					$$$WriteLine("if 'pObservation.%IsMissing("_$$$QUOTE(tField.field)_") {")
					$$$WriteLine("	set tAdjustM = tAdjustM + "_tQ(j))
					
					set tFunction = $s(tField.compareFunction="":tDefaultFunction, 1:tField.compareFunction)
					if (tFunction = "absDiff") {
						set tComponent = "$zabs("_tCoords(j)_" - pObservation."_$$$PROPERTYNAME(tField.field)_")"
					} elseif (tFunction = "gaussSim") {
						set tComponent = "$zexp(-$zln(2)*(("_tCoords(j)_" - pObservation."_$$$PROPERTYNAME(tField.field)_")**2)/("_tField.similarityScale_"**2))"
					} elseif (tFunction = "delta") {
						set tComponent = "$s("_tCoords(j)_" = pObservation."_$$$PROPERTYNAME(tField.field)_":0, 1:1)"
					} elseif (tFunction = "equal") {
						set tComponent = "$s("_tCoords(j)_" = pObservation."_$$$PROPERTYNAME(tField.field)_":1, 1:0)"
					} elseif (tFunction = "table") {
						if '$isobject(tField.Comparisons) {
							set tSC = $$$ERROR($$$GeneralError, "Missing Comparisons matrix for ClusteringField '"_tField.field_"'")
							quit
						}
						do tField.Comparisons.ValuesAsArray(.tMatrix)
						merge tValues = %PMML("Fields", $$$PROPERTYNAME(tField.field), "values")
						set tComponent = "$case(pObservation."_$$$PROPERTYNAME(tField.field)
						if '$d(tValues(tCoords(j)), tCoordValueIndex) {
							set tSC = $$$ERROR($$$GeneralError, "Coordinate for field '"_tField.field_"' not found in comparison matrix: '"_tCoords(j)_"'")
							quit
						}
						set tValue = ""
						for {
							set tValue = $order(tValues(tValue),1,tIndex)
							quit:tValue=""
							set tComponent = tComponent_", "_$$$QUOTE(tValue)_":"_tMatrix(tCoordValueIndex, tIndex)
						}
						set tComponent = tComponent _ ")"
					}
					
					if (tMetric="euclidean") || (tMetric="squaredEuclidean") {
						if (tField.fieldWeight'=1) {
							$$$WriteLine("	set tScore  = tScore + (("_tField.fieldWeight_" * "_tComponent_")**2)")
						} else {
							$$$WriteLine("	set tScore  = tScore + ("_tComponent_"**2)")
						}
					} elseif (tMetric="cityBlock") {
						if (tField.fieldWeight'=1) {
							$$$WriteLine("	set tScore  = tScore + ("_tField.fieldWeight_" * "_tComponent_")")
						} else {
							$$$WriteLine("	set tScore  = tScore + "_tComponent)
						}
					} elseif (tMetric="chebychev") {
						$$$WriteLine("	set tComponent = "_tComponent_$s((tField.fieldWeight'=1):" * "_tField.fieldWeight, 1:""))
						$$$WriteLine("	set:tComponent>tScore tScore = tComponent")
					} elseif (tMetric="minkowsky") {
						$$$WriteLine("	set tScore  = tScore + ("_tComponent_"**"_tDefinition.ComparisonMeasure.Metric.p_")")
					} else {
						set tSC = $$$ERROR($$$NotImplemented) // TODO
						quit
					}
					
					$$$WriteLine("}")
					
				}
				quit:$$$ISERR(tSC)
				
				// TODO: what to do with all-missing (ZERO DIVIDE)
				$$$WriteLine("set tScore = $s(tAdjustM=0:"""", 1:tScore * ("_tQ_"/tAdjustM))")
				
				if (tMetric = "euclidean") {
					$$$WriteLine("set:tScore'="""" tScore = $zsqr(tScore)")
				} elseif (tMetric = "minkowsky") {
					$$$WriteLine("set:tScore'="""" tScore = tScore ** (1/"_tDefinition.ComparisonMeasure.Metric.p_")")
				}
			
			} else { // (tDefinition.ComparisonMeasure.kind="similarity")
				
				$$$WriteLine("set (a11, a10, a01, a00) = 0")
				for j = 1:1:tFields {
					set tField = tFields(j)
					if tCoords(j) {
						$$$WriteLine("if (+pObservation."_$$$PROPERTYNAME(tField.field)_") { set a11 = a11+1 } else { set a01 = a01+1 }")
					} else {
						$$$WriteLine("if (+pObservation."_$$$PROPERTYNAME(tField.field)_") { set a10 = a10+1 } else { set a00 = a00+1 }")
					}
				}
				
				if (tMetric="simpleMatching") {
					$$$WriteLine("set tScore = (a11 + a00) / (a11 + a10 + a01 + a00)")
				} elseif (tMetric="jaccard") {
					$$$WriteLine("set tScore = $s((a11 + a10 + a01) : a11 / (a11 + a10 + a01), 1:0)")
				} elseif (tMetric="tanimoto") {
					$$$WriteLine("set tScore = (a11 + a00) / (a11 + (2*(a10 + a01)) + a00)")
				} elseif (tMetric="binarySimilarity") {
					$$$WriteLine("set tScore = ((c11*a11) + (c10*a10) + (c01*a01) + (c00*a00)) / ((d11*a11) + (d10*a10) + (d01*a01) + (d00*a00))")
				} else {
					set tSC = $$$ERROR($$$GeneralError, "Unknown comparison metric: '"_tMetric_"'")
					quit
				}
			}
			$$$WriteLine("set tScores("_$$$QUOTE(tClusterId)_") = tScore")
			$$$WriteLine("set:tScore'="""" tClusterScores(tScore, "_i_") = "_$$$QUOTE(tClusterId))
		}
		
		$$$WriteLine("")
		$$$WriteLine("")
		$$$WriteLine("// finding best cluster score")
		$$$WriteLine("if $d(tClusterScores) {")
		$$$WriteLine("	set tBestScore = $order(tClusterScores(""""), "_$s(tDefinition.ComparisonMeasure.kind="distance":1, 1:-1)_")")
		$$$WriteLine("	set tBestClusterN = $order(tClusterScores(tBestScore,""""),1,tBestClusterId)")
		$$$WriteLine("} else { set (tBestScore, tBestClusterN, tBestClusterId) = """" }")
		
		
		/// Populate Output object
		set tSC = ..%PopulateOutputObject(pDefinition, tExecute.Implementation, "tBestClusterId")
		quit:$$$ISERR(tSC) 
		
		do tExecute.Implementation.WriteLine("	} catch (ex) {")
		do tExecute.Implementation.WriteLine("		set tSC = ex.AsStatus()")
		do tExecute.Implementation.WriteLine("	}")
		do tExecute.Implementation.WriteLine("	quit tSC")
		
		do pClass.Methods.Insert(tExecute)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%OnGetOutputFeature">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pMethod:%Stream.Object,pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel,pOutputField:%DeepSee.PMML.Definition.OutputField,&pFeatureValueVar:%String,*pSupported:%Boolean]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#define WriteLine(%c) do pMethod.WriteLine($c(9,9)_%c)
	
	set pSupported = 0
	if (pOutputField.feature = "entityId") || (pOutputField.feature = "clusterId") {
		set pSupported = 1, pFeatureValueVar = "tBestClusterN"
	} elseif (pOutputField.feature = "predictedDisplayValue") {
		set pSupported = 1, pFeatureValueVar = "$case(tBestClusterN"
		for i = 1:1:pDefinition.Clusters.Count() {
			set pFeatureValueVar = pFeatureValueVar _ ", "_i_":"_$$$QUOTE(pDefinition.Clusters.GetAt(i).name)
		}
		set pFeatureValueVar = pFeatureValueVar _ ", :"""")"
	} elseif (pOutputField.feature="affinity") || (pOutputField.feature="entityAffinity") || (pOutputField.feature="clusterAffinity") {
		if (pOutputField.value="") {
			set pSupported = 1, pFeatureValueVar = "tBestScore"
		} else {
			set pSupported = 1, pFeatureValueVar = "tScores("_$$$QUOTE(pOutputField.value)_")"
		}
	}
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%AppendImplicitOutputFields">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pPredictedFields]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if '$d(pPredictedFields) {
		set pPredictedFields("Cluster") = $lb("%String", "Cluster", "string", "categorical")
	}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetPredictedFieldFromDef">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set tField = ##super(pDefinition)
	set:tField="" tField = "Cluster"
	quit tField
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Model.Composite">
<Copyright>/* Copyright (c) 2018 by InterSystems Corporation.
   Cambridge, Massachusetts, U.S.A.  All rights reserved.
   Confidential property of InterSystems Corporation. */</Copyright>
<Abstract>1</Abstract>
<Super>AbstractModel</Super>
<System>4</System>
<TimeCreated>63060,57505.475967</TimeCreated>

<Property name="SubModels">
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Method name="%CreateModelClass">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%Dictionary.ClassDefinition,pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tDefinition As %DeepSee.PMML.Definition.Models.MiningModel = pDefinition
	#dim tOutputField As %DeepSee.PMML.Definition.OutputField
	#dim tMiningField As %DeepSee.PMML.Definition.MiningField
	
	set tSC = $$$OK
	try {
		quit:'$isobject(tDefinition.Segmentation)
		set tMethod = tDefinition.Segmentation.multipleModelMethod
		set tBaseModelName = %PMML("Classes",$$$UPPER(pClass.Name))_"."
		
		// for model chains, we'll need a handle on the ModelInput
		if (tMethod = "modelChain") {
			set tModelInputClassName = %PMML("Classes",$$$UPPER(pClass.Name),"input")
			set tModelInputClass = ##class(%Dictionary.ClassDefinition).%OpenId(tModelInputClassName)
		}
		
		// generate %ExecuteModelInternal
		set tExecute = ##class(%Dictionary.MethodDefinition).%New()
		set tExecute.Name = "%ExecuteModelInternal"
		set tExecute.FormalSpec = "&pObservation:%DeepSee.PMML.ModelInput,*pOutput:%DeepSee.PMML.ModelOutput"
		set tExecute.ReturnType = "%Status"
		set tExecute.Private = 1
		
		// BDB823 - generate %OnNew
		set tOnNew = ##class(%Dictionary.MethodDefinition).%New()
		set tOnNew.Name = "%OnNew"
		set tOnNew.FormalSpec = ""
		set tOnNew.ReturnType = "%Status"
		set tOnNew.Internal = 1
		set tOnNew.ServerOnly = 1
		
		#define WriteLine(%c) do tExecute.Implementation.WriteLine($c(9)_%c)
		$$$WriteLine("set tSC = $$$OK, pOutput=""""")
		$$$WriteLine("try {")
		$$$WriteLine("	set tLastModelIndex = 0, tCount = 0")
		
		#define WriteLineON(%c) do tOnNew.Implementation.WriteLine($c(9)_%c)
		$$$WriteLineON("set tSC = $$$OK")
		$$$WriteLineON("try {")
		
		// BDB823
		set tSupportsSimpleMode = (tDefinition.Segmentation.multipleModelMethod'="modelChain")
		if tSupportsSimpleMode {
			$$$WriteLine("	set tSM = ..SimpleMode")
		}
		
		kill tOutputFields, tOutputFieldNames, tSegmentOutputs
		set tPredictedField = ..%GetPredictedFieldFromDef(tDefinition)
		if $isobject(tDefinition.Output) {
			for j = 1:1:tDefinition.Output.OutputFields.Count() {
				set tOutputField = tDefinition.Output.OutputFields.GetAt(j)
				if (tOutputField.segmentId'="") {
					if (tMethod="selectFirst") {
						set tSC = $$$ERROR($$$GeneralError, "OutputField segmentId attribute not supported when multipleModelMethod=""selectFirst""")
						quit
					}
					set tSegmentOutputs($i(tSegmentOutputs)) = tOutputField
					continue
				}
				set tPredicted = $s(tOutputField.targetField="":tPredictedField, 1:tOutputField.targetField)
				set tValue = $s(tOutputField.value="":$c(0), 1:tOutputField.value)
				set tOutputFields(0, tPredicted, tOutputField.feature, tValue) = tOutputField
			}
		} else {
			do ..%GetPredictedFieldsFromDef(tDefinition, .tAllFields)
			for i = 1:1:$g(tAllFields) {
				set tOutputFields(0, tAllFields(i), "predictedValue", $c(0)) = ""
			}
		}
		quit:$$$ISERR(tSC)
		set tParentPredictedField = tPredictedField // BDB827
		
		#dim tSegment As %DeepSee.PMML.Definition.Segment
		for i = 1:1:tDefinition.Segmentation.Segments.Count() {
			set tSegment = tDefinition.Segmentation.Segments.GetAt(i)
			set tSegmentId = $s(tSegment.id="":i, 1:$$$QUOTE(tSegment.id))
			set tSegmentIds(i) = tSegmentId, tSegmentIdsI(tSegmentId) = i
			set tNestedModel = tSegment.Model
			
			// derive meaningful model name
			if (tSegment.id'="") {
				set tModelName = tBaseModelName _ $tr($s($isvalidnum(tSegment.id):"S"_tSegment.id, 1:tSegment.id), ".","_")
			} elseif (tNestedModel.modelName'="") {
				set tModelName = tBaseModelName _ tNestedModel.modelName
			} else {
				set tModelName = tBaseModelName_"S"_i
			}
			
			// list output fields for this model
			set tPredictedFieldProb = ""
			if $isobject(tSegment.Model.Output) {
				set tPredictedField = $classmethod(tSegment.Model.%GetModelClass(), "%GetPredictedFieldFromDef", tSegment.Model)
				set:(tPredictedField="") tPredictedField = tParentPredictedField // BDB827
				set tPredictedFields(i) = tPredictedField
				for j = 1:1:tSegment.Model.Output.OutputFields.Count() {
					set tOutputField = tSegment.Model.Output.OutputFields.GetAt(j)
					if (tOutputField.segmentId'="") {
						set tSC = $$$ERROR($$$GeneralError, "OutputField segmentId attribute not supported for nested models")
						quit
					}
					set tPredicted = $s(tOutputField.targetField="":tPredictedField, 1:tOutputField.targetField)
					set tValue = $s(tOutputField.value="":$c(0), 1:tOutputField.value)
					set tOutputFields(i, tPredicted, tOutputField.feature, tValue) = tOutputField
					set tOutputFieldNames(i, tOutputField.name) = tOutputField
					set:(tOutputField.feature="probability")&&(tOutputField.value="") tPredictedFieldProb = tOutputField.name
				}
			} else {
				do $classmethod(tSegment.Model.%GetModelClass(), "%GetPredictedFieldsFromDef", tSegment.Model, .tAllFields)
				set:'$d(tAllFields) tAllFields=1,tAllFields(1)=tParentPredictedField // BDB827
				for j = 1:1:$g(tAllFields) {
					set tOutputFields(i, tAllFields(j), "predictedValue", $c(0)) = ""
					set tOutputFieldNames(i, tAllFields(j)) = ""
				}
				set (tPredictedField, tPredictedFields(i)) = $g(tAllFields(1))
			}
			quit:$$$ISERR(tSC)
			
			
			// if this is a model chain, ensure ModelInput class can be generated for
			// fields not in the DataDictionary
			if (tMethod="modelChain") && (i>1) {
				for j = 1:1:tSegment.Model.MiningSchema.MiningFields.Count() {
					set tInputField = tSegment.Model.MiningSchema.MiningFields.GetAt(j)
					continue:tInputField.usageType'=$$$PMMLusageTypeActive
					set tOutputField = "", tOutputFieldIndex = 0
					for k = i-1:-1:1 {
						if $d(tOutputFieldNames(k, tInputField.name), tOutputField) {
							set tOutputFieldIndex = k
							quit
						}
					}
					continue:'tOutputFieldIndex
					
					// we'll need to store some metadata so the ModelInput class can be generated
					set tPropName = $$$PROPERTYNAME(tInputField.name)
					continue:$d(%PMML("Fields", tPropName))
					kill tFieldInfo
					set tFieldInfo("datatype") = tOutputField.dataType
					set tFieldInfo("type") = ##class(%DeepSee.PMML.Datatype.DataType).GetClassname(tOutputField.dataType)
					set tFieldInfo("optype") = tOutputField.optype
					merge %PMML("Fields", tPropName) = tFieldInfo
				}
			}
			
			set tSC = ##class(%DeepSee.PMML.Generator).%CreateModelClasses(tNestedModel, .tModelName, .tModelClass, $e(tBaseModelName,1,*-1))
			quit:$$$ISERR(tSC)
			
			// BDB823 - preload model in %OnNew()
			$$$WriteLineON("	set ..SubModels("_$$$QUOTE(tSegmentId)_") = ##class("_tModelClass_").%New()")
			if (tDefinition.functionName="classification") && '("majorityVote,weightedMajorityVote,selectFirst,modelChain"[tMethod) {
				$$$WriteLineON("	set i%SubModels("_$$$QUOTE(tSegmentId)_").KeepAllClassProbabilities = 1")
			}
			
			// BDB823 - avoid pointless "if (1) {" condition
			if 'tSegment.Predicate.%IsA("%DeepSee.PMML.Definition.Util.True") {
				// write segment predicate
				$$$WriteLine("")
				if (tSegment.Predicate.%IsA("%DeepSee.PMML.Definition.Util.CompoundPredicate")) {
					set tSC = tSegment.Predicate.%WriteComputeCode("tPredicateValue", "pObservation", $c(9), tExecute.Implementation)
					quit:$$$ISERR(tSC)
					set tCondition = "tPredicateValue"
				} else {
					set tCondition = tSegment.Predicate.%GetComputeCode("pObservation")
				}
				$$$WriteLine("	if ("_tCondition_") {")
			}
			
			$$$WriteLine("		// Executing model for segment "_tSegmentId)
			
			// BDB823 check if simple mode still supported
			set tParamDef =  ##class(%Dictionary.ParameterDefinition).%OpenId(tModelClass_"||SUPPORTSSIMPLEMODE")
			set:'$isobject(tParamDef) tParamDef = ##class(%Dictionary.ParameterDefinition).%OpenId(tNestedModel.%GetModelClass()_"||SUPPORTSSIMPLEMODE")
			set tCurrentModelSupportsSimpleMode = $s($isobject(tParamDef):tParamDef.Default, 1:0)
			set:tSupportsSimpleMode tSupportsSimpleMode = tCurrentModelSupportsSimpleMode
			
			if tCurrentModelSupportsSimpleMode {
				$$$WriteLine("		set tLastModelIndex = "_i_", tSC = i%SubModels("_$$$QUOTE(tSegmentId)_").%ExecuteModel(.pObservation, .tOutput)")
			} else {
				$$$WriteLine("		set tLastModelIndex = "_i_", tSC = i%SubModels("_$$$QUOTE(tSegmentId)_").%ExecuteModel(pObservation, .tOutput)")
			}
			$$$WriteLine("		quit:$$$ISERR(tSC)")
			$$$WriteLine("")
			
			
			if (tMethod="selectFirst") {
				
				// translate last tOutput to pOutput
				$$$WriteLine("		if $isobject($g(tOutput)) {")
				$$$WriteLine("			set pOutput = $classmethod(..#OUTPUTCLASS, ""%New"")")
				set tPredictedField = ""
				for {
					set tPredictedField = $order(tOutputFields(0, tPredictedField))
					quit:tPredictedField=""
					set tFeature = ""
					for {
						set tFeature = $order(tOutputFields(0, tPredictedField, tFeature))
						quit:tFeature=""
						set tValue = ""
						for {
							set tValue = $order(tOutputFields(0, tPredictedField, tFeature, tValue), 1, tOutputField)
							quit:tValue=""
							
							set tField1 = $s($isobject(tOutputField):tOutputField.name, 1:tPredictedField)
							if $d(tOutputFields(i, tPredictedField, tFeature, tValue), tOutputField2) {
								set tField2 = $s($isobject(tOutputField2):tOutputField2.name, 1:tPredictedField)
								$$$WriteLine("			set pOutput."_$$$PROPERTYNAME(tField1)_" = tOutput."_$$$PROPERTYNAME(tField2))
							} elseif '$isobject(tOutputField) {
								// these are implied output fields, which we can ignore if no data is present
							} else {
								set tVariableName = $s('$d(tOutputFields(i, tPredictedField, "predictedValue", $c(0)),f):"", 1:"tOutput."_$$$PROPERTYNAME($s(f="":tPredictedField, 1:f.name)))
								if (tOutputField.feature = "transformedValue") {
									set pSupported = 1
									set tExprCode = tOutputField.Expression.%GetComputeCode(.tInline, tVariableName)
									if (tInline) {
										$$$WriteLine("			set pOutput."_$$$PROPERTYNAME(tOutputField.name)_" = "_tExprCode)
									} else {
										$$$WriteLine("			// compute code for transformedValue expression")
										$$$WriteLine("			set tValue = "_tVariableName_", tStatus = $s(tValue="""":""missing"", 1:""valid"")")
										$$$WriteLine("			"_tExprCode)
										set tExprCode = "tValue"
									}
									$$$WriteLine("			set pOutput."_$$$PROPERTYNAME(tOutputField.name)_" = "_tExprCode)
								} elseif (tOutputField.feature = "entityId") {
									$$$WriteLine("			set pOutput."_$$$PROPERTYNAME(tField1)_" = "_tSegmentId)
								} else {
									set tSC = $$$ERROR($$$GeneralError, "No mapping found for output field '"_tOutputField.name_"' from nested models with method='selectFirst'")
									quit
								}
							}
						}
						quit:$$$ISERR(tSC)
					}
					quit:$$$ISERR(tSC)
				}
				quit:$$$ISERR(tSC)
				$$$WriteLine("		}")
				$$$WriteLine("		quit  // multipleModelMethod=""selectFirst""")
				
				
			} elseif (tMethod="modelChain") {
				
				$$$WriteLine("		if $isobject($g(tOutput)) {")
				
				// append output to pObservation
				if $isobject(tSegment.Model.Output) {
					for j = 1:1:tSegment.Model.Output.OutputFields.Count() {
						set tOutputField = tSegment.Model.Output.OutputFields.GetAt(j)
						set tPropName = $$$PROPERTYNAME(tOutputField.name)
						$$$WriteLine("			set pObservation."_tPropName_" = tOutput."_tPropName)
						
						// also append a dummy property to the ModelInput object if it's unknown
						continue:$d(%PMML("Classes",pClass.Name,"input",tPropName))
						
						// BDB783 - delegate to generator class
						set tSC = ##class(%DeepSee.PMML.Generator).%AppendModelInputField(pClass, tModelInputClass, tPropName, tOutputField.dataType)
						quit:$$$ISERR(tSC)
					}
					quit:$$$ISERR(tSC)
				}
					
				$$$WriteLine("			set tOutputs("_tSegmentId_") = tOutput")
				$$$WriteLine("		}")
				
			} else {
				
				$$$WriteLine("		if $isobject($g(tOutput)) {")
				$$$WriteLine("			set tOutputs("_tSegmentId_") = tOutput, tPredictedValue = tOutput."_$$$PROPERTYNAME(tPredictedField))
				
				if (tMethod="majorityVote") {
					$$$WriteLine("			set:tPredictedValue'="""" tVotes(tPredictedValue) = $g(tVotes(tPredictedValue))+1")
					$$$WriteLine("			set:tPredictedValue'="""" tVotes(tPredictedValue, "_tSegmentId_") = """"")
				} elseif (tMethod="weightedMajorityVote") {
					$$$WriteLine("			set:tPredictedValue'="""" tVotes(tPredictedValue) = $g(tVotes(tPredictedValue)) + "_tSegment.weight)
					$$$WriteLine("			set:tPredictedValue'="""" tVotes(tPredictedValue, "_tSegmentId_") = """"")
					
				} elseif (tDefinition.functionName="classification") {
					
					if (tMethod="max") {
						if (tPredictedFieldProb'="") {
							$$$WriteLine("			set:tOutput."_$$$PROPERTYNAME(tPredictedFieldProb)_"'="""" tProb(tOutput."_$$$PROPERTYNAME(tPredictedFieldProb)_", "_tSegmentId_") = tOutput."_$$$PROPERTYNAME(tPredictedField))
						} else {
							$$$WriteLine("			set tSC = tOutput.%GetAllClassProbabilities(.tAllProbs)")
							$$$WriteLine("			quit:$$$ISERR(tSC)")
							$$$WriteLine("			for i = 1:1:$g(tAllProbs) {")
							$$$WriteLine("				continue:$li(tAllProbs(i),1)'=tOutput."_$$$PROPERTYNAME(tPredictedField))
							$$$WriteLine("				set tMaxProb($li(tAllProbs(i),2), "_tSegmentId_") = tOutput."_$$$PROPERTYNAME(tPredictedField))
							$$$WriteLine("			}")
						}
					}
					
				} else {
					
					// regression models
					if (tMethod="max") {
						$$$WriteLine("			set:tPredictedValue'="""" tValues(tPredictedValue, "_tSegmentId_")=""""")
					} elseif (tMethod="median") {
						$$$WriteLine("			set:tPredictedValue'="""" tValues(tPredictedValue) = $g(tValues(tPredictedValue))+1, tCount = tCount+1")
					} elseif (tMethod="weightedAverage") {
						$$$WriteLine("			set:tPredictedValue'="""" tValue = $g(tValue) + (tPredictedValue*"_tSegment.weight_"), tCount = tCount + "_tSegment.weight)
					} else {
						$$$WriteLine("			set:tPredictedValue'="""" tValue = $g(tValue) + tPredictedValue, tCount = tCount+1")
					}
				}
				
				// BDB740: for classification: we want to track probabilities irrespective of multiple model method
				// in order to fill in probabilities of the composite model
				if (tDefinition.functionName="classification") {
					// go through probs for each category in Output
					$$$WriteLine("			set tSC = tOutput.%GetAllClassProbabilities(.tAllProbs)")
					$$$WriteLine("			quit:$$$ISERR(tSC)")
					$$$WriteLine("			for i = 1:1:$g(tAllProbs) {")
					$$$WriteLine("				set tProb($li(tAllProbs(i),1), "_tSegmentId_") = "_$s(tMethod="weightedAverage":"$lb($li(tAllProbs(i),2),"_tSegment.weight_")", 1:"$li(tAllProbs(i),2)"))
					$$$WriteLine("			}")
				}
				$$$WriteLine("		}")
			}
			
			if 'tSegment.Predicate.%IsA("%DeepSee.PMML.Definition.Util.True") {
				$$$WriteLine("	}")
			}
		}
		quit:$$$ISERR(tSC)
		
		// BDB823
		set %PMML("Classes",$$$UPPER(pClass.Name),"simple") = tSupportsSimpleMode
		
		$$$WriteLine("")
		
		// now process tOutputs array
		if (tMethod="selectFirst") {
			// has been taken care of already
		} elseif (tMethod="modelChain") {
			
			// save tModelInputClass as some intermediate output may have been appended
			set tSC = tModelInputClass.%Save()
			quit:$$$ISERR(tSC)
			
			// translate last tOutput to pOutput
			$$$WriteLine("	if $isobject($g(tOutput)) {")
			$$$WriteLine("		set pOutput = $classmethod(..#OUTPUTCLASS, ""%New"")")
			
			// to be safe, we need mappings from all previous models until we arrive at one with a TRUE condition
			set tLastModelIndex = ""
			for {
				set tLastModelIndex = $order(tOutputFields(tLastModelIndex), -1)
				quit:'tLastModelIndex
				
				$$$WriteLine("		if (tLastModelIndex = "_tLastModelIndex_") { // segment ID: "_tSegmentIds(tLastModelIndex))
				set tPredictedField = ""
				for {
					set tPredictedField = $order(tOutputFields(0, tPredictedField))
					quit:tPredictedField=""
					set tFeature = ""
					for {
						set tFeature = $order(tOutputFields(0, tPredictedField, tFeature))
						quit:tFeature=""
						set tValue = ""
						for {
							set tValue = $order(tOutputFields(0, tPredictedField, tFeature, tValue), 1, tOutputField)
							quit:tValue=""
							
							set tField1 = $s($isobject(tOutputField):tOutputField.name, 1:tPredictedField)
							
							if $d(tOutputFields(tLastModelIndex, tPredictedField, tFeature, tValue), tOutputField2) {
								set tField2 = $s($isobject(tOutputField2):tOutputField2.name, 1:tPredictedField)
								$$$WriteLine("			set pOutput."_$$$PROPERTYNAME(tField1)_" = tOutputs("_tSegmentIds(tLastModelIndex)_")."_$$$PROPERTYNAME(tField2))
							} elseif '$isobject(tOutputField) {
								// these are implied output fields, which we can ignore if no data is present
							} else {
								set tVariableName = $s('$d(tOutputFields(i, tPredictedField, "predictedValue", $c(0)),f):"", 1:"tOutputs("_tSegmentIds(tLastModelIndex)_")."_$$$PROPERTYNAME($s(f="":tPredictedField, 1:f.name)))
								if (tOutputField.feature = "transformedValue") {
									set pSupported = 1
									set tExprCode = tOutputField.Expression.%GetComputeCode(.tInline, tVariableName)
									if (tInline) {
										$$$WriteLine("			set pOutput."_$$$PROPERTYNAME(tOutputField.name)_" = "_tExprCode)
									} else {
										$$$WriteLine("			// compute code for transformedValue expression")
										$$$WriteLine("			set tValue = "_tVariableName_", tStatus = $s(tValue="""":""missing"", 1:""valid"")")
										$$$WriteLine("			"_tExprCode)
										set tExprCode = "tValue"
									}
									$$$WriteLine("			set pOutput."_$$$PROPERTYNAME(tOutputField.name)_" = "_tExprCode)
								} elseif (tOutputField.feature="entityId") {
									$$$WriteLine("			set pOutput."_$$$PROPERTYNAME(tOutputField.name)_" = "_tSegmentIds(tLastModelIndex))
								} else {
									// we have to ignore this as it can be a model that wasn't intended to be the last one
								}
							}
						}
						quit:$$$ISERR(tSC)
					}
					quit:$$$ISERR(tSC)
				}
				quit:$$$ISERR(tSC)
				
				$$$WriteLine("			quit")
				$$$WriteLine("		}")
				
				// we can exit this loop if the corresponding model was certainly executed
				quit:tDefinition.Segmentation.Segments.GetAt(tLastModelIndex).Predicate.%IsA("%DeepSee.PMML.Definition.Util.True")
			}
			$$$WriteLine("	}")
			
		} elseif (tMethod="majorityVote") || (tMethod="weightedMajorityVote") {
			
			$$$WriteLine("	set tMaxVotes = 0, tTotalVotes = 0, tBestValue="""", tValue = """"")
			$$$WriteLine("	for {")
			$$$WriteLine("		set tValue = $order(tVotes(tValue),1,tVotes)")
			$$$WriteLine("		quit:tValue=""""")
			$$$WriteLine("		set:tVotes>tMaxVotes tBestValue = tValue, tMaxVotes = tVotes")
			$$$WriteLine("		set tTotalVotes = tTotalVotes + tVotes")
			$$$WriteLine("	}")
			
			set tSC = ..%PopulateOutputObject(tDefinition, tExecute.Implementation, "tBestValue")
			quit:$$$ISERR(tSC)
			
		} elseif (tDefinition.functionName="classification") {
			
			if (tMethod="max") {
				$$$WriteLine("	set tBestProb = $order(tMaxProb(""""),-1), tBestModel = $order(tMaxProb(tBestProb,""""),1,tBestValue)")
				
				// BDB740 - track probabilities
				if $d(tOutputFields(0, tPredictedField, "probability")) {
					$$$WriteLine("	set tSegmentId="""", tFinalProbs=0")
					$$$WriteLine("	for {")
					$$$WriteLine("		set tSegmentId = $order(tMaxProb(tBestProb,tSegmentId),1,tOutcome)")
					$$$WriteLine("		quit:tSegmentId=""""")
					$$$WriteLine("		set tFinalProbs=tFinalProbs+1, tValue=""""")
					$$$WriteLine("		for {")
					$$$WriteLine("			set tValue = $order(tProb(tValue))")
					$$$WriteLine("			quit:tValue=""""")
					$$$WriteLine("			set tFinalProbs(tValue) = $g(tFinalProbs(tValue))+$g(tProb(tValue,tSegmentId))")
					$$$WriteLine("		}")
					$$$WriteLine("	}")
				}
			} elseif (tMethod="median") {
				$$$WriteLine("	set tValue=""""")
				$$$WriteLine("	for {") 
				$$$WriteLine("		set tValue = $order(tProb(tValue))")
				$$$WriteLine("		quit:tValue=""""")
				$$$WriteLine("		kill v")
				$$$WriteLine("		s i = """", c=0 f { s i = $o(tProb(tValue, i),1,p)  q:i=""""  s v(p) = $g(v(p))+1, c=c+1 }")
				$$$WriteLine("		set t=0, h=c\2, odd=c#2, p=""""")
				$$$WriteLine("		for {")
				$$$WriteLine("			set p = $order(v(p),1,n)")
				$$$WriteLine("			quit:p=""""")
				$$$WriteLine("			set t = t+n")
				$$$WriteLine("			continue:t<h")
				$$$WriteLine("			if 'odd || (t>h) { set tMedian = p quit }")
				$$$WriteLine("			set tMedian = (p + $order(v(p)))/2")
				$$$WriteLine("			quit")
				$$$WriteLine("		}")
				$$$WriteLine("		set tMedians(tMedian,tValue)="""", tMedianInfo(tValue)=$lb(tMedian,odd)")
				$$$WriteLine("	}")
				$$$WriteLine("	set tBestProb = $order(tMedians(""""),-1), tBestValue = $order(tMedians(tBestProb,""""))")
				
				// BDB740 - track probabilities
				if $d(tOutputFields(0, tPredictedField, "probability")) {
					$$$WriteLine("	kill tSegments") 
					$$$WriteLine("	if (tBestProb'="""") { if '$lg(tMedianInfo(tBestValue),2) { // even")
					$$$WriteLine("		set tLowValue = $o(tMedians(tBestProb)), tHighValue = $o(tMedians(tBestProb,-1))")
					$$$WriteLine("		merge tSegments = tProb(tLowValue), tSegments = tProb(tHighValue)")
					$$$WriteLine("	} else { // odd")
					$$$WriteLine("		merge tSegments = tProb(tBestValue)")
					$$$WriteLine("	} }")
					$$$WriteLine("	set tSegmentId="""", tFinalProbs=0")
					$$$WriteLine("	for {")
					$$$WriteLine("		set tSegmentId = $order(tSegments(tSegmentId))")
					$$$WriteLine("		quit:tSegmentId=""""")
					$$$WriteLine("		set tFinalProbs=tFinalProbs+1, tValue=""""")
					$$$WriteLine("		for {")
					$$$WriteLine("			set tValue = $order(tProb(tValue))")
					$$$WriteLine("			quit:tValue=""""")
					$$$WriteLine("			set tFinalProbs(tValue) = $g(tFinalProbs(tValue))+$g(tProb(tValue,tSegmentId))")
					$$$WriteLine("		}")
					$$$WriteLine("	}")
				}
				
			} else {
				$$$WriteLine("	set tValue=""""")
				$$$WriteLine("	for {") 
				$$$WriteLine("		set tValue = $order(tProb(tValue))")
				$$$WriteLine("		quit:tValue=""""")
				$$$WriteLine("		set i = """", c=0, sum=0")
				$$$WriteLine("		for { s i = $o(tProb(tValue, i),1,p)  q:i=""""")
				if (tMethod="weightedAverage") {
					$$$WriteLine("			set sum = sum+($li(p,1)*$li(p,2)), c=c+$li(p,2)")
				} else {
					$$$WriteLine("			set sum = sum+p, c=c+1")
				}
				$$$WriteLine("		}")
				$$$WriteLine("		set:c tAvgProbs(sum/c,tValue)="""", tFinalProbs(tValue)=sum/c")
				$$$WriteLine("	}")
				$$$WriteLine("	set tBestProb = $order(tAvgProbs(""""),-1), tBestValue = $s(tBestProb'="""":$order(tAvgProbs(tBestProb,"""")), 1:"""")")
			}
			
			set tSC = ..%PopulateOutputObject(tDefinition, tExecute.Implementation, "tBestValue")
			quit:$$$ISERR(tSC)
			
		} else { // regression
		
			if (tMethod="max") {
				$$$WriteLine("	set tBestValue = $order(tValues(""""))")
			} elseif (tMethod="median") {
				$$$WriteLine("	set t = 0, h = tCount\2, e = tCount#2, tValue=""""")
				$$$WriteLine("	for {")
				$$$WriteLine("		set tValue = $order(tValues(tValue),1,n)")
				$$$WriteLine("		quit:tValue=""""")
				$$$WriteLine("		set t = t+n")
				$$$WriteLine("		continue:t<h")
				$$$WriteLine("		if 'e || (t>h) { set tBestValue = tValue quit }")
				$$$WriteLine("		set tBestValue = (tValue + $o(tValues(tValue)))/2")
				$$$WriteLine("		quit")
				$$$WriteLine("	}")
			} elseif (tMethod="sum") {
				$$$WriteLine("	set tBestValue = tValue")
			} else {
				$$$WriteLine("	set tBestValue = $s(tCount:tValue / tCount, 1:"""")")
			}
			
			set tSC = ..%PopulateOutputObject(tDefinition, tExecute.Implementation, "tBestValue")
			quit:$$$ISERR(tSC)
		}
		
		// now process additional segment outputs
		for i = 1:1:$g(tSegmentOutputs) {
			set tOutputField = tSegmentOutputs(i)
			set tModelIndex = tSegmentIdsI(tOutputField.segmentId)
			set tPredicted = $s(tOutputField.targetField="":tPredictedField(tModelIndex) , 1:tOutputField.targetField)
			set tValue = $s(tOutputField.value="":$c(0), 1:tOutputField.value)
			if '$d(tOutputFields(tModelIndex, tPredicted, tOutputField.feature, tValue), tOutputField2) {
				set tSC = $$$ERROR($$$GeneralError, "Could not find output field in nested model for '"_tOutputField.name_"'")
				quit
			}
			$$$WriteLine("	set pOutput."_$$$PROPERTYNAME(tOutputField.name)_" = tOutputs("_$$$QUOTE(tOutputField.segmentId)_")."_$$$PROPERTYNAME(tOutputField2.name))
		}
		
		$$$WriteLine("} catch (ex) {")
		$$$WriteLine("	set tSC = ex.AsStatus()")
		$$$WriteLine("}")
		$$$WriteLine("quit tSC")
		do pClass.Methods.Insert(tExecute)
		
		// BDB823
		$$$WriteLineON("} catch (ex) {")
		$$$WriteLineON("	set tSC = ex.AsStatus()")
		$$$WriteLineON("}")
		$$$WriteLineON("quit tSC")
		do pClass.Methods.Insert(tOnNew)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%OnGetOutputFeature">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pMethod:%Stream.Object,pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel,pOutputField:%DeepSee.PMML.Definition.OutputField,&pFeatureValueVar:%String,*pSupported:%Boolean]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#define WriteLine(%c) do pMethod.WriteLine($c(9,9)_%c)
	set pSupported = 0
	set tMethod = pDefinition.Segmentation.multipleModelMethod
	if (pOutputField.feature = "entityId") {
		if (tMethod="majorityVote") || (tMethod="weightedMajorityVote") {
			set pFeatureValueVar = "$order(tVotes(tBestValue, """"))", pSupported=1
		} elseif (pDefinition.functionName="classification") && (tMethod="max") {
			set pFeatureValueVar = "tBestModel", pSupported=1
		} elseif (pDefinition.functionName="regression") && (tMethod="max") {
			set pFeatureValueVar = "$order(tValues(tBestValue, """"))", pSupported=1
		}
	}
	
	// BDB740
	if (pOutputField.feature = "probability") && (pDefinition.functionName="classification") {
		set pSupported = 1
		// probability data is stored in
		// tProb("outcome", segmentID) = $s(tMethod="weightedAverage":$lb(probability,weight), 1:probability)
		if (pOutputField.segmentId'="") {
			if (pOutputField.value="") {
				$$$WriteLine("set "_pFeatureValueVar_" = $s(tBestValue="""":"""", 1:"_$s(tMethod="weightedAverage":"$lg($g(tProb(tBestValue,"_$$$QUOTE(pOutputField.segmentId)_")),1)",1:"$g(tProb(tBestValue,"_$$$QUOTE(pOutputField.segmentId)_"))"))
			} else {
				$$$WriteLine("set "_pFeatureValueVar_" = "_$s(tMethod="weightedAverage":"$lg($g(tProb("_$$$QUOTE(pOutputField.value)_","_$$$QUOTE(pOutputField.segmentId)_")),1)",1:"$g(tProb("_$$$QUOTE(pOutputField.value)_","_$$$QUOTE(pOutputField.segmentId)_")"))
			}
		} else {
			if (tMethod="majorityVote") || (tMethod="weightedMajorityVote") {
				if (pOutputField.value="") {
					$$$WriteLine("set "_pFeatureValueVar_" = $s(tBestValue="""":"""", tTotalVotes:$g(tVotes(tBestValue))/tTotalVotes, 1:"""")")
				} else {
					$$$WriteLine("set "_pFeatureValueVar_" = $s(tTotalVotes:$g(tVotes("_$$$QUOTE(pOutputField.value)_"))/tTotalVotes, 1:"""")")
				}
			} elseif (tMethod="max") || (tMethod="median") {
				if (pOutputField.value="") {
					$$$WriteLine("set "_pFeatureValueVar_" = $s(tBestValue="""":"""", tFinalProbs:$g(tFinalProbs(tBestValue))/tFinalProbs, 1:"""")")
				} else {
					$$$WriteLine("set "_pFeatureValueVar_" = $s(tFinalProbs:$g(tFinalProbs("_$$$QUOTE(pOutputField.value)_"))/tFinalProbs, 1:"""")")
				}
			} else {
				if (pOutputField.value="") {
					$$$WriteLine("set "_pFeatureValueVar_" = +tBestProb")
				} else {
					$$$WriteLine("set "_pFeatureValueVar_" = $g(tFinalProbs("_$$$QUOTE(pOutputField.value)_"))")
				}
			}
		}
	}
	
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Model.GeneralRegression">
<Copyright>/* Copyright (c) 2018 by InterSystems Corporation.
   Cambridge, Massachusetts, U.S.A.  All rights reserved.
   Confidential property of InterSystems Corporation. */</Copyright>
<Abstract>1</Abstract>
<Super>AbstractModel</Super>
<System>4</System>
<TimeCreated>62741,61530.568942</TimeCreated>

<Property name="Parameters">
<Description><![CDATA[
Based on <Parameters>
		..Parameters(paramName) = label]]></Description>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="PPMatrix">
<Description><![CDATA[
Based on <PPMatrix>
		..PPMatrix(paramName, predictorName) = value]]></Description>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="Predictors">
<Description><![CDATA[
Based on <FactorList> and <CovariateList>
		..Predictors(paramName) = [factor|covariate]]]></Description>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="ParamMatrix">
<Description><![CDATA[
Based on <ParamMatrix>
		..ParamMatrix(targetValue, paramName) = beta]]></Description>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="ContrastMatrices">
<Description>
..ContrastMatrices(predictor, row, col)</Description>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="TraceWeights">
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
</Property>

<Parameter name="TRACEWEIGHTTYPE">
<Default>add</Default>
</Parameter>

<Parameter name="SUPPORTSSIMPLEMODE">
<Internal>1</Internal>
<Default>1</Default>
</Parameter>

<Method name="CalculateXBeta">
<Abstract>1</Abstract>
<FormalSpec><![CDATA[&pObservation:%DeepSee.PMML.ModelInput,*pXBeta,*pBestTarget:%String="",*pBestScore:%Double="",pAddZero:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
</Method>

<Method name="%CreateModelClass">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%Dictionary.ClassDefinition,pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tDefinition As %DeepSee.PMML.Definition.Models.GeneralRegressionModel = pDefinition
	#define WriteLine(%m,%c) do %m.Implementation.WriteLine($c(9)_%c)
	
	set tSC = $$$OK
	try {
		set tXBeta = ##class(%Dictionary.MethodDefinition).%New()
		set tXBeta.Name = "CalculateXBeta"
		set tXBeta.Internal = 1
		set tXBeta.FormalSpec = "&pObservation:%DeepSee.PMML.ModelInput,*pXBeta,*pBestTarget:%String="""",*pBestScore:%Double="""",pAddZero:%String="""""
		set tXBeta.ReturnType = "%Status"
		
		$$$WriteLine(tXBeta,"kill pXBeta")
		$$$WriteLine(tXBeta,"set tSC = $$$OK")
		$$$WriteLine(tXBeta,"try {")
		if '$g(%PMML("DisableTracing")) { 
			$$$WriteLine(tXBeta,"	set tTrace = ..Tracing")
			$$$WriteLine(tXBeta,"	kill:tTrace ..TraceWeights")
		}
		
		// populate tPredictors")
		set tHasContrast = 0
		if $isobject(tDefinition.FactorList) {
			#dim tPredictor As %DeepSee.PMML.Definition.Models.GeneralRegression.Predictor
			for i = 1:1:tDefinition.FactorList.Predictors.Count() {
				set tPredictor = tDefinition.FactorList.Predictors.GetAt(i)
				set tPredictors(tPredictor.name) = "factor"
				
				if $isobject(tPredictor.ContrastMatrix) {
					kill tIndices
					if $isobject(tPredictor.Categories) {
						for j = 1:1:tPredictor.Categories.Categories.Count() {
							set tIndices(j) = tPredictor.Categories.Categories.GetAt(j).value
						}
					} else {
						// TODO: verify!
						set tDataField = $g(%PMML("Fields",$$$PROPERTYNAME(tPredictor.name),"object"))
						for k = 1:1:tDataField.Values.Count() {
							set tIndices(k) = tDataField.Values.GetAt(k).value
						}
					}
					set tSC = tPredictor.ContrastMatrix.ValuesAsArray(.tMatrix)
					quit:$$$ISERR(tSC)
					set tRow = ""
					for {
						set tRow = $order(tMatrix(tRow))
						quit:tRow=""
						set tRowIndex = $$$QUOTE(tIndices(tRow)), tCol = ""
						for {
							set tCol = $order(tMatrix(tRow,tCol),1,tValue)
							quit:tCol=""
							set tColIndex = $$$QUOTE(tIndices(tCol))
							set tHasContrast = 1
							$$$WriteLine(tXBeta,"	set tContrast("_$$$QUOTE(tPredictor.name)_", "_tRowIndex_", "_tColIndex_") = "_$$$QUOTE(tValue))
						}
					}
				}
			}
			quit:$$$ISERR(tSC)
		}
		if $isobject(tDefinition.CovariateList) {
			for i = 1:1:tDefinition.CovariateList.Predictors.Count() {
				set tPredictor = tDefinition.CovariateList.Predictors.GetAt(i)
				set tPredictors(tPredictor.name) = "covariate"
			}
		}
		
		// populate tParameters
		if $isobject(tDefinition.ParameterList) {
			for i = 1:1:tDefinition.ParameterList.Parameters.Count() {
				set tParameter = tDefinition.ParameterList.Parameters.GetAt(i)
				set tParameters(tParameter.name) = tParameter.label
				set tParamUse(tParameter.name) = 0
				set tParamRefPoint(tParameter.name) = tParameter.referencePoint
			}
		}
		
		// populate tPPMatrix
		if $isobject(tDefinition.PPMatrix) {
			for i = 1:1:tDefinition.PPMatrix.Cells.Count() {
				set tCell = tDefinition.PPMatrix.Cells.GetAt(i)
				set tPPMatrix(tCell.parameterName, tCell.predictorName) = tCell.value
				set tParamUse(tCell.parameterName) = $g(tParamUse(tCell.parameterName))+1
			}
		}
		
		// derive intercept: param with no PPMatrix use
		set tInterceptParam = ""
		for {
			set tInterceptParam = $order(tParamUse(tInterceptParam),1,tUses)
			quit:tInterceptParam=""
			quit:'tUses
		}
		
		// populate tParamMatrix
		set tRefPoint = 0, tTargetCategories = 0
		if $isobject(tDefinition.ParamMatrix) {
			for i = 1:1:tDefinition.ParamMatrix.Cells.Count() {
				set tCell = tDefinition.ParamMatrix.Cells.GetAt(i)
				set tTargetCategory = $s(tCell.targetCategory="":$c(0), 1:tCell.targetCategory)
				set:(tCell.targetCategory'="")&&'$d(tTargetCategories(tCell.targetCategory)) tTargetCategories=tTargetCategories+1, tTargetCategories(tCell.targetCategory) = tTargetCategories
				set tParamMatrix(tTargetCategory, tCell.parameterName) = tCell.beta
				
				// calculate reference point for CoxRegression
				set tRefPoint = tRefPoint + (tCell.beta * tParamRefPoint(tCell.parameterName))
			}
		}


		// load predictors into array
		$$$WriteLine(tXBeta,"	kill tObservation")
		$$$WriteLine(tXBeta,"	set tSM = i%SimpleMode")
		set tPredictor = ""
		for {
			set tPredictor = $order(tPredictors(tPredictor))
			quit:tPredictor=""
			$$$WriteLine(tXBeta,"	set tObservation("_$$$QUOTE(tPredictor)_") = "_$$$PropValue("pObservation",tPredictor))
		}
			
		$$$WriteLine(tXBeta,"	// construct vector X")
		$$$WriteLine(tXBeta,"	kill tX")
		set tParam = ""
		for {
			set tParam = $order(tParameters(tParam))
			quit:tParam=""
			$$$WriteLine(tXBeta,"")
			if '$d(tPPMatrix(tParam)) { // intercept
				$$$WriteLine(tXBeta,"	set tX("_$$$QUOTE(tParam)_") = 1")
				if '$g(%PMML("DisableTracing")) { $$$WriteLine(tXBeta,"	set:tTrace tTrace(""t"", "_$$$QUOTE(tParam)_") = ""intercept""") }
			} else {
				kill tPredictorCounts
				$$$WriteLine(tXBeta,"	set tIsMatch = 1, tContrastFactor = 1"_$s($g(%PMML("DisableTracing")):"",1:", tTracePredictors = """""))
				set tPredictor = ""
				for {
					set tPredictor = $order(tPPMatrix(tParam, tPredictor), 1, tValue)
					quit:tPredictor=""
					
					set tPredictorType = tPredictors(tPredictor)
					set tPredictorCounts(tPredictorType) = $g(tPredictorCounts(tPredictorType))+1
					continue:tPredictorType'="factor"
						
					// if there's a contrast matrix, use it, otherwise just check if the
					// input matches the value defined for this parameter
					$$$WriteLine(tXBeta,"	set tActualValue = "_$$$PropValue("pObservation",tPredictor))
					if tHasContrast {
						$$$WriteLine(tXBeta,"	set tContrastFactor = tContrastFactor * $g(tContrast("_$$$QUOTE(tPredictor)_", $s(tActualValue="""":$c(0), 1:tActualValue), "_$$$QUOTE(tValue)_"),1)")
					} else {
						$$$WriteLine(tXBeta,"	set:tIsMatch tIsMatch = (tActualValue="_$$$QUOTE(tValue)_")")
					}
						
					if '$g(%PMML("DisableTracing")) { $$$WriteLine(tXBeta,"	set:tTrace tTracePredictors = tTracePredictors _ $lb("_$$$QUOTE(tPredictor)_")") }
				}
					
				if '$g(tPredictorCounts("covariate")) {
					// only factors on this parameter row
					$$$WriteLine(tXBeta,"	set tX("_$$$QUOTE(tParam)_") = "_$s(tHasContrast:"tContrastFactor", 1:"tIsMatch"))
					if '$g(%PMML("DisableTracing")) { 
						$$$WriteLine(tXBeta,"	set:tTrace tTrace(""p"","_$$$QUOTE(tParam)_") = tTracePredictors")
						$$$WriteLine(tXBeta,"	set:tTrace tTrace(""t"","_$$$QUOTE(tParam)_") = ""factor""")
					}
				} else {
					$$$WriteLine(tXBeta,"	if tIsMatch {")
					set tPredictor="", tProduct = "tContrastFactor"
					for {
						set tPredictor = $order(tPPMatrix(tParam,tPredictor),1,tVal)
						quit:tPredictor=""
						continue:tPredictors(tPredictor)'="covariate"
						set tProduct = tProduct_" * (tObservation("_$$$QUOTE(tPredictor)_")**"_tVal_")"
					}
					$$$WriteLine(tXBeta,"		set tX("_$$$QUOTE(tParam)_") = "_tProduct)
					if '$g(%PMML("DisableTracing")) { 
						$$$WriteLine(tXBeta,"		set:tTrace tTrace(""p"","_$$$QUOTE(tParam)_") = tTracePredictors")
						$$$WriteLine(tXBeta,"		set:tTrace tTrace(""t"","_$$$QUOTE(tParam)_") = "_$$$QUOTE($s($g(tPredictorCounts("factor")):"mixed", 1:"covariate")))
					}
							
					$$$WriteLine(tXBeta,"	} else {")
					$$$WriteLine(tXBeta,"		set tX("_$$$QUOTE(tParam)_") = 0")
					$$$WriteLine(tXBeta,"	}")
				}
			}
		}
		
		$$$WriteLine(tXBeta,"")
		$$$WriteLine(tXBeta,"")
		$$$WriteLine(tXBeta,"	// now calculate Bk*Xi")
		$$$WriteLine(tXBeta,"	set pBestScore="""", pBestTarget=""""")
		set tTarget=""
		for {
			set tTarget = $order(tParamMatrix(tTarget))
			quit:tTarget=""
				
			$$$WriteLine(tXBeta,"	set tScore = 0")
			set tParam=""
			for {
				set tParam = $order(tParamMatrix(tTarget,tParam),1,tBeta)
				quit:tParam=""
				
				$$$WriteLine(tXBeta,"	set tContribution = ("_tBeta_" * tX("_$$$QUOTE(tParam)_")), tScore = tScore + tContribution")
				if '$g(%PMML("DisableTracing")) { 
					$$$WriteLine(tXBeta,"	set:tTrace&&tContribution i%TraceWeights=$g(i%TraceWeights)+1, i%TraceWeights("_$$$QUOTE(tTarget)_", -$zabs(tContribution), i%TraceWeights) = $lb($g(tTrace(""p"","_$$$QUOTE(tParam)_")),, tContribution, ""Parameter: '"_$s($d(tParameters(tParam),tLabel):tLabel, 1:tParam)_"' (""_$g(tTrace(""t"","_$$$QUOTE(tParam)_"))_"")"")")
				}
			}
			$$$WriteLine(tXBeta,"	set pXBeta("_$$$QUOTE(tTarget)_") = tScore")
			$$$WriteLine(tXBeta,"	set:(pBestScore="""")||(pBestScore<tScore) pBestScore = tScore, pBestTarget = "_$$$QUOTE(tTarget))
		}
		
		$$$WriteLine(tXBeta,"	if (pAddZero'="""") {")
		$$$WriteLine(tXBeta,"		set pXBeta(pAddZero) = 0")
		$$$WriteLine(tXBeta,"		set:(pBestScore="""")||(pBestScore<0) pBestScore = 0, pBestTarget = pAddZero")
		$$$WriteLine(tXBeta,"	}")
			
		$$$WriteLine(tXBeta,"} catch (ex) {")
		$$$WriteLine(tXBeta,"	set tSC = ex.AsStatus()")
		$$$WriteLine(tXBeta,"}")
		$$$WriteLine(tXBeta,"quit tSC")
		do pClass.Methods.Insert(tXBeta)
		
		
		/// Build %ExecuteModelInternal method
		set tExecute = ##class(%Dictionary.MethodDefinition).%New()
		set tExecute.Name = "%ExecuteModelInternal"
		set tExecute.FormalSpec = "&pObservation:%DeepSee.PMML.ModelInput,*pOutput:%DeepSee.PMML.ModelOutput"
		set tExecute.ReturnType = "%Status"
		set tExecute.Private = 1
		
		$$$WriteLine(tExecute,"set tSC = $$$OK")
		$$$WriteLine(tExecute,"try {")
		$$$WriteLine(tExecute,"	set tSimpleMode = i%SimpleMode")
		
		if (tDefinition.modelType = "multinomialLogistic") {
			set tTargetFieldName = $$$PROPERTYNAME(..%GetPredictedFieldFromDef(pDefinition))
			if (tDefinition.targetReferenceCategory'="") {
				set tAddZero = tDefinition.targetReferenceCategory
			} elseif '$d(%PMML("Fields", tTargetFieldName, "values")) {
				set tSC = $$$ERROR($$$GeneralError, "Multinomial logistic models should define all target field values")
				quit
			} else {
				merge tTargetCategories = %PMML("Fields", tTargetFieldName, "values") 
				set tPMCount = tDefinition.ParamMatrix.Cells.Count()
				for i = 1:1:tPMCount {
					set tTargetCategory = tDefinition.ParamMatrix.Cells.GetAt(i).targetCategory
					set:tTargetCategory="" tTargetCategory = $c(0)
					kill tTargetCategories(tTargetCategory)
				}
				// pick the remaining value
				set tAddZero = $order(tTargetCategories(""))
			}
			set tAddZero = $s(tAddZero=$c(0):"$c(0)", 1:$$$QUOTE(tAddZero))

			$$$WriteLine(tExecute,"	set tSC = ..CalculateXBeta(.pObservation, .tXBeta, .tBestTarget, .tBestScore, "_tAddZero_")")
			$$$WriteLine(tExecute,"	quit:$$$ISERR(tSC)")
			$$$WriteLine(tExecute,"")
	
		} elseif (tDefinition.modelType '= "CoxRegression") {
			
			$$$WriteLine(tExecute,"	set tSC = ..CalculateXBeta(.pObservation, .tXBeta, .tBestTarget, .tBestScore)")
			$$$WriteLine(tExecute,"	quit:$$$ISERR(tSC)")
			$$$WriteLine(tExecute,"")
		}
		
		/// Prepare outputs based on modelType
		set tPredictedValueVar = "tPredictedValue"
		if (tDefinition.modelType = "regression") {
			
			set tPredictedValueVar = "tBestScore"
			
		} elseif (tDefinition.modelType = "multinomialLogistic") {
			
			set tPredictedValueVar = "tBestTarget"
			
		} elseif (tDefinition.modelType = "generalLinear") {
			
			set tPredictedValueVar = "tBestScore"
			
		} elseif (tDefinition.modelType = "generalizedLinear") {
			
			set a = $s(tDefinition.offsetVariable'="":$$$PropValue("pObservation",tDefinition.offsetVariable), 1:tDefinition.offsetValue)
			set:a'="" a = " + "_a
			set tFormula = "$g(tXBeta($c(0)))"_a
			set tFormula = $$ApplyLinkFunction(tDefinition, tFormula, tDefinition.linkFunction)
			
			set b = $s(tDefinition.trialsVariable'="":$$$PropValue("pObservation",tDefinition.trialsVariable), 1:tDefinition.trialsValue)
			set:b'="" b = " * "_b
			set tFormula = "("_tFormula_")" _ b
			
			$$$WriteLine(tExecute,"	set tPredictedValue = "_tFormula)
			
		} elseif (tDefinition.modelType = "ordinalMultinomial") {
			
			if (tTargetCategories<=2) {
				
				// TODO: find first category in a reliable way!
				set tFirstCategory = $order(tTargetCategories(""))
				set tOtherCategory = $order(tTargetCategories(""),-1)
				
				// TODO: do we need the offsetVariable/Value here?
				set tFormula = $$ApplyLinkFunction(tDefinition, "$g(tXBeta($c(0)))", tDefinition.cumulativeLink)
				
				$$$WriteLine(tExecute,"	set tRegression = "_$$ApplyLinkFunction(tDefinition, "$g(tXBeta($c(0)))", tDefinition.cumulativeLink))
				$$$WriteLine(tExecute,"	set tProbabilities("_$$$QUOTE(tFirstCategory)_") = tRegression")
				$$$WriteLine(tExecute,"	set tProbabilities("_$$$QUOTE(tOtherCategory)_") = 1 - tRegression")
				$$$WriteLine(tExecute,"	set tPredictedValue = $s(tRegression>0.5:"_$$$QUOTE(tFirstCategory)_", 1:"_$$$QUOTE(tOtherCategory)_")")
				
			} else {
				
				$$$WriteLine(tExecute,"	set tTargetCategory = """", tCount=0, tPrevValue=0, tBestProb="""", tBestTarget=""""")
				$$$WriteLine(tExecute,"	for {")
				$$$WriteLine(tExecute,"		set tTargetCategory = $order(..ParamMatrix(tTargetCategory))")
				$$$WriteLine(tExecute,"		quit:tTargetCategory=""""")
				$$$WriteLine(tExecute,"		set tCount = tCount+1")
				$$$WriteLine(tExecute,"		if (tCount="_tTargetCategories_") {")
				$$$WriteLine(tExecute,"			set tProbability = 1 - tPrevValue")
				$$$WriteLine(tExecute,"		} else {")
				$$$WriteLine(tExecute,"			set tValue = $g(tXBeta($c(0))) + $g(..ParamMatrix("_$$$QUOTE(tInterceptParam)_"))")
				$$$WriteLine(tExecute,"			set tValue = "_$$ApplyLinkFunction(tDefinition, "tValue", tDefinition.cumulativeLink))
				$$$WriteLine(tExecute,"			if (tCount=1) {")
				$$$WriteLine(tExecute,"				set tProbability = tValue")
				$$$WriteLine(tExecute,"			} else {")
				$$$WriteLine(tExecute,"				set tProbability = tValue - tPrevValue")
				$$$WriteLine(tExecute,"			}")
				$$$WriteLine(tExecute,"			set tPrevValue = tValue")
				$$$WriteLine(tExecute,"		}")
				$$$WriteLine(tExecute,"		set:(tBestProb="""")||(tBestProb<tProbability) tBestProb = tProbability, tBestTarget = tTargetCategory")
				$$$WriteLine(tExecute,"		set tProbabilities(tTargetCategory) = tProbability")
				$$$WriteLine(tExecute,"	}")
				set tPredictedValueVar = "tBestTarget"
			}
			
			
		} elseif (tDefinition.modelType="CoxRegression") {
			
			$$$WriteLine(tExecute,"")
			$$$WriteLine(tExecute,"	// populate Baseline array")
			if (tDefinition.baselineStrataVariable'="") {
				for i = 1:1:tDefinition.BaseCumHazardTables.BaselineStratum.Count() {
					set tStratum = tDefinition.BaseCumHazardTables.BaselineStratum.GetAt(i)
					set tStratumValue = $s(tStratum.value="":$c(0), 1:tStratum.value)
					$$$WriteLine(tExecute,"	set tBaseCumHazardStratum("_$$$QUOTE(tStratumValue)_") = "_tStratum.maxTime)
					for j = 1:1:tStratum.Cells.Count() {
						set tCell = tStratum.Cells.GetAt(j)
						$$$WriteLine(tExecute,"	set tBaseCumHazardStratum("_$$$QUOTE(tStratumValue)_","_tCell.time_") = "_tCell.cumHazard)
					}
				}
				$$$WriteLine(tExecute,"")
				$$$WriteLine(tExecute,"	set tStratum = "_$$$PropValue("pObservation",tDefinition.baselineStrataVariable))
				$$$WriteLine(tExecute,"	set:tStratum="""" tStratum = $c(0)")
				$$$WriteLine(tExecute,"	if '$d(tBaseCumHazardStratum(tStratum)) {")
				$$$WriteLine(tExecute,"		set tHazard = """", tSurvival = """"")
				$$$WriteLine(tExecute,"		goto end")
				$$$WriteLine(tExecute,"	}")
				$$$WriteLine(tExecute,"	merge tBaseCumHazard = tBaseCumHazardStratum(tStratum)")
			} else {
				$$$WriteLine(tExecute,"	set tBaseCumHazard = "_tDefinition.BaseCumHazardTables.maxTime)
				for i = 1:1:tDefinition.BaseCumHazardTables.BaselineCells.Count() {
					set tCell = tDefinition.BaseCumHazardTables.BaselineCells.GetAt(i)
					$$$WriteLine(tExecute,"	set tBaseCumHazard("_tCell.time_") = "_tCell.cumHazard)
				}
			}
			$$$WriteLine(tExecute,"")
			if (tDefinition.startTimeVariable'="") { // TODO ???
				$$$WriteLine(tExecute,"	set tEndTime = "_$$$PropValue("pObservation",tDefinition.endTimeVariable)_" - "_$$$PropValue("pObservation",tDefinition.startTimeVariable))
			} else {
				$$$WriteLine(tExecute,"	set tEndTime = "_$$$PropValue("pObservation",tDefinition.endTimeVariable))
			}
			$$$WriteLine(tExecute,"	if (tEndTime < $order(tBaseCumHazard(""""))) {")
			$$$WriteLine(tExecute,"		set tHazard = 0, tSurvival = 1")
			$$$WriteLine(tExecute,"		goto end")
			$$$WriteLine(tExecute,"	} elseif (tEndTime > tBaseCumHazard) {")
			$$$WriteLine(tExecute,"		set tHazard = """", tSurvival = """"")
			$$$WriteLine(tExecute,"		goto end")
			$$$WriteLine(tExecute,"	} else {")
			$$$WriteLine(tExecute,"		set:'$d(tBaseCumHazard(tEndTime),tBaseHazard) tTime = $order(tBaseCumHazard(tEndTime),-1, tBaseHazard)")
			$$$WriteLine(tExecute,"		set tSC = ..CalculateXBeta(.pObservation,,, .tProduct)")
			$$$WriteLine(tExecute,"		quit:$$$ISERR(tSC)")
			$$$WriteLine(tExecute,"		set tHazard = tBaseHazard * $zexp(tProduct - "_tRefPoint_")")
			$$$WriteLine(tExecute,"		set tSurvival = $zexp(-tHazard)")
			$$$WriteLine(tExecute,"	}")
			$$$WriteLine(tExecute,"")
			set tPredictedValueVar = "tHazard" // TODO ???
		
			do tExecute.Implementation.WriteLine("end")
			
		} else {
			set tSC = $$$ERROR($$$GeneralError, "modelType '"_tDefinition.modelType_"' is not supported")
			quit
		}
		
		/// Populate Output object
		set tSC = ..%PopulateOutputObject(pDefinition, tExecute.Implementation, tPredictedValueVar)
		quit:$$$ISERR(tSC)
		
		
		/// Populate trace
		if '$g(%PMML("DisableTracing")) { 
			$$$WriteLine(tExecute,"")
			$$$WriteLine(tExecute,"	// populate Trace info")
			$$$WriteLine(tExecute,"	if ..Tracing {")
			$$$WriteLine(tExecute,"		kill tWeights")
			$$$WriteLine(tExecute,"		merge tWeights = ..TraceWeights($c(0))")
			if (tDefinition.modelType="multinomialLogistic") || (tDefinition.modelType="ordinalMultinomial") {
				$$$WriteLine(tExecute,"		merge:tBestTarget'="""" tWeights = ..TraceWeights(tBestTarget)")
			}
			$$$WriteLine(tExecute,"		set tSC = ..%PopulateTrace(.pOutput, .tWeights)")
			$$$WriteLine(tExecute,"		quit:$$$ISERR(tSC)")
			$$$WriteLine(tExecute,"	}")
		}
		
		
		// Populate %AllClassProbs
		if (tDefinition.functionName="classification") {
			$$$WriteLine(tExecute,"")
			$$$WriteLine(tExecute,"	// populate %AllClassProbs")
			$$$WriteLine(tExecute,"	if (i%KeepAllClassProbabilities) {")
			$$$WriteLine(tExecute,"		set tOutcome = """"")
			$$$WriteLine(tExecute,"		for {")
			$$$WriteLine(tExecute,"			set tOutcome = $order(tProbabilities(tOutcome),1,tProb)")
			$$$WriteLine(tExecute,"			quit:tOutcome=""""")
			$$$WriteLine(tExecute,"			set tAllClassProbs=$g(tAllClassProbs)+1, tAllClassProbs(tAllClassProbs) = $lb(tOutcome, tProb)")
			$$$WriteLine(tExecute,"		}")
			$$$WriteLine(tExecute,"		merge pOutput.%AllClassProbs = tAllClassProbs")
			$$$WriteLine(tExecute,"	}")
		}
		
		
		
		$$$WriteLine(tExecute,"} catch (ex) {")
		$$$WriteLine(tExecute,"	set tSC = ex.AsStatus()")
		$$$WriteLine(tExecute,"}")
		$$$WriteLine(tExecute,"quit tSC")
		
		do pClass.Methods.Insert(tExecute)
		set tExecute=""
		
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	
	quit tSC
	
ApplyLinkFunction(tDefinition, tFormula, tLinkFunction)
	if (tLinkFunction="cloglog") {
		set tFormula = "1 - $zexp(-$zexp("_tFormula_"))"
	} elseif (tLinkFunction="identity") {
		// identity function
	} elseif (tLinkFunction="log") {
		set tFormula = "$zexp("_tFormula_")"
	} elseif (tLinkFunction="logc") {
		set tFormula = "1-$zexp("_tFormula_")"
	} elseif (tLinkFunction="logit") {
		set tFormula = "1/(1 + $zexp(-("_tFormula_")))"
	} elseif (tLinkFunction="loglog") {
		set tFormula = "$zexp(-$zexp(-("_tFormula_")))"
	} elseif (tLinkFunction="negbin") {
		set c = tDefinition.distParameter
		set tFormula = "1/(c*($zexp(-("_tFormula_"))-1)"
	} elseif (tLinkFunction="oddspower") {
		set d = tDefinition.linkParameter
		set tFormula = $s(d=0:"1/(1+$zexp(-("_tFormula_")))", 1:"1/(1+(1+("_d_"*("_tFormula_")))**(-1/"_d_"))")
	} elseif (tLinkFunction="power") {
		set d = tDefinition.linkParameter
		set tFormula = $s(d=0:"$zexp("_tFormula_")", 1:"("_tFormula_")**(1/"_d_")")
	} elseif (tLinkFunction="cauchit") {
		set tFormula = "0.5 + $zarctan("_tFormula_")/$zpi)"
	} else {
		set tSC = $$$ERROR($$$GeneralError, "linkFunction = '"_tDefinition.linkFunction_"' not supported")
		quit
	}
	quit tFormula
]]></Implementation>
</Method>

<Method name="%GetPredictedFieldFromDef">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	quit:pDefinition.targetVariableName'="" pDefinition.targetVariableName
	quit ##super(pDefinition)
]]></Implementation>
</Method>

<Method name="%OnGetOutputFeature">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pMethod:%Stream.Object,pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel,pOutputField:%DeepSee.PMML.Definition.OutputField,&pFeatureValueVar:%String,*pSupported:%Boolean]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tDefinition As %DeepSee.PMML.Definition.Models.GeneralRegressionModel = pDefinition
	#define WriteLine(%c) do pMethod.WriteLine($c(9,9)_%c)
	
	set pSupported = 0
	if (tDefinition.modelType = "multinomialLogistic") && (pOutputField.feature = "probability") {
		
		set pSupported = 1
		$$$WriteLine("set rj = tXBeta("_$s(pOutputField.value="":"tBestTarget", 1:$$$QUOTE(pOutputField.value))_")")
		$$$WriteLine("set i="""", tReciprocal=0, tOverflow=0")
		$$$WriteLine("for {")
		$$$WriteLine("	set i = $order(tXBeta(i),1,ri)")
		$$$WriteLine("	quit:i=""""")
		$$$WriteLine("	set tDiff = (ri-rj)")
		$$$WriteLine("	if (tDiff>700) { set tOverflow = 1  quit }")
		$$$WriteLine("	set tReciprocal = tReciprocal + $zexp(tDiff)")
		$$$WriteLine("}")
		$$$WriteLine("set tProbability = $s(tOverflow:0, 1:1/tReciprocal)")
		set pFeatureValueVar = "tProbability"
		quit $$$OK
		
	} elseif (tDefinition.modelType = "ordinalMultinomial") && (pOutputField.feature = "probability") {
		
		set pSupported = 1
		set pFeatureValueVar = "tProbabilities("_$s(pOutputField.value="":"tBestTarget", 1:$$$QUOTE(pOutputField.value))_")"
		quit $$$OK
		
	}
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Model.NaiveBayes">
<Copyright>/* Copyright (c) 2018 by InterSystems Corporation.
   Cambridge, Massachusetts, U.S.A.  All rights reserved.
   Confidential property of InterSystems Corporation. */</Copyright>
<Abstract>1</Abstract>
<Super>AbstractModel</Super>
<System>4</System>
<TimeCreated>62774,35432.503856</TimeCreated>

<Property name="Counts">
<Description>
..Counts("targetValue") = total count for [targetValue]
..Counts("targetValue","fieldName") = total non-missing count for [field] with [targetValue]
..Counts("targetValue","fieldName","fieldValue") = count for [field]=[fieldValue] with [targetValue]</Description>
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="TraceWeights">
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
</Property>

<Parameter name="THRESHOLD">
<Type>INTEGER</Type>
</Parameter>

<Parameter name="TRACEWEIGHTTYPE">
<Default>multiply</Default>
</Parameter>

<Method name="%GetPredictedFieldFromDef">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	quit:pDefinition.BayesOutput.fieldName'="" pDefinition.BayesOutput.fieldName
	quit ##super(pDefinition)
]]></Implementation>
</Method>

<Method name="%CreateModelClass">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%Dictionary.ClassDefinition,pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tPair As %DeepSee.PMML.Definition.Models.NaiveBayes.PairCounts
	#dim tCount As %DeepSee.PMML.Definition.Models.NaiveBayes.TargetValueCount
	#dim tInput As %DeepSee.PMML.Definition.Models.NaiveBayes.BayesInput
	#dim tDefinition As %DeepSee.PMML.Definition.Models.NaiveBayesModel = pDefinition
	#define WriteLine(%m,%c) do %m.Implementation.WriteLine($c(9)_%c)
	
	set tSC = $$$OK
	try {
		
		// build arrays in %OnNew()
		set tConstructor = ##class(%Dictionary.MethodDefinition).%New()
		set tConstructor.Name = "%OnNew"
		set tConstructor.ServerOnly = 1
		set tConstructor.Private = 1
		set tConstructor.ReturnType = "%Status"
		
		$$$WriteLine(tConstructor,"// populating output counts")
		set tTotalCount = 0
		for i = 1:1:tDefinition.BayesOutput.TargetValueCounts.Counts.Count() {
			set tCount = tDefinition.BayesOutput.TargetValueCounts.Counts.GetAt(i)
			$$$WriteLine(tConstructor,"set i%Counts("_$$$QUOTE(tCount.value)_") = "_tCount.count)
			set tTotalCount = tTotalCount + tCount.count
		}
		$$$WriteLine(tConstructor,"set i%Counts = "_tTotalCount)
		$$$WriteLine(tConstructor,"")
		
		$$$WriteLine(tConstructor,"// populating input counts")
		for i = 1:1:tDefinition.BayesInputs.BayesInput.Count() {
			set tInput = tDefinition.BayesInputs.BayesInput.GetAt(i)
			set tField = $$$QUOTE(tInput.fieldName)
			kill tFieldTotals
			for j = 1:1:tInput.PairCounts.Count() {
				set tPair = tInput.PairCounts.GetAt(j)
				set tFieldValue = $$$QUOTE(tPair.value)
				for k = 1:1:tPair.TargetValueCounts.Counts.Count() {
					set tCount = tPair.TargetValueCounts.Counts.GetAt(k)
					set tValue = $$$QUOTE(tCount.value)
					$$$WriteLine(tConstructor,"set i%Counts("_tValue_","_tField_","_tFieldValue_") = "_tCount.count)
					set tFieldTotals(tValue) = $g(tFieldTotals(tValue)) + tCount.count
				}
			}
			set tValue=""
			for {
				set tValue = $order(tFieldTotals(tValue),1,tTotalCount)
				quit:tValue=""
				$$$WriteLine(tConstructor,"set i%Counts("_tValue_","_tField_") = "_tTotalCount)
			}
			$$$WriteLine(tConstructor,"")
		}
		$$$WriteLine(tConstructor,"quit $$$OK")
		do pClass.Methods.Insert(tConstructor)
		
		// add threshold parameter
		set tParam = ##class(%Dictionary.ParameterDefinition).%New()
		set tParam.Name = "THRESHOLD"
		set tParam.Default = tDefinition.threshold
		do pClass.Parameters.Insert(tParam)
		
		
		/// add %ExecuteModelInternal method
		set tExecute = ##class(%Dictionary.MethodDefinition).%New()
		set tExecute.Name = "%ExecuteModelInternal"
		set tExecute.FormalSpec = "pObservation:%DeepSee.PMML.ModelInput,*pOutput:%DeepSee.PMML.ModelOutput"
		set tExecute.ReturnType = "%Status"
		set tExecute.Private = 1
		
		$$$WriteLine(tExecute,"set tSC = $$$OK, pOutput=""""")
		$$$WriteLine(tExecute,"try {")
		$$$WriteLine(tExecute,"	set tSC = pObservation.%GetAsArray(.tData)")
		$$$WriteLine(tExecute,"	quit:$$$ISERR(tSC)")
		$$$WriteLine(tExecute,"")
		
		// BDB491 - process BayesInput DerivedField
		for i = 1:1:tDefinition.BayesInputs.BayesInput.Count() {
			set tBayesInput = tDefinition.BayesInputs.BayesInput.GetAt(i)
			if $isobject(tBayesInput.DerivedField) {
				$$$WriteLine(tExecute,"	// Discretization code for BayesInput field "_tBayesInput.fieldName)
				$$$WriteLine(tExecute,"	if $d(tData("_$$$QUOTE(tBayesInput.fieldName)_"), tOriginalValue) {")
				$$$WriteLine(tExecute,"		set tStatus = ""valid""")
				set tCode = tBayesInput.DerivedField.Expression.%GetComputeCode(.tInline,, "pObservation")
				if (tInline) {
					$$$WriteLine(tExecute,"		set tData("_$$$QUOTE(tBayesInput.fieldName)_") = "_tCode)
				} else {
					$$$WriteLine(tExecute,"		"_tCode)
					$$$WriteLine(tExecute,"		if (tStatus=""missing"") { kill tData("_$$$QUOTE(tBayesInput.fieldName)_") }")
					$$$WriteLine(tExecute,"		else { set tData("_$$$QUOTE(tBayesInput.fieldName)_") = tValue }")
				}
				$$$WriteLine(tExecute,"	}")
				$$$WriteLine(tExecute,"")
			}
		}
		
		$$$WriteLine(tExecute,"	set tSC = ..GetLikelihoods(.tData, .tLikelihoods)")
		$$$WriteLine(tExecute,"	quit:$$$ISERR(tSC)")
		
		$$$WriteLine(tExecute,"	set tOutcome = """", tBestLikelihood = """", tBestOutcome = """", tTotalLikelihood = 0")
		$$$WriteLine(tExecute,"	for {")
		$$$WriteLine(tExecute,"		set tOutcome = $order(tLikelihoods(tOutcome),1,tLikelihood)")
		$$$WriteLine(tExecute,"		quit:tOutcome=""""")
		$$$WriteLine(tExecute,"		set tTotalLikelihood = tTotalLikelihood + tLikelihood")
		$$$WriteLine(tExecute,"		set:(tBestLikelihood="""")||(tBestLikelihood<tLikelihood) tBestLikelihood=tLikelihood, tBestOutcome=tOutcome")
		$$$WriteLine(tExecute,"	}")
		//$$$WriteLine(tExecute,"	set pObservation."_$$$PROPERTYNAME(..%GetPredictedFieldFromDef(pDefinition))_" = tBestOutcome")
		$$$WriteLine(tExecute,"")
		
		/// Populate Output object
		set tSC = ..%PopulateOutputObject(pDefinition, tExecute.Implementation, "tBestOutcome")
		quit:$$$ISERR(tSC)
		
		/// Populate trace
		if '$g(%PMML("DisableTracing")) { 
			$$$WriteLine(tExecute,"")
			$$$WriteLine(tExecute,"	// populate Trace info")
			$$$WriteLine(tExecute,"	if ..Tracing {")
			$$$WriteLine(tExecute,"		kill tWeights")
			$$$WriteLine(tExecute,"		merge tWeights = ..TraceWeights(tBestOutcome)")
			$$$WriteLine(tExecute,"		set tSC = ..%PopulateTrace(.pOutput, .tWeights)")
			$$$WriteLine(tExecute,"		quit:$$$ISERR(tSC)")
			$$$WriteLine(tExecute,"	}")
		}
		
		
		// Populate %AllClassProbs
		if (tDefinition.functionName="classification") {
			$$$WriteLine(tExecute,"")
			$$$WriteLine(tExecute,"	// populate %AllClassProbs")
			$$$WriteLine(tExecute,"	if (i%KeepAllClassProbabilities && tTotalLikelihood) {")
			$$$WriteLine(tExecute,"		set tOutcome = """"")
			$$$WriteLine(tExecute,"		for {")
			$$$WriteLine(tExecute,"			set tOutcome = $order(tLikelihoods(tOutcome),1,tLikelihood)")
			$$$WriteLine(tExecute,"			quit:tOutcome=""""")
			$$$WriteLine(tExecute,"			set tAllClassProbs=$g(tAllClassProbs)+1, tAllClassProbs(tAllClassProbs) = $lb(tOutcome, tLikelihood / tTotalLikelihood)")
			$$$WriteLine(tExecute,"		}")
			$$$WriteLine(tExecute,"		merge pOutput.%AllClassProbs = tAllClassProbs")
			$$$WriteLine(tExecute,"	}")
		}
		
		$$$WriteLine(tExecute,"} catch (ex) {")
		$$$WriteLine(tExecute,"	set tSC = ex.AsStatus()")
		$$$WriteLine(tExecute,"}")
		$$$WriteLine(tExecute,"quit tSC")
		
		do pClass.Methods.Insert(tExecute)
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%OnGetOutputFeature">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pMethod:%Stream.Object,pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel,pOutputField:%DeepSee.PMML.Definition.OutputField,&pFeatureValueVar:%String,*pSupported:%Boolean]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#define WriteLine(%c) do pMethod.WriteLine($c(9,9)_%c)
	
	set pSupported = 0
	
	if (pOutputField.feature = "probability") {
		set pSupported = 1
		if (pOutputField.value="") {
			$$$WriteLine("set "_pFeatureValueVar_" = $s('tTotalLikelihood:"""", 1:$s(tBestOutcome="""":0, 1:$g(tLikelihoods(tBestOutcome))) / tTotalLikelihood)")
		} else {
			$$$WriteLine("set "_pFeatureValueVar_" = $s('tTotalLikelihood:"""", 1:$g(tLikelihoods("_$$$QUOTE(pOutputField.value)_")) / tTotalLikelihood)")
		}
	}
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="GetLikelihoods">
<Description>
Output: pLikelihoods(tOutputValue) = likelihood</Description>
<FormalSpec><![CDATA[&pObservation,*pLikelihoods]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		kill ..TraceWeights
		merge tCounts = ..Counts
		
		set tOutputValue = ""
		for {
			set tOutputValue = $order(tCounts(tOutputValue), 1, tTotalCount)
			quit:tOutputValue=""
			
			set pLikelihoods(tOutputValue) = tTotalCount
			set:i%Tracing tBase=tTotalCount/tCounts, i%TraceWeights=$g(i%TraceWeights)+1, i%TraceWeights(tOutputValue, -tBase, i%TraceWeights) = $lb("","",tBase,"Base probability for outcome")
			
			set tProp = ""
			for {
				set tProp = $order(tCounts(tOutputValue, tProp), 1, tFieldTotalCount)
				quit:tProp=""
				
				continue:'$d(pObservation(tProp), tObsPropValue)
			
				set tFieldValueCount = $g(tCounts(tOutputValue, tProp, tObsPropValue), 0)
				set tContribution = $s(tFieldValueCount: tFieldValueCount / tFieldTotalCount, 1:..#THRESHOLD)
				
				set pLikelihoods(tOutputValue) = $g(pLikelihoods(tOutputValue)) * tContribution
				
				set:i%Tracing i%TraceWeights=$g(i%TraceWeights)+1, i%TraceWeights(tOutputValue, -tContribution, i%TraceWeights) = $lb($lb(tProp),$lb(tObsPropValue),tContribution,"")
			}
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Model.NeuralNetwork">
<Abstract>1</Abstract>
<Super>AbstractModel</Super>
<System>4</System>
<TimeCreated>63126,58105.5583</TimeCreated>

<Method name="%CreateModelClass">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%Dictionary.ClassDefinition,pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		#dim tDefinition As %DeepSee.PMML.Definition.Models.NeuralNetwork = pDefinition
		
		
		/// Build %ExecuteModelInternal method
		set tExecute = ##class(%Dictionary.MethodDefinition).%New()
		set tExecute.Name = "%ExecuteModelInternal"
		set tExecute.FormalSpec = "pObservation:%DeepSee.PMML.ModelInput,*pOutput:%DeepSee.PMML.ModelOutput"
		set tExecute.ReturnType = "%Status"
		set tExecute.Private = 1
		do tExecute.Implementation.WriteLine("	set tSC = $$$OK")
		do tExecute.Implementation.WriteLine("	try {")
		#define WriteLine(%c) do tExecute.Implementation.WriteLine($c(9,9)_%c)
		
		$$$WriteLine("")
		$$$WriteLine("// Initialize inputs")
		for i = 1:1:tDefinition.NeuralInputs.numberOfInputs {
			#dim tInput As %DeepSee.PMML.Definition.Models.NeuralNetwork.NeuralInput = tDefinition.NeuralInputs.Inputs.GetAt(i)
			
			set tCode = tInput.DerivedField.Expression.%GetComputeCode(.tInline,, "pObservation")
			if (tInline) {
				$$$WriteLine("set tNeuron("_$$$QUOTE(tInput.id)_") = "_tCode)
			} else {
				$$$WriteLine(tCode)
				$$$WriteLine("set tNeuron("_$$$QUOTE(tInput.id)_") = tValue")
			}
			$$$WriteLine("")
		}
		
		for i = 1:1:tDefinition.numberOfLayers {
			#dim tLayer As %DeepSee.PMML.Definition.Models.NeuralNetwork.NeuralLayer = tDefinition.Layers.GetAt(i)
			set tNormalization = $s(tLayer.normalizationMethod="":tDefinition.normalizationMethod, 1:tLayer.normalizationMethod)
			set tFunction = $s(tLayer.activationFunction="":tDefinition.activationFunction, 1:tLayer.activationFunction)
			set tThreshold = $s(tLayer.threshold="":tDefinition.threshold, 1:tLayer.threshold)
			if (tFunction="radialBasis") {
				set tWidth = $s(tLayer.width="":tDefinition.width, 1:tLayer.width)
				set tAltitude = $s(tLayer.altitude="":tDefinition.altitude, 1:tLayer.altitude)
			}
			
			$$$WriteLine("")
			$$$WriteLine("// Processing layer "_i)
			
			if (tNormalization'="none") {
				$$$WriteLine("set tNormalizeSum = 0")
			}
			
			set tNeuronCount = tLayer.Neurons.Count()
			for j = 1:1:tNeuronCount {
				#dim tNeuron As %DeepSee.PMML.Definition.Models.NeuralNetwork.Neuron = tLayer.Neurons.GetAt(j)
				
				set tZ = ""
				for k = 1:1:tNeuron.Connections.Count() {
					#dim tConnection As %DeepSee.PMML.Definition.Models.NeuralNetwork.Connection = tNeuron.Connections.GetAt(k)
					if (tFunction = "radialBasis") {
						set tZ = tZ _ $s(k=1:"", 1:" + ") _ "((tNeuron("_$$$QUOTE(tConnection.from)_")-"_tConnection.weight_")**2)"
					} else {
						set tZ = tZ _ $s(k=1:"", 1:" + ") _ "("_tConnection.weight_" * tNeuron("_$$$QUOTE(tConnection.from)_"))"
					}
				}
				if (tFunction="radialBasis") {
					set tZ = "("_tZ_") / (2 * ("_$s(tNeuron.width="":tWidth, 1:tNeuron.width)_"**2))"
				} else {
					set:tNeuron.bias tZ = tZ _ " + " _ tNeuron.bias
				}
				
				if (tFunction = "threshold") {
					$$$WriteLine("set tNeuron("_$$$QUOTE(tNeuron.id)_") = (("_tZ_") > "_tThreshold_")")
				} elseif (tFunction = "logistic") {
					$$$WriteLine("set Z = "_tZ)
					$$$WriteLine("set tNeuron("_$$$QUOTE(tNeuron.id)_") = $s((-Z)>700:0, 1:1 / (1 + $zexp(-Z)))")
				} elseif (tFunction = "tanh") {
					$$$WriteLine("set tNeuron("_$$$QUOTE(tNeuron.id)_") = (1 - $zexp(-2*Z)) / (1 + $zexp(-2*Z))")
				} elseif (tFunction = "identity") {
					$$$WriteLine("set tNeuron("_$$$QUOTE(tNeuron.id)_") = "_tZ)
				} elseif (tFunction = "exponential") {
					$$$WriteLine("set tNeuron("_$$$QUOTE(tNeuron.id)_") = $zexp("_tZ_")")
				} elseif (tFunction = "reciprocal") {
					$$$WriteLine("set tNeuron("_$$$QUOTE(tNeuron.id)_") = 1/("_tZ_")")
				} elseif (tFunction = "square") {
					$$$WriteLine("set tNeuron("_$$$QUOTE(tNeuron.id)_") = ("_tZ_")**2")
				} elseif (tFunction = "Gauss") {
					$$$WriteLine("set tNeuron("_$$$QUOTE(tNeuron.id)_") = $zexp(-(("_tZ_")**2))")
				} elseif (tFunction = "sine") {
					$$$WriteLine("set tNeuron("_$$$QUOTE(tNeuron.id)_") = $zsin("_tZ_")")
				} elseif (tFunction = "cosine") {
					$$$WriteLine("set tNeuron("_$$$QUOTE(tNeuron.id)_") = $zcos("_tZ_")")
				} elseif (tFunction = "Elliott") {
					$$$WriteLine("set Z = "_tZ)
					$$$WriteLine("set tNeuron("_$$$QUOTE(tNeuron.id)_") = Z / (1 + $zabs(Z))")
				} elseif (tFunction = "arctan") {
					$$$WriteLine("set tNeuron("_$$$QUOTE(tNeuron.id)_") = 2 * $zarctan("_tZ_") / $zpi")
				} elseif (tFunction = "radialBasis") {
					set tNeuronAlt = $s(tNeuron.altitude="":tAltitude, 1:tNeuron.altitude)
					if (tNeuronAlt=1) {
						$$$WriteLine("set tNeuron("_$$$QUOTE(tNeuron.id)_") = $zexp(-("_tZ_"))")
					} else {
						$$$WriteLine("set tNeuron("_$$$QUOTE(tNeuron.id)_") = $zexp(("_tNeuron.Connections.Count()_" * $zlog("_tNeuronAlt_")) - ("_tZ_"))")
					}
				} else {
					set tSC = $$$ERROR($$$GeneralError, "Unknown activation fucntion: '"_tFunction_"'")
					quit
				}
				
				continue:tNormalization="none"
				$$$WriteLine("set tNormalizeSum = tNormalizeSum + "_$s(tNormalization="simplemax":"tNeuron("_$$$QUOTE(tNeuron.id)_")", 1:"$zexp(tNeuron("_$$$QUOTE(tNeuron.id)_"))"))
			}
			quit:$$$ISERR(tSC)
			
			
			continue:tNormalization="none"
			for j = 1:1:tNeuronCount {
				set tNeuronID = $$$QUOTE(tLayer.Neurons.GetAt(j).id)
				$$$WriteLine("set tNeuronProb("_tNeuronID_") = $s('tNormalizeSum:0, 1:"_$s(tNormalization="simplemax":"tNeuron("_tNeuronID_")", 1:"$zexp(tNeuron("_tNeuronID_"))")_" / tNormalizeSum)")
			}
			
		}
		quit:$$$ISERR(tSC)
		$$$WriteLine("")
		
		
		// now process NeuralOutputs
		set tPredicted = ..%GetPredictedFieldFromDef(tDefinition)
		#dim tNOutput As %DeepSee.PMML.Definition.Models.NeuralNetwork.NeuralOutput
		$$$WriteLine("// Process NeuralOutput elements")
		if (tDefinition.functionName="regression") {
			
			for i = 1:1:tDefinition.NeuralOutputs.numberOfOutputs {
				
				set tNOutput = tDefinition.NeuralOutputs.Outputs.GetAt(i)
				#dim tNormCont As %DeepSee.PMML.Definition.Util.NormContinuous = tNOutput.DerivedField.Expression
				if ('tNormCont.%IsA("%DeepSee.PMML.Definition.Util.NormContinuous")) {
					set tSC = $$$ERROR($$$GeneralError, "Unsupported DerivedField expression type for regression model: '"_$classname(tNormCont)_"'")
					quit
				}
				
				// now construct inverse NormContinuous code (assuming outliers="asIs")
				set tSegmentCount = tNormCont.LinearNorms.Count()
				set tIsAscending = (tNormCont.LinearNorms.GetAt(2).norm > tNormCont.LinearNorms.GetAt(1).norm)
				for j = 2:1:tSegmentCount {
					set tStart = tNormCont.LinearNorms.GetAt(j-1)
					set tEnd = tNormCont.LinearNorms.GetAt(j)
					if (j=tSegmentCount) {
						$$$WriteLine("} else {")
					} else {
						$$$WriteLine($s(j=2:"", 1:"} else")_"if (tNeuron("_$$$QUOTE(tNOutput.outputNeuron)_") "_$s(tIsAscending:"<=", 1:">=")_" "_tEnd.norm_") {")
					}
					set tField = $s(tNormCont.field'="":tNormCont.field, 1:tPredicted)
					$$$WriteLine("	set tDenormalized("_$$$QUOTE(tField)_") = ((tNeuron("_$$$QUOTE(tNOutput.outputNeuron)_")-"_tStart.norm_") * "_((tEnd.orig-tStart.orig)/(tEnd.norm-tStart.norm))_") + "_tStart.orig_"")
				}
				$$$WriteLine("}")
			}
			quit:$$$ISERR(tSC)
			
			
		} elseif (tDefinition.functionName="classification") {
			
			for i = 1:1:tDefinition.NeuralOutputs.numberOfOutputs {
				
				set tNOutput = tDefinition.NeuralOutputs.Outputs.GetAt(i)
				#dim tNormDiscr As %DeepSee.PMML.Definition.Util.NormDiscrete = tNOutput.DerivedField.Expression
				if ('tNormDiscr.%IsA("%DeepSee.PMML.Definition.Util.NormDiscrete")) {
					set tSC = $$$ERROR($$$GeneralError, "Unsupported DerivedField expression type for classification model: '"_$classname(tNormDiscr)_"'")
					quit
				}
				set tField = $s(tNormDiscr.field'="":tNormDiscr.field, 1:tPredicted)
				$$$WriteLine("set:'$d(tDenormalized("_$$$QUOTE(tField)_", "_$$$QUOTE(tNormDiscr.value)_")) tDenormalized("_$$$QUOTE(tField)_", "_$$$QUOTE(tNormDiscr.value)_") = "_$$$QUOTE(tNOutput.outputNeuron))
				$$$WriteLine("if '$d(tBestScore("_$$$QUOTE(tField)_"), tCurrentScore) || (tNeuron("_$$$QUOTE(tNOutput.outputNeuron)_") > tCurrentScore) {")
				$$$WriteLine("	set tDenormalized("_$$$QUOTE(tField)_") = "_$$$QUOTE(tNormDiscr.value)_", tBestScore("_$$$QUOTE(tField)_") = tNeuron("_$$$QUOTE(tNOutput.outputNeuron)_")")
				$$$WriteLine("}")
			}
			quit:$$$ISERR(tSC)
		} else {
			set tSC = $$$ERROR($$$GeneralError, "NeuralNetwork output processing only supported when functionName is 'regression' or 'classification'")
			quit
		}
		
		
		$$$WriteLine("")
		set tSC = ..%PopulateOutputObject(pDefinition, tExecute.Implementation, "tDenormalized("_$$$QUOTE(tPredicted)_")")
		quit:$$$ISERR(tSC)
		
		
		do tExecute.Implementation.WriteLine("	} catch (ex) {")
		do tExecute.Implementation.WriteLine("		set tSC = ex.AsStatus()")
		do tExecute.Implementation.WriteLine("	}")
		do tExecute.Implementation.WriteLine("	quit tSC")
		do pClass.Methods.Insert(tExecute)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%OnGetOutputFeature">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pMethod:%Stream.Object,pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel,pOutputField:%DeepSee.PMML.Definition.OutputField,&pFeatureValueVar:%String,*pSupported:%Boolean]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#define WriteLine(%c) do pMethod.WriteLine($c(9,9)_%c)
	
	set pSupported = 0
	
	if (pOutputField.feature = "probability") {
		set pSupported = 1
		if (pOutputField.targetField="") {
			set tField = ..%GetPredictedFieldFromDef(pDefinition)
		} else {
			set tField = pOutputField.targetField
		}
		if (pOutputField.value="") {
			set tValue = "tDenormalized("_$$$QUOTE(tField)_")"
		} else {
			set tValue = $$$QUOTE(pOutputField.value)
		}
		set pFeatureValueVar = "$g(tNeuronProb(tDenormalized("_$$$QUOTE(tField)_", "_tValue_")))"
	}
	
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Model.Regression">
<Copyright>/* Copyright (c) 2018 by InterSystems Corporation.
   Cambridge, Massachusetts, U.S.A.  All rights reserved.
   Confidential property of InterSystems Corporation. */</Copyright>
<Abstract>1</Abstract>
<Super>%DeepSee.PMML.Model.AbstractModel</Super>
<System>4</System>
<TimeCreated>62917,58674.543152</TimeCreated>

<Parameter name="TRACEWEIGHTTYPE">
<Type>STRING</Type>
<Default>add</Default>
</Parameter>

<Parameter name="SUPPORTSSIMPLEMODE">
<Type>BOOLEAN</Type>
<Internal>1</Internal>
<Default>1</Default>
</Parameter>

<Method name="%CreateModelClass">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%Dictionary.ClassDefinition,pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tDefinition As %DeepSee.PMML.Definition.Models.RegressionModel = pDefinition
	
	set tSC = $$$OK
	try {
		set tPredictedFieldName = ..%GetPredictedFieldFromDef(tDefinition)
		for i = 1:1:tDefinition.MiningSchema.MiningFields.Count() {
			if (tPredictedFieldName = tDefinition.MiningSchema.MiningFields.GetAt(i).name) {
				set tPredictedFieldOpType = tDefinition.MiningSchema.MiningFields.GetAt(i).optype
				quit
			}
		}
		if $g(tPredictedFieldOpType)="" {
			set tPredictedFieldOpType = $g(%PMML("Fields",$$$PROPERTYNAME(tPredictedFieldName),"optype"))
		}
		
		/// Build %ExecuteModelInternal method
		set tExecute = ##class(%Dictionary.MethodDefinition).%New()
		set tExecute.Name = "%ExecuteModelInternal"
		set tExecute.FormalSpec = "&pObservation:%DeepSee.PMML.ModelInput,*pOutput:%DeepSee.PMML.ModelOutput"
		set tExecute.ReturnType = "%Status"
		set tExecute.Private = 1
		do tExecute.Implementation.WriteLine("	set tSC = $$$OK")
		do tExecute.Implementation.WriteLine("	try {")
		set tTraceCode = 0
		
		#define WriteLine(%c) do tExecute.Implementation.WriteLine($c(9,9)_%c)
		#define CheckMissing(%p) if '$d(tCheckMissing(%p)) { $$$WriteLine("goto:"_$$$PropMissing("pObservation",%p)_" HasMissing")  set tCheckMissing(%p) = 1 }
		
		// BDB731
		$$$WriteLine("set tSM = i%SimpleMode")
		
		#dim tRegTable As %DeepSee.PMML.Definition.Models.Regression.RegressionTable
		set tMulti = (tDefinition.RegressionTables.Count()>1), tNullCat = ""
		for i = 1:1:tDefinition.RegressionTables.Count() {
			set tRegTable = tDefinition.RegressionTables.GetAt(i)
			
			set tCat = tRegTable.targetCategory, tCatIndex = $s(tCat="":"$c(0)", 1:$$$QUOTE(tCat))
			$$$WriteLine("")
			$$$WriteLine("// regression formula for target category '"_tCat_"'")
			set tLine = "set tRegValue = " _ tRegTable.intercept
			if '$g(%PMML("DisableTracing")) { 
				set:tRegTable.intercept tTraceCode=tTraceCode+1, tTraceCode(tTraceCode) = "set tWeights("_tCatIndex_", $lb(""Intercept"")) = $g(tWeights("_tCatIndex_", $lb(""Intercept""))) + "_tRegTable.intercept
			}
			
			for j = 1:1:tRegTable.NumericPredictors.Count() {
				set tNumPredictor = tRegTable.NumericPredictors.GetAt(j)
				$$$CheckMissing(tNumPredictor.name)
				set tFactor = "("_$$$PropValue("pObservation",tNumPredictor.name)_")"
				set:tNumPredictor.exponent'=1 tFactor = "(" _ tFactor _ "**" _ tNumPredictor.exponent _ ")"
				set tFactor = tNumPredictor.coefficient _ "*" _ tFactor
				set tLine = tLine _ " + (" _ tFactor _ ")"
				
				if '$g(%PMML("DisableTracing")) { 
					set tTraceCode=tTraceCode+1, tTraceCode(tTraceCode) = "set tWeights("_tCatIndex_", $lb("_$$$QUOTE(tNumPredictor.name)_")) = $g(tWeights("_tCatIndex_", $lb("_$$$QUOTE(tNumPredictor.name)_"))) + "_tFactor
				}
			}
			
			// group CategoricalPredictor elements into $case statements
			kill tCats
			for j = 1:1:tRegTable.CategoricalPredictors.Count() {
				set tCatPredictor = tRegTable.CategoricalPredictors.GetAt(j)
				set tCats(tCatPredictor.name, $s(tCatPredictor.value="":$c(0), 1:tCatPredictor.value)) = tCatPredictor.coefficient
			}
			set tPropName = ""
			for {
				set tPropName = $order(tCats(tPropName))
				quit:tPropName=""
				
				$$$CheckMissing(tPropName)
				
				set tFactor = "$case("_$$$PropValue("pObservation",tPropName), tValue = ""
				for {
					set tValue = $order(tCats(tPropName, tValue), 1, tCoefficient)
					quit:tValue=""
					set tFactor = tFactor _ ", " _ $$$QUOTE($s(tValue=$c(0):"", 1:tValue)) _ ":" _ tCoefficient
				}
				set tFactor = tFactor _ ", :0)"
				set tLine = tLine _ " + " _ tFactor
				
				if '$g(%PMML("DisableTracing")) { 
					set tTraceCode=tTraceCode+1, tTraceCode(tTraceCode) = "set tWeights("_tCatIndex_", $lb("_$$$QUOTE(tPropName)_")) = $g(tWeights("_tCatIndex_", $lb("_$$$QUOTE(tPropName)_"))) + "_tFactor
				}
			}
			
			for j = 1:1:tRegTable.PredictorTerms.Count() {
				set tPredictor = tRegTable.PredictorTerms.GetAt(j)
				set tFactor = "", tFieldNames = ""
				for k = 1:1:tPredictor.FieldRefs.Count() {
					set:k>1 tFactor = tFactor _ " * "
					set tFieldRef = tPredictor.FieldRefs.GetAt(k)
					if (tFieldRef.mapMissingTo'="") {
						set tFactor = tFactor _ "$s("_$$$PropMissing("pObservation",tFieldRef.field)_":"_tFieldRef.mapMissingTo_", 1:"_$$$PropValue("pObservation",tFieldRef.field)_")"
					} else {
						$$$CheckMissing(tFieldRef.field)
						set tFactor = tFactor _ $$$PropValue("pObservation",tFieldRef.field)
					}
					set tFieldNames = tFieldNames _ "," _ $$$QUOTE(tFieldRef.field)
				}
				set tLine = tLine _ " + (" _ tFactor _ ")"
				
				if '$g(%PMML("DisableTracing")) { 
					set tTraceCode=tTraceCode+1, tTraceCode(tTraceCode) = "set tWeights("_tCatIndex_", $lb("_$e(tFieldNames,2,*)_")) = $g(tWeights("_tCatIndex_", $lb("_$e(tFieldNames,2,*)_"))) + "_tFactor
				}
			}
			
			$$$WriteLine(tLine)
			
			if (tMulti) {
				$$$WriteLine("set tRegValues=tRegValues+1, tRegValues(tRegValues) = $lb("_tCatIndex_", tRegValue)")
				set:(tLine="set tRegValue = 0")&&(tPredictedFieldOpType="categorical") tNullCat = tCatIndex
			}
		}
		$$$WriteLine("")
		
		
		if (tMulti) {
			
			$$$WriteLine("// calculate probabilities based on normalizationMethod: "_tDefinition.normalizationMethod)
			if (tDefinition.normalizationMethod="softmax") {
				$$$WriteLine("set tNorm=0")
				$$$WriteLine("for i = 1:1:tRegValues {")
				$$$WriteLine("	set tNorm = tNorm + $zexp($li(tRegValues(i),2))")
				$$$WriteLine("}")
			}
			if (tPredictedFieldOpType="ordinal") {
				$$$WriteLine("set tPrevYValue=0")
			}
			
			if (tNullCat'="")||(tPredictedFieldOpType="ordinal") { $$$WriteLine("set tCumulativeProb = 0") }
			$$$WriteLine("for i = 1:1:tRegValues {")
			$$$WriteLine("	set tCat = $li(tRegValues(i),1), tValue = $li(tRegValues(i),2)")
			if (tPredictedFieldOpType="categorical") {
				if (tDefinition.normalizationMethod="none") {
					$$$WriteLine("	set tProb = tValue") // this is probably a pseudo-probability
				} elseif (tDefinition.normalizationMethod="softmax") {
					$$$WriteLine("	set tProb = $zexp(tValue) / tNorm")
				} elseif (tDefinition.normalizationMethod="logit") {
					$$$WriteLine("	set tProb = 1 / (1 + $zexp(-tValue))")
				} elseif (tDefinition.normalizationMethod="cloglog") {
					$$$WriteLine("	set tProb = 1 - $zexp(-$zexp(tValue))")
				} elseif (tDefinition.normalizationMethod="loglog") {
					$$$WriteLine("	set tProb = $zexp(-$zexp(-tValue))")
				} elseif (tDefinition.normalizationMethod="cauchit") {
					$$$WriteLine("	set tProb = 0.5 + ($zarctan(tValue) / $zpi)")
				} else {
					set tSC = $$$ERROR($$$NotImplemented)
					quit
				}
				if (tNullCat="") {
					$$$WriteLine("	set tProbabilities(tCat) = tProb, tSorted(-tProb, tCat) = """"")
				} else {
					$$$WriteLine("	if (tCat'="_tNullCat_") { ")
					$$$WriteLine("		set tProbabilities(tCat) = tProb, tSorted(-tProb, tCat) = """"")
					$$$WriteLine("		set tCumulativeProb = tCumulativeProb + tProb")
					$$$WriteLine("	}")
				}
			} else {
				if (tDefinition.normalizationMethod="softmax") {
					$$$WriteLine("	set tYValue = $zexp(tValue) / tNorm")
					$$$WriteLine("	set tProb = $s(i=1:tYValue, 1:tYValue-tPrevYValue), tPrevYValue = tYValue")
				} else {
					$$$WriteLine("	if (i=tRegValues) {")
					$$$WriteLine("		set tProb = 1-tCumulativeProb")
					$$$WriteLine("	} else {")
					if (tDefinition.normalizationMethod="logit") {
						$$$WriteLine("		set tYValue = 1 / (1 + $zexp(-tValue))")
					} elseif (tDefinition.normalizationMethod="cloglog") {
						$$$WriteLine("		set tYValue = 1 - $zexp(-$zexp(tValue))")
					} elseif (tDefinition.normalizationMethod="loglog") {
						$$$WriteLine("		set tYValue = $zexp(-$zexp(-tValue))")
					} elseif (tDefinition.normalizationMethod="cauchit") {
						$$$WriteLine("		set tYValue = 0.5 + ($zarctan(tValue) / $zpi)")
					} else {
						set tSC = $$$ERROR($$$NotImplemented)
						quit
					}
					$$$WriteLine("		set tProb = $s(i=1:tYValue, 1:tYValue-tPrevYValue), tPrevYValue = tYValue")
					$$$WriteLine("	}")
				}
				$$$WriteLine("	set tProbabilities(tCat) = tProb, tSorted(-tProb, tCat) = """"")
			}
			$$$WriteLine("}")
			if (tNullCat'="") { $$$WriteLine("set tProbabilities("_tNullCat_") = 1 - tCumulativeProb, tSorted(-(1-tCumulativeProb), "_tNullCat_") = """"") }
			$$$WriteLine("")
			
			$$$WriteLine("set tBestScore = $order(tSorted(""""))")
			$$$WriteLine("set tBestCat = $order(tSorted(tBestScore, """"))")
			set tPredictedValueVar = "tBestCat"
			
		} else {
			set tPredictedValueVar = "tRegValue"
		}
		
		set tSC = ..%PopulateOutputObject(pDefinition, tExecute.Implementation, tPredictedValueVar)
		quit:$$$ISERR(tSC)
		
		if '$g(%PMML("DisableTracing")) { 
			$$$WriteLine("")
			$$$WriteLine("if (..Tracing) {")
			$$$WriteLine("	kill tWeights")
			for i = 1:1:tTraceCode {
				$$$WriteLine("	"_tTraceCode(i))
			}
			$$$WriteLine("	set tFields = """"")
			$$$WriteLine("	for {") 
			$$$WriteLine("		set tFields = $order(tWeights("_$s(tMulti:tPredictedValueVar, 1:"$c(0)")_", tFields), 1, tWeight)")
			$$$WriteLine("		quit:tFields=""""")
			$$$WriteLine("		set tTraceWeights=$g(tTraceWeights)+1, tTraceWeights(-$zabs(tWeight), tTraceWeights) = $lb(tFields,, tWeight)")
			$$$WriteLine("	}")
			$$$WriteLine("	set tSC = ..%PopulateTrace(.pOutput, .tTraceWeights)")
			$$$WriteLine("	quit:$$$ISERR(tSC)")
			$$$WriteLine("}")
		}
		
		
		// Populate %AllClassProbs
		if (tDefinition.functionName="classification") {
			$$$WriteLine("")
			$$$WriteLine("// populate %AllClassProbs")
			$$$WriteLine("if (i%KeepAllClassProbabilities) {")
			$$$WriteLine("	set tOutcome = """"")
			$$$WriteLine("	for {")
			$$$WriteLine("		set tOutcome = $order(tProbabilities(tOutcome),1,tProb)")
			$$$WriteLine("		quit:tOutcome=""""")
			$$$WriteLine("		set tAllClassProbs=$g(tAllClassProbs)+1, tAllClassProbs(tAllClassProbs) = $lb(tOutcome, tProb)")
			$$$WriteLine("	}")
			$$$WriteLine("	merge pOutput.%AllClassProbs = tAllClassProbs")
			$$$WriteLine("}")
		}
		$$$WriteLine("quit")
		
		
		// missing value treatment
		$$$WriteLine("")
		do tExecute.Implementation.WriteLine("HasMissing")
		$$$WriteLine("// for missing values, just create an empty output object")
		$$$WriteLine("set pOutput = $classmethod(..#OUTPUTCLASS, ""%New"")")
		$$$WriteLine("")
		
		
		
		do tExecute.Implementation.WriteLine("	} catch (ex) {")
		do tExecute.Implementation.WriteLine("		set tSC = ex.AsStatus()")
		do tExecute.Implementation.WriteLine("	}")
		do tExecute.Implementation.WriteLine("	quit tSC")
		do pClass.Methods.Insert(tExecute)
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	
	quit tSC
]]></Implementation>
</Method>

<Method name="%OnGetOutputFeature">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pMethod:%Stream.Object,pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel,pOutputField:%DeepSee.PMML.Definition.OutputField,&pFeatureValueVar:%String,*pSupported:%Boolean]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tDefinition As %DeepSee.PMML.Definition.Models.GeneralRegressionModel = pDefinition
	#define WriteLine(%c) do pMethod.WriteLine($c(9,9)_%c)
	
	set pSupported = 0
	if (pOutputField.feature = "probability") && (pDefinition.functionName="classification") { // TODO: verify for non-multi cases
		
		set pSupported = 1
		set pFeatureValueVar = "tProbabilities("_$s(pOutputField.value="":"tBestCat", 1:$$$QUOTE(pOutputField.value))_")"
		quit $$$OK
		
	}
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Model.RuleSet">
<Copyright>/* Copyright (c) 2018 by InterSystems Corporation.
   Cambridge, Massachusetts, U.S.A.  All rights reserved.
   Confidential property of InterSystems Corporation. */</Copyright>
<Abstract>1</Abstract>
<Super>AbstractModel</Super>
<System>4</System>
<TimeCreated>63126,44638.81687</TimeCreated>

<Method name="%CreateModelClass">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%Dictionary.ClassDefinition,pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		#dim tDefinition As %DeepSee.PMML.Definition.Models.RuleSetModel = pDefinition
		
		
		/// Build %ExecuteModelInternal method
		set tExecute = ##class(%Dictionary.MethodDefinition).%New()
		set tExecute.Name = "%ExecuteModelInternal"
		set tExecute.FormalSpec = "pObservation:%DeepSee.PMML.ModelInput,*pOutput:%DeepSee.PMML.ModelOutput"
		set tExecute.ReturnType = "%Status"
		set tExecute.Private = 1
		do tExecute.Implementation.WriteLine("	set tSC = $$$OK")
		do tExecute.Implementation.WriteLine("	try {")
		#define WriteLine(%c) do tExecute.Implementation.WriteLine($c(9,9)_%c)
		if '$g(%PMML("DisableTracing")) { $$$WriteLine("set tTrace = ..Tracing") }
		
		set tRuleSelectionMethod = tDefinition.RuleSet.RuleSelectionMethod.GetAt(1)
		
		set tSC = ..%WriteRules(tDefinition.RuleSet.Rules, tExecute.Implementation, tRuleSelectionMethod, $c(9,9))
		quit:$$$ISERR(tSC)
		
		$$$WriteLine("")
		if (tRuleSelectionMethod.criterion = "firstHit") {
			$$$WriteLine("set tScore = "_$$$QUOTE(tDefinition.RuleSet.defaultScore)_", tConfidence = "_$$$QUOTE(tDefinition.RuleSet.defaultConfidence)_", tRuleID = """"")
			do tExecute.Implementation.WriteLine("end")
		} else {
			$$$WriteLine("// resolve weighted score ("_tRuleSelectionMethod.criterion_")")
			$$$WriteLine("if '$d(tWeights) {")
			$$$WriteLine("	set tScore = "_$$$QUOTE(tDefinition.RuleSet.defaultScore)_", tConfidence = "_$$$QUOTE(tDefinition.RuleSet.defaultConfidence)_", tRuleID = """"")
			$$$WriteLine("} else {")
			
			if (tRuleSelectionMethod.criterion = "weightedSum") {
				$$$WriteLine("	set tScore = """", tBestScore = """", tBestWeight = """"")
				$$$WriteLine("	for {")
				$$$WriteLine("		set tScore = $order(tWeights(tScore), 1, tWeight)")
				$$$WriteLine("		quit:tScore=""""")
				$$$WriteLine("		continue:(tWeight<tBestWeight)")
				$$$WriteLine("		set tBestWeight = tWeight, tBestScore = tScore")
				$$$WriteLine("	}")
				$$$WriteLine("	set tScore = tBestScore, tConfidence = $s(tScore="""":"""", 1:tBestWeight / tRulesFiring(tScore))")
				$$$WriteLine("	set tID = """", tRuleID = """"")
				$$$WriteLine("	for {")
				$$$WriteLine("		set tID = $order(tRulesFiring(tScore,tID))")
				$$$WriteLine("		quit:tID=""""")
				$$$WriteLine("		set tRuleID = $s(tRuleID="""":"""", 1:tRuleID_"", "") _ tID")
				$$$WriteLine("	}")
			} else {
				$$$WriteLine("	set tBestWeight = $order(tWeights("""")), x = $order(tWeights(tBestWeight,""""), 1, tInfo)")
				$$$WriteLine("	set tRuleID = $li(tInfo,1), tScore = $li(tInfo,2), tConfidence = $li(tInfo,3)")
			}
			
			$$$WriteLine("}")
		}
		
		
		set tSC = ..%PopulateOutputObject(pDefinition, tExecute.Implementation, "tScore")
		quit:$$$ISERR(tSC)
		
		
		// append tracing info
		if '$g(%PMML("DisableTracing")) { 
			$$$WriteLine("")
			$$$WriteLine("	if (tTrace) {")
			$$$WriteLine("		set tSC = ..%PopulateTrace(.pOutput, .tTrace)")
			$$$WriteLine("		quit:$$$ISERR(tSC)")
			$$$WriteLine("	}")
		}
		
		
		do tExecute.Implementation.WriteLine("	} catch (ex) {")
		do tExecute.Implementation.WriteLine("		set tSC = ex.AsStatus()")
		do tExecute.Implementation.WriteLine("	}")
		do tExecute.Implementation.WriteLine("	quit tSC")
		do pClass.Methods.Insert(tExecute)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%WriteRules">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRules:%ListOfObjects,pStream:%Stream.Object,pRuleSelectionMethod:%DeepSee.PMML.Definition.Models.RuleSet.RuleSelectionMethod,pIndent:%String,pPrefix:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		#define WriteLine(%c) do pStream.WriteLine(pIndent_%c)
		#dim tRule As %DeepSee.PMML.Definition.Models.RuleSet.SimpleRule
		
		for i = 1:1:pRules.Count() {
			set tRule = pRules.GetAt(i)
			set tIsCompoundRule = (tRule.%IsA("%DeepSee.PMML.Definition.Models.RuleSet.CompoundRule")) 
			set tRuleID = $s(tIsCompoundRule||(tRule.id=""):pPrefix_$s(pPrefix="":"", 1:".")_i, 1:tRule.id)
			
			$$$WriteLine("")
			set tSC = tRule.Predicate.%WriteComputeCode("tRuleFires", "pObservation", pIndent, pStream)
			quit:$$$ISERR(tSC)
			$$$WriteLine("if (tRuleFires) {")
			
			
			// tracing: first transform the rule's condition into a field list and info
			if '$g(%PMML("DisableTracing")) { 
				do tRule.Predicate.%GetAsTree(.tTree)
				if $d(tTree) { // skip True and False conditions
					// derive condition (as string) and field list from tree
					set tInfo = ##class(%DeepSee.PMML.Utils.TreeBuilder).GetCondition(.tTree)
					set tFields = ##class(%DeepSee.PMML.Utils.TreeBuilder).GetFieldList(.tTree)
					if (pRuleSelectionMethod'="firstHit") && 'tIsCompoundRule {
						$$$WriteLine("	set:tTrace tTrace($i(tTrace),0) = $lb($lb("""_$lts(tFields,""",""")_"""),,"_tRule.weight_",""Rule "_tRuleID_": "_$replace(tInfo,"""","""""")_""")")
					} else {
						$$$WriteLine("	set:tTrace tTrace($i(tTrace),0) = $lb($lb("""_$lts(tFields,""",""")_"""),,,""Rule "_tRuleID_": "_$replace(tInfo,"""","""""")_""")")
					}
				}
			}
			
			if tIsCompoundRule {
				
				set tSC = ..%WriteRules(tRule.Rules, pStream, pRuleSelectionMethod, pIndent_$c(9), pPrefix_$s(pPrefix="":"", 1:".")_i)
				quit:$$$ISERR(tSC)
				
			} else {
				
				if (pRuleSelectionMethod.criterion="firstHit") {
					$$$WriteLine("	set tRuleID = "_$$$QUOTE(tRuleID)_", tScore = "_$$$QUOTE(tRule.score))
					$$$WriteLine("	goto end")
				} elseif (pRuleSelectionMethod.criterion="weightedSum") {
					$$$WriteLine("	set x = $i(tWeights("_$$$QUOTE(tRule.score)_"), "_tRule.weight_")")
					$$$WriteLine("	set x = $i(tRulesFiring("_$$$QUOTE(tRule.score)_"))")
					$$$WriteLine("	set tRulesFiring("_$$$QUOTE(tRule.score)_", "_$$$QUOTE(tRuleID)_") = "_tRule.weight)
				} elseif (pRuleSelectionMethod.criterion="weightedMax") {
					$$$WriteLine("	set tWeights("_tRule.weight_", $i(tWeights)) = $lb("_$$$QUOTE(tRuleID)_", "_$$$QUOTE(tRule.score)_", "_tRule.confidence_")")
				} else {
					set tSC = $$$ERROR($$$GeneralError, "Unknown RuleSelectionMethod criterion: '"_pRuleSelectionMethod.criterion_"'")
					quit
				}
			}
			
			$$$WriteLine("}")
		}
		
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%OnGetOutputFeature">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pMethod:%Stream.Object,pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel,pOutputField:%DeepSee.PMML.Definition.OutputField,&pFeatureValueVar:%String,*pSupported:%Boolean]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#define WriteLine(%c) do pMethod.WriteLine($c(9,9)_%c)
	set pSupported = 0
	
	if (pOutputField.feature = "probability") || ((pOutputField.feature="ruleValue") && (pOutputField.ruleFeature="confidence")) {
		if (pOutputField.value = "") {
			set pSupported = 1, pFeatureValueVar = "tConfidence"
		} else {
			// TODO
		}
	} elseif (pOutputField.feature = "entityId") || ((pOutputField.feature="ruleValue") && (pOutputField.ruleFeature="ruleId")) {
		set pSupported = 1, pFeatureValueVar = "tRuleID"
	}
	
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Model.SVM">
<Abstract>1</Abstract>
<Super>AbstractModel</Super>
<System>4</System>
<TimeCreated>62966,61478.786804</TimeCreated>

<Method name="%CreateModelClass">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%Dictionary.ClassDefinition,pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tDefinition As %DeepSee.PMML.Definition.Models.SupportVectorMachineModel = pDefinition
	
	set tSC = $$$OK
	try {
		
		/// Build %ExecuteModelInternal method
		set tExecute = ##class(%Dictionary.MethodDefinition).%New()
		set tExecute.Name = "%ExecuteModelInternal"
		set tExecute.FormalSpec = "pObservation:%DeepSee.PMML.ModelInput,*pOutput:%DeepSee.PMML.ModelOutput"
		set tExecute.ReturnType = "%Status"
		set tExecute.Private = 1
		do tExecute.Implementation.WriteLine("	set tSC = $$$OK")
		do tExecute.Implementation.WriteLine("	try {")
		#define WriteLine(%c) do tExecute.Implementation.WriteLine($c(9,9)_%c)
		
		set tOneAgainstAll = (tDefinition.classificationMethod = "OneAgainstAll")
		set tCoefficientsOnly = (tDefinition.svmRepresentation = "Coefficients")
		
		$$$WriteLine("// build input vector x")
		set tFieldCount = tDefinition.VectorDictionary.Fields.FieldRefs.Count()
		for i = 1:1:tFieldCount {
			set tFieldRef = tDefinition.VectorDictionary.Fields.FieldRefs.GetAt(i)
			$$$WriteLine("set x("_i_") = pObservation."_$$$PROPERTYNAME(tFieldRef.field))
		}
				
		if 'tCoefficientsOnly {
			$$$WriteLine("")
			$$$WriteLine("// build kernels")
			set tVectorCount = tDefinition.VectorDictionary.numberOfVectors
			for i = 1:1:tVectorCount {
				set tVector = tDefinition.VectorDictionary.Instances.GetAt(i)
				set tSC = tDefinition.KernelType.%GetKernelFormula(tVector, .tFormula)
				quit:$$$ISERR(tSC)
				$$$WriteLine("set tKernels("_$$$QUOTE(tVector.id)_") = "_tFormula)
			}
			quit:$$$ISERR(tSC)
		}
		
		
		$$$WriteLine("")
		#dim tSVM As %DeepSee.PMML.Definition.Models.SVM.SupportVectorMachine
		for i = 1:1:tDefinition.SVMs.Count() {
			set tSVM = tDefinition.SVMs.GetAt(i)
			$$$WriteLine("")
			$$$WriteLine("// SVM "_i_": "_tSVM.targetCategory_ $s('tOneAgainstAll:" vs "_tSVM.alternateTargetCategory, 1:""))
			
			set tFormula = ""
			for j = 1:1:tSVM.Coefficients.Coefficients.Count() {
				set tKernel = $s(tCoefficientsOnly:"x("_j_")", 1:"tKernels("_$$$QUOTE(tSVM.SupportVectors.Vectors.GetAt(j).vectorId)_")")
				set tFormula = tFormula _ " + (" _ tSVM.Coefficients.Coefficients.GetAt(j).value _ "*"_tKernel_")"
			}
			$$$WriteLine("set tScore = "_+tSVM.Coefficients.absoluteValue_tFormula)
				
			if tOneAgainstAll {
				$$$WriteLine("set tScores=$g(tScores)+1, tScores(tScore, tScores) = "_$$$QUOTE(tSVM.targetCategory))
			} else {
				set tThreshold = +$s(tSVM.threshold="":tDefinition.threshold, 1:tSVM.threshold)
				$$$WriteLine("set tPredictedClass = $s(tScore<"_+tThreshold_":"_$$$QUOTE(tSVM.targetCategory)_", 1:"_$$$QUOTE(tSVM.alternateTargetCategory)_")")
				$$$WriteLine("set tVotes(tPredictedClass) = $g(tVotes(tPredictedClass))+1, tVotes = tVotes(tPredictedClass), tScores = $g(tScores)+1, tScores(-tVotes, tScores) = tPredictedClass")
			}
		}
		quit:$$$ISERR(tSC)
		
		$$$WriteLine("")
		$$$WriteLine("")
		$$$WriteLine("// resolve scores")
		$$$WriteLine("set tBestScore = $order(tScores(""""))")
		$$$WriteLine("set x = $order(tScores(tBestScore, """"), 1, tBestCategory)")
		
		set tSC = ..%PopulateOutputObject(pDefinition, tExecute.Implementation, "tBestCategory")
		quit:$$$ISERR(tSC)
		
		
		do tExecute.Implementation.WriteLine("	} catch (ex) {")
		do tExecute.Implementation.WriteLine("		set tSC = ex.AsStatus()")
		do tExecute.Implementation.WriteLine("	}")
		do tExecute.Implementation.WriteLine("	quit tSC")
		do pClass.Methods.Insert(tExecute)
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Model.Text">
<Abstract>1</Abstract>
<Super>%DeepSee.PMML.Model.AbstractModel</Super>
<System>4</System>
<TimeCreated>62879,44024.377817</TimeCreated>

<Parameter name="DOCCOUNT">
<Type>INTEGER</Type>
</Parameter>

<Parameter name="TERMCOUNT">
<Type>INTEGER</Type>
</Parameter>

<Parameter name="TRACEWEIGHTTYPE">
<Default>add</Default>
</Parameter>

<Parameter name="SIMILARITYMETRIC">
<Type>STRING</Type>
</Parameter>

<Property name="Indexer">
<Type>%iKnow.Indexer</Type>
<Internal>1</Internal>
<Private>1</Private>
</Property>

<Property name="DocTermMatrix">
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="GetQueryVector">
<Description>
Returns a vector containing the weighed frequency values for the query terms,
using the information in this TextModel's Dictionary.</Description>
<Internal>1</Internal>
<Abstract>1</Abstract>
<FormalSpec>pInput:%DeepSee.PMML.ModelInput,*pVector</FormalSpec>
<ReturnType>%Status</ReturnType>
</Method>

<Method name="CreateOutput">
<Abstract>1</Abstract>
<FormalSpec>pDoc:%Integer,pScore:%Double,*pOutput:%DeepSee.PMML.ModelOutput</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
</Method>

<Method name="%CreateModelClass">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%Dictionary.ClassDefinition,pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#define WriteLine(%m,%c) do %m.Implementation.WriteLine($c(9)_%c)
	#dim tDefinition As %DeepSee.PMML.Definition.Models.TextModel = pDefinition
	set tSC = $$$OK
	try {
		set tDocCount = tDefinition.numberOfDocuments
		set tTermCount = tDefinition.numberOfTerms
		
		set tSC = tDefinition.DocumentTermMatrix.Matrix.ValuesAsArray(.tMatrix)
		quit:$$$ISERR(tSC)
		set tSC = tDefinition.Dictionary.Terms.ValuesAsArray(.tTerms)
		quit:$$$ISERR(tSC)
		
		set tParam = ##class(%Dictionary.ParameterDefinition).%New()
		set tParam.Name = "DOCCOUNT"
		set tParam.Default = tDocCount
		set tParam.Internal = 1
		do pClass.Parameters.Insert(tParam)
		
		set tParam = ##class(%Dictionary.ParameterDefinition).%New()
		set tParam.Name = "TERMCOUNT"
		set tParam.Default = tTermCount
		set tParam.Internal = 1
		do pClass.Parameters.Insert(tParam)
		set tParam=""
		
		set tParam = ##class(%Dictionary.ParameterDefinition).%New()
		set tParam.Name = "SIMILARITYMETRIC"
		set tParam.Default = tDefinition.Similarity.similarityType
		set tParam.Internal = 1
		do pClass.Parameters.Insert(tParam)
		set tParam=""
		
		
		// generate GetTermValue() implementation
		set tGTValue = ##class(%Dictionary.MethodDefinition).%New()
		set tGTValue.Name = "GetTermValue"
		set tGTValue.FormalSpec = "pTermId:%Integer"
		set tGTValue.ReturnType = "%String"
		set tGTValue.Internal = 1
		set tGTValue.ClassMethod = 1
		for i = 1:1:tTermCount {
			do tGTValue.Implementation.WriteLine("	quit:pTermId="_i_" "_$$$QUOTE(tTerms(i)))
		}
		do tGTValue.Implementation.WriteLine("	quit """"")
		do pClass.Methods.Insert(tGTValue)
		
		
		// generate GetQueryVector() implementation
		set tGQVector = ##class(%Dictionary.MethodDefinition).%New()
		set tGQVector.Name = "GetQueryVector"
		set tGQVector.FormalSpec = "pInput:%DeepSee.PMML.ModelInput,*pVector,*pNorm:%Double"
		set tGQVector.ReturnType = "%Status"
		set tGQVector.Internal = 1
		do tGQVector.Implementation.WriteLine("	set tSC = $$$OK")
		do tGQVector.Implementation.WriteLine("	try {")
		#define WriteLine(%c) do tGQVector.Implementation.WriteLine($c(9,9)_%c)
		$$$WriteLine("kill tFrequency")
		
		set tInputMap = ""
		for i = 1:1:tDefinition.Extension.Count() {
			set tExtension = tDefinition.Extension.GetAt(i)
			for j = 1:1:tExtension.iscExtensions.Count() {
				set tExtensionElem = tExtension.iscExtensions.GetAt(j)
				if (tExtensionElem.%IsA("%DeepSee.PMML.Definition.Extension.TextModelInput")) {
					set tInputMap = tExtensionElem
					quit
				}
			}
			quit:$isobject(tInputMap)
		}
		if $isobject(tInputMap) {
			set tSC = tInputMap.Fields.ValuesAsArray(.tInputFields)
			quit:$$$ISERR(tSC)
			if (tInputMap.inputType="text") {
				
				// line up terms of interest
				for i = 1:1:tTermCount {
					$$$WriteLine("set tTerms("_i_") = "_$$$QUOTE(tTerms(i)))
				}
				$$$WriteLine("")
				
				// concatenate input fields and then get frequencies from text
				$$$WriteLine("set tText = """"")
				for i = 1:1:tInputFields {
					$$$WriteLine("set tText = tText _ $s(tText="""":"""", 1:$c(13,10,13,10)) _ pInput."_$$$PROPERTYNAME(tInputFields(i)))
				}
				$$$WriteLine("")
				
				$$$WriteLine("set tSC = ..GetTermsFromText(tText, .tTerms, .tFrequency, "_$$$QUOTE(tInputMap.languages)_")")
				$$$WriteLine("quit:$$$ISERR(tSC)")
				
			} else {
		
				// if inputType="terms", simply map to input fields
				for i = 1:1:tInputFields {
					$$$WriteLine("set tFrequency("_i_") = pInput."_$$$PROPERTYNAME(tInputFields(i)))
				}
				
			}
		} else {
			
			// if no explicit input map is in place, simply use all active mining fields
			// in that order
			set tCounter = 0
			for i = 1:1:tDefinition.MiningSchema.MiningFields.Count() {
				set tField = tDefinition.MiningSchema.MiningFields.GetAt(i)
				continue:tField.usageType'=$$$PMMLusageTypeActive
				set tCounter = tCounter+1
				$$$WriteLine("set tFrequency("_tCounter_") = pInput."_$$$PROPERTYNAME(tField.name))
			}
				
		}
		
		$$$WriteLine("")
		
		// prepare to apply weights
		if (tDefinition.Normalization.localTermWeights="augmentedNormalizedTermFrequency") {
			// find tMaxFreq
			$$$WriteLine("set tMaxFreq = 0")
			$$$WriteLine("for i = 1:1:"_tTermCount_" { set:'tMaxFreq||(tMaxFreq<tFrequency(i)) tMaxFreq = tFrequency(i) }")
		}
		
		for i = 1:1:tTermCount {
		
			if (tDefinition.Normalization.localTermWeights = "termFrequency") {
				set tLocal = "$g(tFrequency("_i_"),0)"
			} elseif (tDefinition.Normalization.localTermWeights = "binary") {
				set tLocal = "(''$g(tFrequency("_i_"),0))"
			} elseif (tDefinition.Normalization.localTermWeights = "logarithmic") {
				set tLocal = "$zlog($g(tFrequency("_i_"),0)+1)"
			} elseif (tDefinition.Normalization.localTermWeights = "augmentedNormalizedTermFrequency") {
				set tLocal = "(0.5*((''$g(tFrequency("_i_"),0)) + ($g(tFrequency("_i_"),0)/tMaxFreq)))"
			}
		
			if (tDefinition.Normalization.globalTermWeights = "none") {
				set tGlobal = tLocal
			} elseif (tDefinition.Normalization.globalTermWeights = "inverseDocumentFrequency") {
				set tSpread = 0
				for j = 1:1:tDocCount { 
					set:$g(tMatrix(j,i),0) tSpread = tSpread+1
				}
				set tGlobal = $s(tSpread:$zlog(tDocCount/tSpread)_" * "_tLocal, 1:0)
			} elseif (tDefinition.Normalization.globalTermWeights = "GFIDF") {
				set tSC = $$$ERROR($$$NotImplemented)  quit // TODO
			} elseif (tDefinition.Normalization.globalTermWeights = "normal") {
				set tSC = $$$ERROR($$$NotImplemented)  quit // TODO
			} elseif (tDefinition.Normalization.globalTermWeights = "probabilisticInverse") {
				set tSpread = 0
				for j = 1:1:tDocCount { 
					set:$g(tMatrix(j,i),0) tSpread = tSpread+1
				}
				set tGlobal = $s(tSpread:$zlog((tDocCount - tSpread)/tSpread)_" * "_tLocal, 1:0)
			}
			
			$$$WriteLine("set pVector("_i_") = "_tGlobal)
			
		}
		quit:$$$ISERR(tSC)
		
		if (tDefinition.Similarity.similarityType="cosine") {
			$$$WriteLine("")
			$$$WriteLine("set pNorm = 0")
			$$$WriteLine("for i = 1:1:"_tTermCount_" { set pNorm = pNorm + ($g(pVector(i))**2) }")
			$$$WriteLine("set pNorm = $zsqr(pNorm)")
		}
		
		do tGQVector.Implementation.WriteLine("	} catch (ex) {")
		do tGQVector.Implementation.WriteLine("		set tSC = ex.AsStatus()")
		do tGQVector.Implementation.WriteLine("	}")
		do tGQVector.Implementation.WriteLine("	quit tSC")
		do pClass.Methods.Insert(tGQVector)
		set tGQVector=""
		
		
		// generate %OnNew() implementation, populating ..DocTermMatrix
		set tOnNew = ##class(%Dictionary.MethodDefinition).%New()
		set tOnNew.Name = "%OnNew"
		set tOnNew.ReturnType = "%Status"
		set tOnNew.Private = 1
		set tOnNew.ServerOnly = 1
		do tOnNew.Implementation.WriteLine("	set tSC = $$$OK")
		do tOnNew.Implementation.WriteLine("	try {")
		#define WriteLine(%c) do tOnNew.Implementation.WriteLine($c(9,9)_%c)
		
		if (tDefinition.Normalization.globalTermWeights = "inverseDocumentFrequency") || 
			(tDefinition.Normalization.globalTermWeights = "probabilisticInverse") {
			for i = 1:1:tDocCount {
				for j = 1:1:tTermCount {
					set tSpread(j) = $g(tSpread(j))+1
					set:$g(tMatrix(i,j)) x = tSpread(j)
				}
			}
		}
		
		for i = 1:1:tDocCount {
			
			if (tDefinition.Normalization.localTermWeights = "augmentedNormalizedTermFrequency") {
				set tMaxFreq = 0
				for j = 1:1:tTermCount {
					set:'tMaxFreq||(tMaxFreq<$g(tMatrix(i,j))) tMaxFreq = tMatrix(i,j)
				}
			}
			
			kill tWeight
			set tNormalize = 0
			for j = 1:1:tTermCount {
				
				// local term weight
				if (tDefinition.Normalization.localTermWeights = "termFrequency") {
					set tWeight(j) = $g(tMatrix(i,j),0)
				} elseif (tDefinition.Normalization.localTermWeights = "binary") {
					set tWeight(j) = ''$g(tMatrix(i,j),0)
				} elseif (tDefinition.Normalization.localTermWeights = "logarithmic") {
					set tWeight(j) = $zlog($g(tMatrix(i,j),0)+1)
				} elseif (tDefinition.Normalization.localTermWeights = "augmentedNormalizedTermFrequency") {
					set tWeight(j) = (0.5*((''$g(tMatrix(i,j),0)) + ($g(tMatrix(i,j),0)/tMaxFreq)))
				}
				continue:tWeight(j)=0
				
				// global term weight
				if (tDefinition.Normalization.globalTermWeights = "none") {
					// no extra weighting
				} elseif (tDefinition.Normalization.globalTermWeights = "inverseDocumentFrequency") {
					set tWeight(j) = tWeight(j) * $s($g(tSpread(j)):$zlog(tDocCount/tSpread(j)), 1:0)
				} elseif (tDefinition.Normalization.globalTermWeights = "GFIDF") {
					set tSC = $$$ERROR($$$NotImplemented)  quit // TODO
				} elseif (tDefinition.Normalization.globalTermWeights = "normal") {
					set tSC = $$$ERROR($$$NotImplemented)  quit // TODO
				} elseif (tDefinition.Normalization.globalTermWeights = "probabilisticInverse") {
					set tWeight(j) = tWeight(j) * $s($g(tSpread(j)):$zlog((tDocCount - tSpread(j))/tSpread(j)), 1:0)
				}
				
				// normalize
				set tNormalize = tNormalize + (tWeight(j)**2)
			}
			
			set tNormalize = $zsqr(tNormalize)
			$$$WriteLine("set i%DocTermMatrix("_i_") = "_tNormalize)
			
			for j = 1:1:tTermCount {
				set tWeight = tWeight(j)
				continue:'tWeight
				
				if (tDefinition.Normalization.documentNormalization = "cosine") {
					set tWeight = tWeight / tNormalize
				}
				
				$$$WriteLine("set i%DocTermMatrix("_i_","_j_") = "_tWeight)
			}
			quit:$$$ISERR(tSC)
		}
		quit:$$$ISERR(tSC)
		
		do tOnNew.Implementation.WriteLine("	} catch (ex) {")
		do tOnNew.Implementation.WriteLine("		set tSC = ex.AsStatus()")
		do tOnNew.Implementation.WriteLine("	}")
		do tOnNew.Implementation.WriteLine("	quit tSC")
		do pClass.Methods.Insert(tOnNew)
		set tOnNew=""
		
		
		
		// generate CreateOutput() implementation
		set tCOut = ##class(%Dictionary.MethodDefinition).%New()
		set tCOut.Name = "CreateOutput"
		set tCOut.FormalSpec = "pDoc:%Integer,pScore:%Double,*pOutput:%DeepSee.PMML.ModelOutput"
		set tCOut.ReturnType = "%Status"
		set tCOut.Private = 1
		do tCOut.Implementation.WriteLine("	set tSC = $$$OK")
		do tCOut.Implementation.WriteLine("	try {")
		#define WriteLine(%c) do tCOut.Implementation.WriteLine($c(9,9)_%c)
		
		for i = 1:1:tDocCount {
			set tDoc = tDefinition.Corpus.Documents.GetAt(i)
			$$$WriteLine("set tDocs("_i_") = $lb("_$$$QUOTE(tDoc.id)_","_$$$QUOTE(tDoc.name)_","_$$$QUOTE(tDoc.file)_")")
		}
		$$$WriteLine("set tBestDoc = $s(pDoc="""":"""", 1:$li(tDocs(pDoc),1))")
		
		set tSC = ..%PopulateOutputObject(pDefinition, tCOut.Implementation, "tBestDoc")
		quit:$$$ISERR(tSC)
		
		do tCOut.Implementation.WriteLine("	} catch (ex) {")
		do tCOut.Implementation.WriteLine("		set tSC = ex.AsStatus()")
		do tCOut.Implementation.WriteLine("	}")
		do tCOut.Implementation.WriteLine("	quit tSC")
		do pClass.Methods.Insert(tCOut)
		set tCOut=""
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%ExecuteModelInternal">
<FormalSpec>pInput:%DeepSee.PMML.ModelInput,*pOutput:%DeepSee.PMML.ModelOutput</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		// get weighted query vector
		set tSC = ..GetQueryVector(pInput, .tQueryVector, .tQueryNorm)
		quit:$$$ISERR(tSC)
		
		set tTrace = ..Tracing
		
		// multiply with doc term matrix
		merge tDocTermMatrix = ..DocTermMatrix
		set tDoc = ""
		for {
			set tDoc = $order(tDocTermMatrix(tDoc), 1, tDocNorm)
			quit:tDoc=""
			
			set tTerm = "", tDocTotal = 0
			for {
				set tTerm = $order(tDocTermMatrix(tDoc,tTerm),1,tWeight)
				quit:tTerm=""
				
				if (..#SIMILARITYMETRIC = "cosine") {
					set tContribution = (tWeight * tQueryVector(tTerm))
				} else {
					set tContribution = (tWeight - tQueryVector(tTerm))**2
				}
				set tDocTotal = tDocTotal + tContribution
				
				set:tTrace&&tContribution tTrace=$g(tTrace)+1, tTrace(tDoc, -tContribution, tTrace) = $lb($lb(..GetTermValue(tTerm)), /* ? */, tContribution, "")
			}
			continue:'tDocTotal
			
			if (..#SIMILARITYMETRIC="cosine") {
				continue:'(tQueryNorm&&tDocNorm)
				set tSimilarity = tDocTotal / (tQueryNorm * tDocNorm)
			} else {
				// for euclidian distance, we're looking for the *lowest* number
				set tSimilarity = -$zsqr(tDocTotal)
			}
			
			set tScores(-tSimilarity, tDoc) = ""
		}
		
		set tScore = $order(tScores(""))
		set tBestDoc = $s(tScore="":"", 1:$order(tScores(tScore,"")))
		
		set tSC = ..CreateOutput(tBestDoc, $zabs(tScore), .pOutput)
		quit:$$$ISERR(tSC)
		
		if ..Tracing && (tBestDoc'="") {
			kill tWeights
			merge tWeights = tTrace(tBestDoc)
			set tSC = ..%PopulateTrace(.pOutput, .tWeights)
			quit:$$$ISERR(tSC)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="GetTermsFromText">
<Internal>1</Internal>
<FormalSpec><![CDATA[pText:%String,&pTerms,*pFrequencies,pLanguages:%String="en"]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if '$isobject(..Indexer) {
			set ..Indexer = ##class(%iKnow.Indexer).%New()
			
			set tSC = ..Indexer.EnableMergeRelations()
			quit:$$$ISERR(tSC)
			set tSC = ..Indexer.DisableSummarizer()
			quit:$$$ISERR(tSC)
			
			set:pLanguages="" pLanguages = "en"
			set tLangCount = $length(pLanguages, ",")
			for i = 1:1:tLangCount {
				set tLang = $$$LOWER($zstrip($piece(pLanguages, ",", i),"<>W"))
				
		        set tSC = ..Indexer.LoadKnowledgebase(tLang, ##class(%iKnow.KB.Knowledgebase).GetByName(tLang))
		        quit:$$$ISERR(tSC)
		        
		        if (tLangCount > 1) {
			        set tSC = ..Indexer.LoadLanguagebase(tLang, ##class(%iKnow.LB.Languagebase).GetByName(tLang))
			        quit:$$$ISERR(tSC)
		        }
			}
			quit:$$$ISERR(tSC)
		}
		
		set tDirectInput = ##class(%DeepSee.PMML.Utils.iKnow.DirectInput).%New()
		
		set tSC = ..Indexer.BufferString(pText)
		quit:$$$ISERR(tSC)
		
		set tSC = ..Indexer.IndexBuffer(tDirectInput)
		quit:$$$ISERR(tSC)
		
		set tSC = ..Indexer.ClearBuffer()
		quit:$$$ISERR(tSC)
		
		set i = ""
		for {
			set i = $order(pTerms(i), 1, tTerm)
			quit:i=""
			
			set pFrequencies(i) = tDirectInput.GetFrequency(tTerm)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="GetTermValue">
<Internal>1</Internal>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTermId:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit ""
]]></Implementation>
</Method>

<Method name="%OnGetOutputFeature">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pMethod:%Stream.Object,pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel,pOutputField:%DeepSee.PMML.Definition.OutputField,&pFeatureValueVar:%String,*pSupported:%Boolean]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set pSupported = 0
	
	if (pOutputField.feature="predictedDisplayValue") {
		set pSupported = 1
		do pMethod.WriteLine("		set tBestDocName = $s(pDoc="""":"""", 1:$li(tDocs(pDoc),2))")
		set pFeatureValueVar = "tBestDocName"
	}
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Model.Tree">
<Copyright>/* Copyright (c) 2018 by InterSystems Corporation.
   Cambridge, Massachusetts, U.S.A.  All rights reserved.
   Confidential property of InterSystems Corporation. */</Copyright>
<Abstract>1</Abstract>
<Super>AbstractModel</Super>
<System>4</System>
<TimeCreated>62749,57529.732477</TimeCreated>

<Parameter name="TRACEWEIGHTTYPE">
<Internal>1</Internal>
<Default>tree</Default>
</Parameter>

<Parameter name="SUPPORTSSIMPLEMODE">
<Internal>1</Internal>
<Default>1</Default>
</Parameter>

<Method name="%CreateModelClass">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%Dictionary.ClassDefinition,pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tDefinition As %DeepSee.PMML.Definition.Models.TreeModel = pDefinition
	new %NodeLabels, %Methods
	set tSC = $$$OK
	try {
		
		/// Create %ExecuteModelInternal method
		set tExecute = ##class(%Dictionary.MethodDefinition).%New()
		set tExecute.Name = "%ExecuteModelInternal"
		set tExecute.FormalSpec = "&pObservation:%DeepSee.PMML.ModelInput,*pOutput:%DeepSee.PMML.ModelOutput"
		set tExecute.ReturnType = "%Status"
		set tExecute.Private = 1
		
		#define WriteLine(%c) do tExecute.Implementation.WriteLine($c(9)_%c)
		$$$WriteLine("set tSC = $$$OK")
		if (tDefinition.missingValueStrategy="aggregateNodes") || (tDefinition.missingValueStrategy="weightedConfidence") {
			$$$WriteLine("new %AM, %AC, %AS")
		}
		$$$WriteLine("try {")
		$$$WriteLine("	set tMissingValueCount = 0, tSM = i%SimpleMode"_$s($g(%PMML("DisableTracing")):"",1:", tTrace = ..Tracing"))
		if (tDefinition.missingValueStrategy="aggregateNodes") || (tDefinition.missingValueStrategy="weightedConfidence") {
			$$$WriteLine("	set %AM = 0")
		}
		
		set tMethod = ..CreateSubTreeMethod(pClass /*, tDefinition.missingValueStrategy="defaultChild"*/ )
		set tSC = ..%WriteNodeBranch(tDefinition.Node, pClass, tMethod.Implementation,,, tDefinition)
		quit:$$$ISERR(tSC)
		set tSC = ..EndSubTreeMethod(tMethod)
		quit:$$$ISERR(tSC)
		
		$$$WriteLine("	set tSC = .."_tMethod.Name_"(.pObservation, .tScores, .tTrace, .tMissingValueCount, .tEnd)")
		$$$WriteLine("	quit:$$$ISERR(tSC)")
		$$$WriteLine("	goto:tEnd end")

		// as the last part of walking the tree, process tScores
		do tExecute.Implementation.WriteLine("end		// process tScores")
		if (tDefinition.missingValueStrategy="weightedConfidence") {
			
			$$$WriteLine("	if (%AM) {")
			$$$WriteLine("		set tValue = """", tConfidence = """", tBestValue = """"")
			$$$WriteLine("		for {")
			$$$WriteLine("			set tValue = $order(%AC(tValue),1,tConf)")
			$$$WriteLine("			quit:tValue=""""")
			$$$WriteLine("			set:(tConfidence="""")||(tConfidence<tConf) tConfidence = tConf, tBestValue = tValue")
			$$$WriteLine("		}")
			$$$WriteLine("")
			$$$WriteLine("		kill tScores")
			$$$WriteLine("		set tValue = """"")
			$$$WriteLine("		for {")
			$$$WriteLine("			set tValue = $order(%AS(tValue), 1, tRecordCount)")
			$$$WriteLine("			quit:tValue=""""")
			$$$WriteLine("			set tScores(tValue) = tRecordCount / %AS")
			if (tDefinition.functionName="classification") {
				$$$WriteLine("			set:i%KeepAllClassProbabilities tAllClassProbs = $g(tAllClassProbs)+1, tAllClassProbs(tAllClassProbs) = $lb(tValue, tScores(tValue))")
			}
			$$$WriteLine("		}")
			$$$WriteLine("		set tBestProb = $s(tBestValue="""":"""", 1:$g(tScores(tBestValue)))")
			$$$WriteLine("	} else {")
			$$$WriteLine("		set tValue = """", tBestProb = """", tBestValue = """"")
			$$$WriteLine("		for {")
			$$$WriteLine("			set tValue = $order(tScores(tValue),1,tProb)")
			$$$WriteLine("			quit:tValue=""""")
			if (tDefinition.functionName="classification") {
				$$$WriteLine("			set:i%KeepAllClassProbabilities tAllClassProbs=$g(tAllClassProbs)+1, tAllClassProbs(tAllClassProbs) = $lb(tValue, tProb)")
			}
			$$$WriteLine("			set:(tBestProb="""")||(tBestProb<tProb) tBestProb = tProb, tBestValue = tValue")
			$$$WriteLine("		}")
			$$$WriteLine("		// derive confidence value")
			$$$WriteLine("		set tConfidence = $s(tBestValue="""":"""", 1:$g(tConfidence(tBestValue)))")
			$$$WriteLine("	}")
			
		} else {
			if tDefinition.missingValueStrategy="aggregateNodes" {
				$$$WriteLine("	if (%AM) {")
				$$$WriteLine("		kill tScores")
				$$$WriteLine("		set tValue = """"")
				$$$WriteLine("		for {")
				$$$WriteLine("			set tValue = $order(%AS(tValue), 1, tRecordCount)")
				$$$WriteLine("			quit:tValue=""""")
				$$$WriteLine("			set tScores(tValue) = tRecordCount / %AS")
				$$$WriteLine("		}")
				$$$WriteLine("	}")
				$$$WriteLine("")
			}
			
			$$$WriteLine("	set tValue = """", tBestProb = """", tBestValue = """"")
			$$$WriteLine("	for {")
			$$$WriteLine("		set tValue = $order(tScores(tValue),1,tProb)")
			$$$WriteLine("		quit:tValue=""""")
			if (tDefinition.functionName="classification") {
				$$$WriteLine("		set:i%KeepAllClassProbabilities tAllClassProbs=$g(tAllClassProbs)+1,tAllClassProbs(tAllClassProbs) = $lb(tValue, tProb)")
			}
			$$$WriteLine("		set:(tBestProb="""")||(tBestProb<tProb) tBestProb = tProb, tBestValue = tValue")
			$$$WriteLine("	}")
			$$$WriteLine("	// derive confidence value")
			$$$WriteLine("	set tConfidence = $s(tBestValue="""":"""", 1:$g(tConfidence(tBestValue)))")
		}
		
		if (tDefinition.missingValuePenalty'="") && (tDefinition.missingValuePenalty'=1) {
			$$$WriteLine("	set tConfidence = tConfidence * ("_tDefinition.missingValuePenalty_" ** tMissingValueCount)")
		}
		$$$WriteLine("")
		
		set tSC = ..%PopulateOutputObject(pDefinition, tExecute.Implementation, "tBestValue")
		quit:$$$ISERR(tSC)
		
		// append tracing info
		if '$g(%PMML("DisableTracing")) {
			$$$WriteLine("")
			$$$WriteLine("	if (tTrace) {")
			$$$WriteLine("		set tSC = ..%PopulateTrace(.pOutput, .tTrace)")
			$$$WriteLine("		quit:$$$ISERR(tSC)")
			$$$WriteLine("	}")
		}
		
		// append tAllClassProbs
		if (tDefinition.functionName="classification") {
			$$$WriteLine("	merge:i%KeepAllClassProbabilities pOutput.%AllClassProbs = tAllClassProbs")
		}
		
		$$$WriteLine("} catch (ex) {")
		$$$WriteLine("	set tSC = ex.AsStatus()")
		$$$WriteLine("}")
		$$$WriteLine("quit tSC")
		
		do pClass.Methods.Insert(tExecute)
		set tExecute=""
		
		
		// default child jumper
		if (tDefinition.missingValueStrategy="defaultChild") {
			set tGoto = ##class(%Dictionary.MethodDefinition).%New()
			set tGoto.Name = "GotoDefaultChild"
			set tGoto.FormalSpec = "pNodeID:%String,&o,&s,&t,&pMissingValueCount:%Integer=0,*pEnd:%Boolean=0"
			set tGoto.ReturnType = "%Status"
			set tGoto.Internal = 1
			set tNodeID = ""
			for {
				set tNodeID = $order(%Methods("dc",tNodeID),1,tMethodID)
				quit:tNodeID=""
				do tGoto.Implementation.WriteLine("  quit:pNodeID="_$$$QUOTE(tNodeID)_" ..SubTree"_tMethodID_"(.o, .s, .t, .pMissingValueCount, .pEnd, 1)")
			}
			do tGoto.Implementation.WriteLine("  quit $$$ERROR($$$GeneralError, ""Unknown defaultChild node: '""_pNodeID_""'"")")
			do pClass.Methods.Insert(tGoto)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="CreateSubTreeMethod">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%Dictionary.ClassDefinition,pEnableDefaultChild:%Boolean=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Dictionary.MethodDefinition</ReturnType>
<Implementation><![CDATA[
	set tMethod = ##class(%Dictionary.MethodDefinition).%New()
	set tMethod.Name = "SubTree"_$i(%Methods), %Methods(%Methods) = tMethod.Name, %Methods(%Methods,"parent") = +$g(%Methods(-1)), %Methods(-1) = %Methods
	set tMethod.parent = pClass
	set tMethod.Internal = 1
	set tMethod.FormalSpec = "&o,&s,&t,&pMissingValueCount:%Integer=0,*pEnd:%Boolean=0"
	set:pEnableDefaultChild tMethod.FormalSpec = tMethod.FormalSpec_",pSkipToDefaultChild:%Boolean=0"
	set tMethod.ReturnType = "%Status"
	do tMethod.Implementation.WriteLine("  set tSC = $$$OK, pEnd=0, tSM=i%SimpleMode")
	do tMethod.Implementation.WriteLine("  try {")
	do:pEnableDefaultChild tMethod.Implementation.WriteLine("    goto:pSkipToDefaultChild defaultChild")
	quit tMethod
]]></Implementation>
</Method>

<Method name="EndSubTreeMethod">
<ClassMethod>1</ClassMethod>
<FormalSpec>pMethod:%Dictionary.MethodDefinition</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	do pMethod.Implementation.WriteLine("  } catch (ex) {")
	do pMethod.Implementation.WriteLine("    set tSC = ex.AsStatus()")
	do pMethod.Implementation.WriteLine("  }")
	do pMethod.Implementation.WriteLine("  quit tSC")
	set %Methods(-1) = %Methods(%Methods(-1),"parent")
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnGetOutputFeature">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pMethod:%Stream.Object,pDefinition:%DeepSee.PMML.Definition.Models.AbstractModel,pOutputField:%DeepSee.PMML.Definition.OutputField,&pFeatureValueVar:%String,*pSupported:%Boolean]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#define WriteLine(%c) do pMethod.WriteLine($c(9,9)_%c)
	set pSupported = 0
	
	if (pOutputField.feature = "probability") {
		set pSupported = 1
		if (pOutputField.value="") {
			$$$WriteLine("set "_pFeatureValueVar_" = $s(tBestValue="""":0, 1:$g(tScores(tBestValue)))")
		} else {
			$$$WriteLine("set "_pFeatureValueVar_" = $g(tScores("_$$$QUOTE(pOutputField.value)_"))")
		}
		
	}
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%WriteNodeBranch">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNode:%DeepSee.PMML.Definition.Models.Trees.TreeNode,pClass:%Dictionary.ClassDefinition,pCode:%Stream.TmpCharacter,pLevel:%Integer=0,pParentsDefaultChild:%String="",pTreeModel:%DeepSee.PMML.Definition.Models.TreeModel</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#define NODELABEL(%l,%id) set:'$d(%NodeLabels(%id),%l) %l = "node"_$i(%NodeLabels), %NodeLabels(%id) = %l
#define AddLOC(%n) set %Methods(%Methods(-1),"loc")=$g(%Methods(%Methods(-1),"loc"))+%n
#define WriteLine(%c) do pCode.WriteLine(%c) $$$AddLOC(1)
	set tSC = $$$OK
	try {
		
		set tIndent = ""
		for i=1:1:pLevel+2 {
			set tIndent = tIndent _ "  "
		}
		
		do pNode.Predicate.%WriteComputeCode("tCheck","o",tIndent,pCode)
		if (pNode.Predicate.%IsA("%DeepSee.PMML.Definition.Util.CompoundPredicate")) {
			$$$AddLOC(pNode.Predicate.Predicates.Count()*2)
		} else {
			$$$AddLOC(2)
		}
		
		if (pTreeModel.missingValueStrategy="none") {
			
			$$$WriteLine(tIndent_"if (tCheck = 1) {")
			
		} else {
			
			if (pTreeModel.missingValueStrategy="lastPrediction") {
				$$$WriteLine(tIndent_"if (tCheck = $c(0)) { set pEnd = 1  quit } elseif (tCheck=1) {")
			} elseif (pTreeModel.missingValueStrategy="nullPrediction") {
				$$$WriteLine(tIndent_"if (tCheck = $c(0)) { k s  set pEnd = 1  quit } elseif (tCheck=1) {")
			} elseif (pTreeModel.missingValueStrategy="defaultChild") {
				$$$WriteLine(tIndent_"if (tCheck = $c(0)) {")
				if (pParentsDefaultChild'="") {
					
					// write some trace output before jumping to the default child
					if '$g(%PMML("DisableTracing")) {
						do pNode.Predicate.%GetAsTree(.tTree)
						set tInfo = ##class(%DeepSee.PMML.Utils.TreeBuilder).GetCondition(.tTree)
						set tFields = ##class(%DeepSee.PMML.Utils.TreeBuilder).GetFieldList(.tTree)
						$$$WriteLine(tIndent_"  set:t t=t+1, t(t,0) = $lb($lb("""_$lts(tFields,""",""")_"""),,,""Node "_pNode.id_": "_$replace(tInfo,"""","""""")_"""), t=t+1, t(t,0) = $lb($lb("""_$lts(tFields,""",""")_"""),,,""Node "_pNode.id_": MISSING VALUES - go to node "_pParentsDefaultChild_""")")
					}
					
					$$$WriteLine(tIndent_"  set pMissingValueCount = pMissingValueCount + 1")
					
					if (pLevel=0) && (%Methods>1) {
						// we just arrived in another method and will have to look up the default child
						$$$WriteLine(tIndent_"  set tSC = ..GotoDefaultChild("_$$$QUOTE(pParentsDefaultChild)_",.o,.s,.t,.pMissingValueCount,.pEnd)  quit:$$$ISERR(tSC)||pEnd")
						$$$WriteLine(tIndent_"  set pEnd = 1  quit")
					} else {
						// the default child should be in the same method
						$$$NODELABEL(tLabel,pParentsDefaultChild)
						$$$WriteLine(tIndent_"  goto "_tLabel) // defaultChild label always within the same method
					}
				} else {
					$$$WriteLine(tIndent_"  set pEnd = 1  quit")
				}
				$$$WriteLine(tIndent_"} elseif (tCheck = 1) {")
			
			} elseif (pTreeModel.missingValueStrategy="aggregateNodes") || (pTreeModel.missingValueStrategy="weightedConfidence") {
				
				$$$WriteLine(tIndent_"if (tCheck = $c(0)) {")
				
				// write some trace output before aggregating nodes
				if '$g(%PMML("DisableTracing")) {
					do pNode.Predicate.%GetAsTree(.tTree)
					set tInfo = ##class(%DeepSee.PMML.Utils.TreeBuilder).GetCondition(.tTree)
					set tFields = ##class(%DeepSee.PMML.Utils.TreeBuilder).GetFieldList(.tTree)
					$$$WriteLine(tIndent_"	set:t&&'%AM t=t+1, t(t,0) = $lb($lb("""_$lts(tFields,""",""")_"""),,,""Node "_pNode.id_": "_$replace(tInfo,"""","""""")_" - aggregating..."")")
				}
				
				// now enable aggregation mode and get on as if tCheck = 1
				$$$WriteLine(tIndent_"	set %AM = 1, tCheck = 1")
			
				// no ELSEif as tCheck may have changed!
				$$$WriteLine(tIndent_"} if (tCheck = 1) {")
				
			} else {
				set tSC = $$$ERROR($$$NotImplemented)
				quit
			}
			
		}
				
		// print label if in defaultChild MVStrategy
		if (pTreeModel.missingValueStrategy="defaultChild") && (pNode.id'="") {
			$$$NODELABEL(tLabel,pNode.id)
			if (pLevel=0) && (pParentsDefaultChild'="") {
				// we have to write this label every time for the SubTree# method to compile
				$$$WriteLine("defaultChild")
				// but we'll want to keep the GoToDefaultChild() method short, so only write
				// actual default children here
				set:(pNode.id=pParentsDefaultChild) %Methods("dc",pNode.id)=%Methods(-1)
			} else {
				$$$WriteLine(tLabel)
			}
		}
		
		
		// tracing: first transform the node condition into a field list and info
		do pNode.Predicate.%GetAsTree(.tTree)
		if $d(tTree) && '$g(%PMML("DisableTracing")) { // skip True and False conditions
			// derive condition (as string) and field list from tree
			set tInfo = ##class(%DeepSee.PMML.Utils.TreeBuilder).GetCondition(.tTree)
			set tFields = ##class(%DeepSee.PMML.Utils.TreeBuilder).GetFieldList(.tTree)
			$$$WriteLine(tIndent_"  set:t t=t+1, t(t,0) = $lb($lb("""_$lts(tFields,""",""")_"""),,,""Node "_pNode.id_": "_$replace(tInfo,"""","""""")_""")")
		}
		
		
		set tHasSubnodes = ''pNode.Subnodes.Count()
		
		// if this is a leaf node or we need to keep track of the last prediction, store
		// the ScoreDistribution/score info in the tScores array
		if 'tHasSubnodes || (pTreeModel.noTrueChildStrategy="returnLastPrediction") || (pTreeModel.missingValueStrategy="lastPrediction") {
			
			// aggregate recordCount ScoreDistribution elements
			set tRecordCount = pNode.recordCount
			if 'tRecordCount {
				for i = 1:1:pNode.ScoreDistributions.Count() {
					set tRecordCount = tRecordCount + pNode.ScoreDistributions.GetAt(i).recordCount
				}
			}
			
			set tScoreCode = "  k s  set", tScoreCodeFirst=1
			
			if (pNode.ScoreDistributions.Count()) {
				for i = 1:1:pNode.ScoreDistributions.Count() {
					set tDistribution = pNode.ScoreDistributions.GetAt(i)
					set tProbability = tDistribution.probability
					set:'tProbability tProbability = $s(tRecordCount:tDistribution.recordCount / tRecordCount, 1:0)
					
					set tScoreCode = tScoreCode_$s(tScoreCodeFirst:"",1:",")_" s("_$$$QUOTE(tDistribution.value)_")=$g(s("_$$$QUOTE(tDistribution.value)_"))+"_tProbability
					//set:tDistribution.confidence'="" tScoreCode = tScoreCode_", tConfidence("_$$$QUOTE(tDistribution.value)_") = "_tDistribution.confidence
					set tScoreCodeFirst = 0
				}
			} elseif (pNode.score'="") {
				// otherwise, if there is a single score, store it
				set tScoreCode = tScoreCode_" s("_$$$QUOTE(pNode.score)_")=$g(s("_$$$QUOTE(pNode.score)_"))+1"
			} else {
				set tSC = $$$ERROR($$$GeneralError, "Node '"_pNode.id_"' has no score or scoredistribution")
				quit
			}
			
			$$$WriteLine(tIndent_tScoreCode)
		} else {
			// $$$WriteLine(tIndent_"  k s") // BDB823 - looks obsolete and is costly
		}
		
		// now process any subnodes
		if tHasSubnodes {
			for i = 1:1:pNode.Subnodes.Count() {
				set tSubnode = pNode.Subnodes.GetAt(i)
				
				if %Methods(%Methods(-1),"loc")>50000 {
					// if we're getting close the maximum #LOC per method, create a new one for each child
					set tMethod = ..CreateSubTreeMethod(pClass, pTreeModel.missingValueStrategy="defaultChild")
					set tSC = ..%WriteNodeBranch(tSubnode, pClass, tMethod.Implementation, 0, pNode.defaultChild, pTreeModel)
					quit:$$$ISERR(tSC)
					set tSC = ..EndSubTreeMethod(tMethod)
					quit:$$$ISERR(tSC)
					$$$WriteLine(tIndent_"  set tSC = .."_tMethod.Name_"(.o, .s, .t, .pMissingValueCount, .pEnd)  quit:$$$ISERR(tSC)||pEnd")
				} else {
					set tSC = ..%WriteNodeBranch(tSubnode, pClass, pCode, pLevel+1, pNode.defaultChild, pTreeModel)
					quit:$$$ISERR(tSC)
				}
			}
			quit:$$$ISERR(tSC)
		}
		
		// if in aggregateNodes mode, append score distribution values if this is a leaf node
		if 'tHasSubnodes && ((pTreeModel.missingValueStrategy="aggregateNodes") || (pTreeModel.missingValueStrategy="weightedConfidence")) {
			if (pTreeModel.missingValueStrategy="weightedConfidence") {
				set tRecordCount = pNode.recordCount
				if 'tRecordCount {
					for i = 1:1:pNode.ScoreDistributions.Count() {
						set tRecordCount = tRecordCount + pNode.ScoreDistributions.GetAt(i).recordCount
					}
				}
			}
			
			if (pNode.ScoreDistributions.Count()) {
				set tScoreCode = tIndent_"  set:%AM "
				for i = 1:1:pNode.ScoreDistributions.Count() {
					set tDistribution = pNode.ScoreDistributions.GetAt(i)
					set tScoreCode = tScoreCode_$s(i>1:", ",1:"")_"%AS("_$$$QUOTE(tDistribution.value)_") = $g(%AS("_$$$QUOTE(tDistribution.value)_"))+"_tDistribution.recordCount_", %AS = $g(%AS)+"_tDistribution.recordCount
					set:pTreeModel.missingValueStrategy="weightedConfidence" tScoreCode = tScoreCode_", %AC("_$$$QUOTE(tDistribution.value)_") = $g(%AC("_$$$QUOTE(tDistribution.value)_"))+("_$s(tDistribution.confidence="":tDistribution.probability, 1:tDistribution.confidence)_" * "_$s(tRecordCount:tDistribution.recordCount_" / "_tRecordCount, 1:0)_")"
				}
				$$$WriteLine(tScoreCode)
			} elseif (pNode.score'="") {
				$$$WriteLine(tIndent_"  set:%AM %AS("_$$$QUOTE(pNode.score)_") = $g(%AS("_$$$QUOTE(pNode.score)_"))+"_tRecordCount_", %AS = $g(%AS)+"_tRecordCount_"")
			}
		}
		
		
		// always go to the end at this point. noTrueChildStrategy has already prepared tScores
		if (pTreeModel.missingValueStrategy="aggregateNodes") || (pTreeModel.missingValueStrategy="weightedConfidence") {
			$$$WriteLine(tIndent_"  if '%AM { set pEnd = 1  quit }")
		} else {
			$$$WriteLine(tIndent_"  set pEnd = 1  quit")
		}
		$$$WriteLine(tIndent_"}")
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.ModelInput">
<Abstract>1</Abstract>
<Super>%DeepSee.PMML.Data</Super>
<System>4</System>
<TimeCreated>62775,61962.536226</TimeCreated>

<Parameter name="DATACLASS">
<Description><![CDATA[
The name of the root <class>%DeepSee.PMML.Data</class> class for this PMML definition]]></Description>
<Type>CLASSNAME</Type>
</Parameter>

<Parameter name="MODELCLASS">
<Description><![CDATA[
The name of the <class>%DeepSee.PMML.Model.AbstractModel</class> for this PMML model]]></Description>
<Type>CLASSNAME</Type>
</Parameter>

<Parameter name="MODELNAME">
<Description>
The name of this model as defined in the PMML definition</Description>
<Type>STRING</Type>
</Parameter>

<Method name="%GetFields">
<Description>
Returns the usage types for all fields in this Mining Model
		pArray(fieldName) = $lb(usageType, displayName)</Description>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	// implementation generated by %DeepSee.PMML.Definition.%CreateClasses()
]]></Implementation>
</Method>

<Method name="%OnNew">
<FormalSpec><![CDATA[&pData]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		if $isobject($g(pData)) {
			set tSC = pData.%GetAsArray(.tData)
			quit:$$$ISERR(tSC)
			set tSC = ..%LoadData(.tData)
			quit:$$$ISERR(tSC)
		} elseif $d(pData)>1 {
			set tSC = ..%LoadData(.pData)
			quit:$$$ISERR(tSC)
		}
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Serial</Type>
</Storage>
</Class>


<Class name="%DeepSee.PMML.ModelOutput">
<Abstract>1</Abstract>
<IncludeCode>%PMML</IncludeCode>
<Super>%RegisteredObject</Super>
<System>4</System>
<TimeCreated>62775,62000.658796</TimeCreated>

<Property name="%Trace">
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="%AllClassProbs">
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="%GetFields">
<Description>
		pArray(fieldName) = $lb(feature, targetFieldName, displayName)</Description>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pFields</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	// implementation will be generated by %DeepSee.PMML.Definition.%CreateClasses()
]]></Implementation>
</Method>

<Method name="%GetFeatureValue">
<Description><![CDATA[
Returns the feature value of predicted field <var>pTargetField</var>. If <var>pTargetField</var>
is left blank, the feature value for the "last" field is returned (generally safe for models
predicting a single field value). Note that <var>pTargetField</var> is the name of the field
in the data class, not in this output class.
<var>pAllValues</var> contains the feature values for all fields, indexed by field name]]></Description>
<FormalSpec>pFeature:%String="predictedValue",pTargetField:%String="",*pAllValues</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set tFeatureValue = ""
	kill pAllValues
	do ..%GetFields(.tFields)
	set tField = "", pTargetField = $$$PROPERTYNAME(pTargetField)
	for {
		set tField = $order(tFields(tField),1,tDetails)
		quit:tField=""
		
		continue:($li(tDetails,1)'=pFeature)
		
		set tValue = $property($this, $$$PROPERTYNAME(tField))
		set pAllValues(tField) = tValue
		
		if (pTargetField=$$$PROPERTYNAME($li(tDetails,2))) || (pTargetField="") {
			set tFeatureValue = tValue
		}
	}
	quit tFeatureValue
]]></Implementation>
</Method>

<Method name="%GetTracingInfo">
<Description>
Returns tracing information (if available) about the contribution of the input values to the 
model's outcome. 
Format:
	pTrace(n) = $lb($lb(inputs), $lb(values), rank, [weight], [info])</Description>
<FormalSpec>*pTrace</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if $d(..%Trace)<10 {
			set tSC = $$$ERROR($$$GeneralError, "No trace info available")
			quit
		}
		
		merge pTrace = ..%Trace
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%GetAllClassProbabilities">
<Internal>1</Internal>
<FormalSpec>*pClassProbs</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	merge pClassProbs = ..%AllClassProbs
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.UI.AbstractTester">
<Abstract>1</Abstract>
<Hidden>1</Hidden>
<IncludeCode>%PMML</IncludeCode>
<Super>%DeepSee.UI.standardPage</Super>
<System>4</System>
<TimeCreated>63082,58365.420104</TimeCreated>

<Parameter name="RESOURCE">
<Default>%Development</Default>
</Parameter>

<Property name="definitionClass">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="ZENURL" value="CLASS"/>
</Property>

<Property name="customSQL">
<Type>%ZEN.Datatype.string</Type>
</Property>

<Property name="testId">
<Type>%ZEN.Datatype.integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="mode">
<Type>%ZEN.Datatype.string</Type>
<InitialExpression>"categorical"</InitialExpression>
</Property>

<Property name="currentActualValue">
<Type>%ZEN.Datatype.string</Type>
</Property>

<Property name="currentPredictedValue">
<Type>%ZEN.Datatype.string</Type>
</Property>

<Property name="currentRowId">
<Type>%ZEN.Datatype.string</Type>
</Property>

<Property name="minimalProbability">
<Type>%ZEN.Datatype.float</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="ZENURL" value="MINPROB"/>
</Property>

<Property name="hideAdvanced">
<Type>%ZEN.Datatype.boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<XData name="dataSourcePane">
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
</XData>

<XData name="rowLevelTracePane">
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
</XData>

<XData name="moreContentPane">
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
</XData>

<XData name="contentPane">
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<pane enclosingStyle="padding:20px;">
<modalGroup groupTitle="Test progress" id="popTestProgress">
<label id="lblTestProgress" />
</modalGroup>

<hgroup valign="top">
<vgroup width="38%" valign="top">
<pane paneName="dataSourcePane" />

<spacer height="30" />
<vgroup id="grpTestParams" hidden="true" width="100%" >
<titleBox title="Test parameters" width="100%" />
<spacer height="10" />
<vgroup labelPosition="left">
<text id="txtMinProb" value="#(%page.minimalProbability)#" label="Score threshold"
hint="Predictions with lower scores will not be counted towards precision and recall"
onchange="var sc = zenPage.setProperty('minimalProbability',zenThis.getValue()); zenPage.reset();" />
</vgroup>
</vgroup>
</vgroup>
<spacer width="30" />
<vgroup width="58%" valign="top" id="grpCategoricalResults" hidden="false">

<titleBox title="Test results" />
<spacer height="5" />

<hgroup cellVAlign="middle">
<jsonSQLProvider id="jsonAccuracy" OnGetSQL="OnGetSQLAccuracy" />
<svgFrame id="svgAccuracy" width="250" height="150" >
<pieChart id="chartAccuracy" width="250" height="150" legendVisible="false"
seriesColors="#9cfa7d,#eea17d,#dddddd" controllerId="jsonAccuracy" plotBy="items"
marginBottom="0" marginLeft="0" marginRight="0" marginTop="0" showPercentage="true" />
</svgFrame>
<spacer width="20" />
<vgroup cellVAlign="middle" labelPosition="left" cellStyle="padding-bottom:10px;">
<label id="txtRecordCount" label="Record count: "
 labelClass="pmmlResultLabel" controlClass="pmmlResultControl" readOnly="true" />
<label id="txtWPrecision" label="Precision: " title="Micro-averaged precision (secondary value is macro average)"
 labelClass="pmmlResultLabel" controlClass="pmmlResultControl" readOnly="true"/>
<label id="txtWRecall" label="Recall: " title="Micro-averaged recall (secondary value is macro average)"
 labelClass="pmmlResultLabel" controlClass="pmmlResultControl" readOnly="true" />
<label id="txtWFmeasure" label="F-measure: " title="Micro-averaged F-measure (secondary value is macro average)"
 labelClass="pmmlResultLabel" controlClass="pmmlResultControl" readOnly="true" />
</vgroup>
</hgroup>
<spacer height="10" />

<titleBox title="Details by actual value"/>
<spacer height="5" />
<tabGroup showTabBar="true" width="640" height="250" id="tabsCatVal">
<tab caption="Overview" enclosingStyle="padding: 10px;">
<jsonSQLProvider id="jsonCatValOverview" OnGetSQL="OnGetSQLCatValOverview" />
<svgFrame id="svgCatValOverview" width="600" height="250">
<barChart id="chartCatValOverview" width="600" height="250" controllerId="jsonCatValOverview"
marginBottom="0" marginLeft="15" marginRight="0" marginTop="0" chartPivot="true"
chartStacked="true" labelsVisible="true" seriesColors="#9cfa7d,#eea17d,#dddddd"
onelementClick="return zenPage.onCatValOverviewClick(zenThis);"
/>
</svgFrame>
</tab>
<tab caption="Details" enclosingStyle="padding: 10px;">
<hgroup cellVAlign="top">
<vgroup>
<vgroup labelPosition="left">
<select id="selCategoricalValue" label="Actual value: "
sql="SELECT %EXACT(ActualValue), %EXACT(ActualValue) ||' ('|| COUNT(*) ||')' FROM %DeepSee_PMML_Utils.TempResult WHERE TestId = ? GROUP BY %EXACT(ActualValue)"
onchange="zenPage.updateCatValDetails(zenThis.getValue());" >
<parameter value="#(%page.testId)#" />
</select>
</vgroup>
<spacer height="10" />
<hgroup>
<label id="lblPrecision" title="Precision" />
<spacer width="25" />
<label id="lblRecall" title="Recall" />
<spacer width="25" />
<label id="lblFMeasure" title="F-measure" />
</hgroup>
<spacer height="20" />

<vgroup width="250" id="grpConfusion">
<hgroup height="50">
<vgroup cellAlign="center" containerStyle="background-color: #9cfa7d;">
<label label="true positive" width="120" align="center" 
title="correctly predicted as category X" />
<label id="lblConfusionTruePos" width="120" align="center" label=" " 
title="correctly predicted as category X" />
</vgroup>
<spacer width="10" />
<vgroup cellAlign="center" containerStyle="background-color: #eea17d;" >
<label label="false negative" width="120" align="center"
title="actually category X, but predicted as something else" />
<label id="lblConfusionFalseNeg" width="120" align="center" label=" "
title="actually category X, but predicted as something else" />
</vgroup>
</hgroup>
<hgroup height="50">
<vgroup cellAlign="center" containerStyle="background-color: #eea17d;" >
<label label="false positive" width="120" align="center"
title="predicted as category X, but actually something else" />
<label id="lblConfusionFalsePos" width="120" align="center" label=" "
title="predicted as category X, but actually something else" />
</vgroup>
<spacer width="10" />
<vgroup cellAlign="center" containerStyle="background-color: #9cfa7d;">
<label label="true negative" width="120" align="center"
title="correctly predicted as something else" />
<label id="lblConfusionTrueNeg" width="120" align="center" label=" "
title="correctly predicted as something else" />
</vgroup>
</hgroup>
</vgroup>
</vgroup>
<spacer width="40" />
<jsonSQLProvider id="jsonCatValDetails" OnGetSQL="OnGetSQLCatValDetails" />
<svgFrame id="svgCatValDetails" width="300" height="180" >
<pieChart id="chartCatValDetails" width="300" height="180" plotBy="items"
marginBottom="0" marginLeft="0" marginRight="0" marginTop="0"
showPercentage="true" controllerId="jsonCatValDetails" legendVisible="false"
 onelementClick="return zenPage.onCatValElementClick(zenThis);" />
</svgFrame>
</hgroup>
</tab>
</tabGroup>
</vgroup>
<vgroup width="60%" valign="top" id="grpContinuousResults" hidden="true">

<titleBox title="Test results" />
<spacer height="5" />

<hgroup>
<jsonSQLProvider id="jsonErrors" OnGetSQL="OnGetSQLErrors" />
<svgFrame id="svgErrors" width="300" height="180" >
<barChart id="chartErrors" width="300" height="180" controllerId="jsonErrors"
title="Error distribution" chartPivot="true" >
<yAxis title="absolute error" labelStyle="font-size:9px;" />
</barChart>
</svgFrame>
<spacer width="20" />
<vgroup valign="middle" labelPosition="left" cellStyle="padding-bottom:10px;">
<text id="txtRecordCount2" label="Record count: " 
labelClass="pmmlResultLabel" controlClass="pmmlResultControl" readOnly="true" />
<text id="txtSigma" label="Sigma: " title="Sigma (aka &quot;Root Mean Square Error&quot;, equals root of Variance)"
 labelClass="pmmlResultLabel" controlClass="pmmlResultControl" readOnly="true" />
<text id="txtRSE" label="RSE: " title="Relative Square Error"
 labelClass="pmmlResultLabel" controlClass="pmmlResultControl" readOnly="true" />
<text id="txtRSquared" label="R: " title="R Squared (aka &quot;Coefficient of Determination&quot;)"
 labelClass="pmmlResultLabel" controlClass="pmmlResultControl" readOnly="true" />
</vgroup>
</hgroup>
<spacer height="20" />

<titleBox title="Value distribution"/>
<spacer height="5" />
<jsonSQLProvider id="jsonScatter" OnGetSQL="OnGetSQLScatter"  />
<svgFrame id="svgScatter" width="500" height="270" >
<xyChart id="chartScatter" width="500" height="270" plotStyle="stroke:none;" 
  controllerId="jsonScatter" onelementClick="zenPage.onContValElementClick(zenThis);" >
 <xAxis title="Actual value" />
 <yAxis title="Predicted value" />
 </xyChart>
</svgFrame>

</vgroup>
</hgroup>

<modalGroup id="popRowDetails" groupTitle="Row-level details">
<spacer height="10" />
<tablePane id="tblRowDetails" showRowSelector="false" enclosingStyle="height: 350px; overflow-y: scroll;" >
<column colName="_ID" header="ID" OnDrawCell="DrawRowID"  />
</tablePane>
</modalGroup>

<modalGroup id="popRecordDetails" groupTitle="Test record details">
<spacer height="10" />
<html id="htmlRecord" OnDrawContent="DrawRecordDetails" />
</modalGroup>

<pane paneName="rowLevelTracePane" />

<modalGroup id="popExport" groupTitle="Export test results to cube definition">
<spacer height="5" />
<vgroup labelPosition="left" cellStyle="padding-bottom:8px;" enclosingClass="background: #eeeeee;">
<radioSet label="Export" valueList="data,both" displayList="data only,classes and data" value="both" id="radExportAction" onchange="zenPage.toggleExportAction(zenThis.getValue());" />
<text label="Result class name" id="txtExportResultClass" />
<text label="Link to source class" title="Class name of the original record the result class should link to" id="txtExportSrcClass" />
<checkbox label="Drop old data" title="Erase all previous test result data in the result class" id="chkExportOverwriteData" value="1" />
<spacer height="10" />
<text label="Cube name" id="txtExportCube" />
<text label="Cube class name" id="txtExportCubeClass" />
<checkbox label="Add iKnow measure" title="Add an iKnow measure for the _Text field" id="chkExportIKMsr" hidden="true" />
<checkbox label="Overwrite classes" title="Overwrite existing class definitions" id="chkExportOverwriteCls" />
<button caption="Export" onclick="zenPage.export();" />
</vgroup>
</modalGroup>

<pane paneName="moreContentPane" />
</pane>
]]></Data>
</XData>

<Method name="OnGetSQLErrors">
<FormalSpec><![CDATA[&pParameters:%String,&pSQL:%String,pCriteria:%ZEN.proxyObject,&pPagingInfo:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tTestId = ..testId
	&SQL(SELECT MAX(ABS(PredictedValue-ActualValue)) INTO :tMaxError FROM %DeepSee_PMML_Utils.TempResult WHERE TestId = :tTestId AND PredictedValue IS NOT NULL AND ActualValue IS NOT NULL)
	set:'tMaxError tMaxError = 1
	set pSQL = "SELECT ROUND(ErrInterval * "_tMaxError_",2,1)||'-'||ROUND((ErrInterval+1) * "_tMaxError_",2,1) as caption, COUNT(*) as ""count"" FROM (SELECT ROUND(10*ABS(PredictedValue-ActualValue)/"_tMaxError_",0) AS ErrInterval FROM %DeepSee_PMML_Utils.TempResult WHERE TestId = "_..testId_") WHERE ErrInterval IS NOT NULL GROUP BY ErrInterval"
	quit $$$OK
]]></Implementation>
</Method>

<Method name="OnGetSQLScatter">
<FormalSpec><![CDATA[&pParameters:%String,&pSQL:%String,pCriteria:%ZEN.proxyObject,&pPagingInfo:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set pSQL = "SELECT ActualValue, PredictedValue FROM %DeepSee_PMML_Utils.TempResult WHERE TestId = "_..testId_" ORDER BY %ID"
	quit $$$OK
]]></Implementation>
</Method>

<Method name="OnGetSQLCatValOverview">
<FormalSpec><![CDATA[&pParameters:%String,&pSQL:%String,pCriteria:%ZEN.proxyObject,&pPagingInfo:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if (..minimalProbability>0) {
		set pSQL = "SELECT ActualValue As caption, SUM(CASE WHEN Probability >= "_+..minimalProbability_" AND PredictedValue = ActualValue THEN 1 ELSE 0 END) As correct,  SUM(CASE WHEN Probability >= "_+..minimalProbability_" AND PredictedValue != ActualValue THEN 1 ELSE 0 END) As incorrect, SUM(CASE WHEN Probability < "_+..minimalProbability_" THEN 1 ELSE 0 END) As unsure FROM %DeepSee_PMML_Utils.TempResult WHERE TestId = "_..testId_" GROUP BY ActualValue"
	} else {
		set pSQL = "SELECT ActualValue As caption, SUM(CASE WHEN PredictedValue = ActualValue THEN 1 ELSE 0 END) As correct,  SUM(CASE WHEN PredictedValue != ActualValue THEN 1 ELSE 0 END) As incorrect FROM %DeepSee_PMML_Utils.TempResult WHERE TestId = "_..testId_" GROUP BY ActualValue"
	}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="OnGetSQLCatValDetails">
<FormalSpec><![CDATA[&pParameters:%String,&pSQL:%String,pCriteria:%ZEN.proxyObject,&pPagingInfo:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if (..minimalProbability>0) {
		set pSQL = "SELECT COUNT(*) As ""count"", caption FROM (SELECT ID, CASE WHEN Probability < "_..minimalProbability_" THEN 'unsure' ELSE NVL(PredictedValue,'[null]') END As caption FROM %DeepSee_PMML_Utils.TempResult WHERE TestId = "_..testId_" AND ActualValue "_$s(..currentActualValue="":"IS NULL", 1:"= '"_..currentActualValue_"'")_") GROUP BY caption"
	} else {
		set pSQL = "SELECT COUNT(*) As ""count"", NVL(PredictedValue,'[null]') As caption FROM %DeepSee_PMML_Utils.TempResult WHERE TestId = "_..testId_" AND ActualValue "_$s(..currentActualValue="":"IS NULL", 1:"= '"_..currentActualValue_"'")_" GROUP BY PredictedValue"
	}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="OnGetSQLAccuracy">
<FormalSpec><![CDATA[&pParameters:%String,&pSQL:%String,pCriteria:%ZEN.proxyObject,&pPagingInfo:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set pSQL = "SELECT SUM(""count""), caption FROM ((SELECT COUNT(*) As ""count"", outcome caption FROM (SELECT CASE WHEN Probability < "_+..minimalProbability_" THEN 'unsure' WHEN PredictedValue = ActualValue THEN 'correct' ELSE 'incorrect' END As outcome FROM %DeepSee_PMML_Utils.TempResult WHERE TestId = "_..testId_") GROUP BY outcome) UNION (SELECT 0 ""count"", 'correct' caption) UNION (SELECT 0 ""count"", 'incorrect' caption)) GROUP BY caption"
	quit $$$OK
]]></Implementation>
</Method>

<Method name="GetCurrentURL">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[	quit $zconvert($classname(), "O", "URL")_".zen"
]]></Implementation>
</Method>

<Method name="onPopupAction">
<Description>
This client event is fired when the a popup page launched from this page fires an action.</Description>
<FormalSpec>popupName,action,value</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (action != 'ok') return false;
	switch(popupName) {
		case 'PMML':
		case 'iKnow':
			self.document.location = zenLink(zenPage.GetCurrentURL() + '?CLASS='+encodeURIComponent(value.substring(0,value.length-4)));
			break;
		case 'switchNamespace':
			var url = zenPage.GetNewURL(value, zenPage.GetCurrentURL());
			self.document.location = url;
			break;
		case 'CubeBuild':
			if (confirm($$$Text('Proceed to Analyzer?'))) {
				location.href = zenLink('_DeepSee.UI.Analyzer.zen?CUBENAME='+encodeURIComponent(cubeName));
			}
			break;
		default:
			break;
	}
]]></Implementation>
</Method>

<Method name="onloadHandler">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.changeMode();
	zenPage.reset();
]]></Implementation>
</Method>

<Method name="changeMode">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var isContinuous = (zenPage.getProperty('mode')=='continuous');
	zen('grpContinuousResults').setProperty('hidden', !isContinuous);
	zen('grpCategoricalResults').setProperty('hidden', isContinuous);
	zen('txtMinProb').setProperty('hidden', isContinuous);
]]></Implementation>
</Method>

<Method name="reset">
<Final>1</Final>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('testId', 0);
	sc = zenPage.onReset();
	
	zenPage.refresh();
]]></Implementation>
</Method>

<Method name="onReset">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
</Method>

<Method name="refresh">
<Final>1</Final>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var results = zenPage.GetTestResults();
	
	if (zenPage.getProperty('mode')=='continuous') {
		
		zen('jsonScatter').reloadContents();
		zen('jsonErrors').reloadContents();
		zen('txtRecordCount2').setValue(results.recordCount);
		zen('txtSigma').setValue(results.RMSE);
		zen('txtRSE').setValue(results.RSE);
		zen('txtRSquared').setValue(results.RSquared);
		
	} else {
		
		zen('jsonAccuracy').reloadContents();
		zen('jsonCatValOverview').reloadContents();
		zen('txtRecordCount').setValue(results.recordCount);
		zen('txtWPrecision').setValue(results.microPrecision+'% ('+results.macroPrecision+')');
		zen('txtWRecall').setValue(results.microRecall+'% ('+results.macroRecall+')');
		zen('txtWFmeasure').setValue(results.microFMeasure+'% ('+results.macroFMeasure+')');
		
		zen('selCategoricalValue').setValue('');
		zen('selCategoricalValue').refreshContents();
		zenPage.updateCatValDetails('');
	}
	
	zenPage.onRefresh();
]]></Implementation>
</Method>

<Method name="onRefresh">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
</Method>

<Method name="checkDataSource">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	return true;
]]></Implementation>
</Method>

<Method name="test">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (!zenPage.checkDataSource()) {
		return;
	}
	var sc = zen('lblTestProgress').setValue('Initializing...');
	sc = zen('popTestProgress').show();
	
	zenPage.TestModel();
]]></Implementation>
</Method>

<Method name="changeProbThreshold">
<FormalSpec>value</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty(value);
	zenPage.refresh();
]]></Implementation>
</Method>

<Method name="TestModel">
<Abstract>1</Abstract>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
</Method>

<Method name="GetConfusionMatrix">
<ReturnType>%ZEN.proxyObject</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tSC = $$$OK, tObj = ##class(%ZEN.proxyObject).%New()
	try {
		quit:'..testId
		set tTestId = ..testId, tValue = ..currentActualValue, tMinProb = ..minimalProbability
		if (tMinProb>0) {
			&SQL(SELECT SUM(CASE WHEN ActualValue = :tValue AND PredictedValue = :tValue THEN 1 ELSE 0 END),
					SUM(CASE WHEN ActualValue != :tValue AND PredictedValue != :tValue THEN 1 ELSE 0 END),
					SUM(CASE WHEN ActualValue != :tValue AND PredictedValue = :tValue THEN 1 ELSE 0 END),
					SUM(CASE WHEN ActualValue = :tValue AND PredictedValue != :tValue THEN 1 ELSE 0 END) 
					INTO :tTruePos, :tTrueNeg, :tFalsePos, :tFalseNeg
					FROM %DeepSee_PMML_Utils.TempResult 
					WHERE TestId = :tTestId AND Probability >= :tMinProb)
		} else {
			set tSC = ##class(%DeepSee.PMML.Utils.TempResult).GetCategoryPrecisionMetrics(tTestId, tValue,,,, .tTruePos, .tTrueNeg, .tFalsePos, .tFalseNeg)
			quit:$$$ISERR(tSC)
		}
		set tObj.TruePos = tTruePos, tObj.TrueNeg = tTrueNeg, tObj.FalsePos = tFalsePos, tObj.FalseNeg = tFalseNeg
		
		set tPrecision = $s(tTruePos+tFalsePos:100 * tTruePos / (tTruePos + tFalsePos), 1:0)
		set tRecall = $s(tTruePos+tFalseNeg:100 * tTruePos / (tTruePos + tFalseNeg), 1:0)
		set tFmeasure = $s(tPrecision+tRecall:2*tPrecision*tRecall/(tPrecision+tRecall), 1:0)
		set tObj.Precision = $fnumber(tPrecision, "", 0)
		set tObj.Recall = $fnumber(tRecall, "", 0)
		set tObj.Fmeasure = $fnumber(tFmeasure, "", 0)
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	set tObj.error = $s($$$ISERR(tSC):$system.Status.GetErrorText(tSC), 1:"")
	quit tObj
]]></Implementation>
</Method>

<Method name="onCatValOverviewClick">
<FormalSpec>chart</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var item = chart.getSelectedItem();
	if (item < 0) return;
	
	var cat = chart.getYLabelText(item);
	zen('selCategoricalValue').setValue(cat);
	zen('tabsCatVal').showTab(2);
	zenPage.updateCatValDetails(cat);
]]></Implementation>
</Method>

<Method name="updateCatValDetails">
<FormalSpec>value</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('currentActualValue', value);
	sc = zenPage.setProperty('currentPredictedValue', '');
	zen('jsonCatValDetails').reloadContents();
	
	var conf = zenPage.GetConfusionMatrix();
	if (conf.error!='') {
		alert('Error fetching confusion matrix:\n'+conf.error);
	} else {
		zenPage.setConfusionMatrixValue('TruePos',conf.TruePos);
		zenPage.setConfusionMatrixValue('FalsePos',conf.FalsePos);
		zenPage.setConfusionMatrixValue('FalseNeg',conf.FalseNeg);
		zenPage.setConfusionMatrixValue('TrueNeg',conf.TrueNeg);
	
		zen('lblPrecision').setProperty('label', 'P: '+conf.Precision+'%');
		zen('lblRecall').setProperty('label', 'R: '+conf.Recall+'%');
		zen('lblFMeasure').setProperty('label', 'F: '+conf.Fmeasure+'%');
	}
]]></Implementation>
</Method>

<Method name="setConfusionMatrixValue">
<FormalSpec>cell,value</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	zen('lblConfusion'+cell).setProperty('label', (value=='') ? 0 : value);
]]></Implementation>
</Method>

<Method name="DropTestResults">
<FormalSpec>pTestId:%Integer=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set:'pTestId pTestId = ..testId
	quit ##class(%DeepSee.PMML.Utils).%DropResults(pTestId)
]]></Implementation>
</Method>

<Method name="GetTestResults">
<ReturnType>%ZEN.proxyObject</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tSC = $$$OK, tObject = ##class(%ZEN.proxyObject).%New()
	try {
		set tTestId = ..testId
		
		&SQL(SELECT COUNT(*) INTO :tRecordCount FROM %DeepSee_PMML_Utils.TempResult WHERE TestId = :tTestId)
		
		set tObject.recordCount = tRecordCount
		
		if (..mode="continuous") {
			
			&SQL(SELECT AVG(ActualValue) INTO :tMean FROM %DeepSee_PMML_Utils.TempResult WHERE TestId = :tTestId)
			&SQL(SELECT 
					SUM(POWER(ActualValue-PredictedValue, 2))/ GREATEST(COUNT(*),1),
					SUM(POWER(PredictedValue-ActualValue, 2)) / SUM(POWER(:tMean-ActualValue, 2))
				 INTO :tMSE, :tRSE
				 FROM %DeepSee_PMML_Utils.TempResult
				 WHERE TestId = :tTestId)
			
			set tObject.MSE = $fnumber(tMSE,"",2), tObject.RSE = $fnumber(tRSE,"",4)
			set tObject.RMSE = $fnumber($zsqr(tMSE),"",2)
			set tObject.RSquared = $fnumber(1-tRSE,"",4)
			
		} else {
			
			// get weighted precision and recall
			set tSC = ##class(%DeepSee.PMML.Utils.TempResult).GetAggregatePrecisionMetrics(tTestId, .tMacroP, .tMicroP, .tMacroR, .tMicroR, .tMacroF, .tMicroF)
			quit:$$$ISERR(tSC)
			set tObject.macroPrecision = $fnumber(tMacroP,"",2), tObject.macroRecall = $fnumber(tMacroR,"",2)
			set tObject.microPrecision = $fnumber(tMicroP,"",2), tObject.microRecall = $fnumber(tMicroR,"",2)
			set tObject.microFMeasure = $fnumber(tMicroF,"",2), tObject.macroFMeasure = $fnumber(tMacroF,"",2)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	set tObject.error = $s($$$ISERR(tSC):$system.Status.GetErrorText(tSC), 1:"")
	quit tObject
]]></Implementation>
</Method>

<Method name="CheckSQL">
<FormalSpec>pSQL:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tSC = ##class(%SQL.Statement).%New().%Prepare(pSQL)
	if $$$ISERR(tSC) {
		set ..customSQL = ""
		quit $system.Status.GetErrorText(tSC)
	} else {
		set ..customSQL = pSQL
		set %session.Data($classname(),"CustomSQL") = pSQL
		quit "OK"
	}
]]></Implementation>
</Method>

<Method name="%OnFinishBackgroundTask">
<ClassMethod>1</ClassMethod>
<FormalSpec>pTaskID:%String</FormalSpec>
<Implementation><![CDATA[
	set tData = $g(^IRIS.Temp.PMML.BgrTask(pTaskID))
	set tSC = $lg(tData,2)
	if $$$ISERR(tSC) {
		set tErrorMessage = $zconvert($system.Status.GetErrorText(tSC),"O","JS")
		&js<alert(('Error running model')+':\n#(tErrorMessage)#'); zenPage.endModal(); zenPage.reset();>
	} else {
		set tTestId = $lg(tData,1)
		&js<zenPage.endModal(); sc = zenPage.setProperty('testId', parseInt('#(tTestId)#')); zenPage.refresh();>
	}
	kill ^IRIS.Temp.PMML.BgrTask(pTaskID)
]]></Implementation>
</Method>

<Method name="%OnMonitorBackgroundTask">
<ClassMethod>1</ClassMethod>
<FormalSpec>pTaskID:%String,pStatus:%String,pPercentComplete:%Float</FormalSpec>
<Implementation><![CDATA[
	merge tStatus = ^IRIS.Temp.PMML.BgrTask(pTaskID, "track")
	quit:'$data(tStatus)
	
	if $d(tStatus("total"), tTotal) {
		set pPercentComplete = $g(tStatus("done")) / tTotal
		set tPercentCompleteStr = $zconvert("Running: "_$fnumber(pPercentComplete*100, "", 2)_" % processed","O","JS")
	} else {
		set tPercentCompleteStr = $zconvert("Running: "_$g(tStatus("done"),0)_" rows processed","O","JS")
	}
	
	&js<zen('lblTestProgress').setValue('#(tPercentCompleteStr)#');>
]]></Implementation>
</Method>

<Method name="onCatValElementClick">
<FormalSpec>chart</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var item = chart.getSelectedItem();
	if (item < 0) return;
	
	if (!zenPage.CheckDataSourceHasIdentifier()) {
		alert($$$Text('Can only drill to row-level details if _ID column selected in custom SQL'));
		return;
	}
	
	var cat = chart.getYLabelText(item);
	var sc = zenPage.setProperty('currentPredictedValue', cat);
	sc = zenPage.BuildRowDetailsQuery();
	if (sc!='OK') { alert(sc); return; }
	zen('tblRowDetails').refreshContents();
	
	var actual = zenPage.getProperty('currentActualValue');
	zen('popRowDetails').setProperty('groupTitle', 'Rows with actual value "'+actual+'" and predicted value "'+cat+'"');
	zen('popRowDetails').show();
]]></Implementation>
</Method>

<Method name="BuildRowDetailsQuery">
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tSC = ..OnBuildRowDetailsQuery(.tSQL)
		quit:$$$ISERR(tSC)
		
		set ..%GetComponentById("tblRowDetails").sql = tSQL
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit $s($$$ISERR(tSC):$system.Status.GetErrorText(tSC), 1:"OK")
]]></Implementation>
</Method>

<Method name="OnBuildRowDetailsQuery">
<Abstract>1</Abstract>
<FormalSpec>*pSQL:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
</Method>

<Method name="showText">
<FormalSpec>id</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('currentRowId',id);
	zen('htmlText').refreshContents();
	zen('htmlCategories').refreshContents();
	zen('htmlTrace').setProperty('seed', '');
	zen('htmlTrace').refreshContents();
	zen('popText').show();
]]></Implementation>
</Method>

<Method name="DrawRowID">
<Abstract>1</Abstract>
<FormalSpec>pTable:%ZEN.Component.tablePane,pName:%String,pSeed:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
</Method>

<Method name="launchExport">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (zenPage.getProperty('testId') == 0) { 
		alert($$$Text("Run the model on some data before exporting.")); 
		return;
	}
	
	// populate input fields if empty
	if (zen('txtExportResultClass').getValue()=='') {
		var packageName = zenPage.GetExportPackageName()		// DTB459 - Don't use reserve word
		zen('txtExportCube').setValue('ModelTestResults');
		zen('txtExportCubeClass').setValue(packageName+'.ResultCube');
		zen('txtExportResultClass').setValue(packageName+'.Result');
		zen('txtExportSrcClass').setValue(zenPage.GetSourceClassForSQL(zen('txtSQL').getValue()));
	}
	
	zen('popExport').show();
]]></Implementation>
</Method>

<Method name="GetSourceClassForSQL">
<FormalSpec>pSQL:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tClassname = ""
	set pSQL = $replace($replace(pSQL, $c(10)," "), $c(13)," ")
	set pSQL = $$$UPPER($zstrip(pSQL,"<>=WC"))
	set pSQL = $piece(pSQL," FROM ",2)
	quit:$find(pSQL," GROUP BY") "" // can't do anything useful with aggregations
	set pSQL = $piece(pSQL," WHERE ",1)
	set pSQL = $piece(pSQL," HAVING ",1)
	set pSQL = $piece(pSQL," ORDER BY ",1)
	set pSQL = $piece(pSQL,",",1) // simplification: stay with the first table
	set:'$find(pSQL,"""") pSQL = $piece($zstrip(pSQL,"<>W")," ",1)
	quit:'$system.SQL.TableExists(pSQL, .tMetadata) ""
	quit $lg(tMetadata,3)
]]></Implementation>
</Method>

<Method name="GetExportPackageName">
<Abstract>1</Abstract>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
</Method>

<Method name="toggleExportAction">
<FormalSpec>dataOnly</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	zen('txtExportCubeClass').setProperty('disabled', dataOnly=='data');
	zen('chkExportOverwriteCls').setProperty('disabled', dataOnly=='data');
	zen('chkExportIKMsr').setProperty('disabled', dataOnly=='data');
]]></Implementation>
</Method>

<Method name="export">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var dataOnly = (zen('radExportAction').getValue()=='data');
	var cubeName = zen('txtExportCube').getValue();
	var cubeClass = zen('txtExportCubeClass').getValue();
	var resultClass = zen('txtExportResultClass').getValue();
	var overwrite = zen('chkExportOverwriteCls').getValue();
	var dropData = zen('chkExportOverwriteData').getValue();
	var srcClass = zen('txtExportSrcClass').getValue();
	var ikMsr = zen('chkExportIKMsr').getValue();
	
	var sc = zenPage.ExportToCubeDefinition(dataOnly, cubeName, cubeClass, resultClass, overwrite, dropData, srcClass, ikMsr);
	if (sc != "OK") {
		alert(sc);
		return;
	}
	zenPage.endModal();
	
	if ((cubeClass != null) && (cubeClass != '')) {
		var parms = { CUBE:cubeName, CLASS:cubeClass };
		zenLaunchPopupWindow('_DeepSee.UI.Dialog.CubeBuild.cls','CubeBuild','status,scrollbars,resizable=yes,width=700,height=600',parms);
	}
]]></Implementation>
</Method>

<Method name="ExportToCubeDefinition">
<FormalSpec>pDataOnly:%Boolean,pCubeName:%String,pCubeClass:%String,pResultClass:%String,pOverwrite:%Boolean,pDropData:%Boolean,pSourceClass:%String="",pAddIKnowMeasure:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		if 'pDataOnly {
			
			if '$zname(pCubeClass,4) {
				set tSC = $$$ERROR($$$ClassNameInvalid, pCubeClass)
				quit
			} elseif $$$defClassDefined(pCubeClass) {
				if (pOverwrite) {
					set tSC = $$Delete^%apiOBJ(pCubeClass,"c-de")
					quit:$$$ISERR(tSC)
				} else {
					set tSC = $$$ERROR($$$ClassAlreadyExist, pCubeClass)
					quit
				}
			}
		
			if ##class(%DeepSee.Utils).%CubeExists(pCubeName) {
				set tSC = $$$ERROR($$$GeneralError, "Cube with name '"_pCubeName_"' already exists in a different class.")
				quit
			}
		}
		
		if '$zname(pResultClass,4) {
			set tSC = $$$ERROR($$$ClassNameInvalid, pResultClass)
			quit
		} elseif $$$defClassDefined(pResultClass) {
			if pDataOnly {
				set:pDropData tSC = $classmethod(pResultClass, "%DeleteExtent")
				quit:$$$ISERR(tSC)
			} else {
				if (pOverwrite) {
					set tSC = $$Delete^%apiOBJ(pResultClass,"c-de")
					quit:$$$ISERR(tSC)
				} else {
					set tSC = $$$ERROR($$$ClassAlreadyExist, pResultClass)
					quit
				}
			}
		} elseif (pDataOnly) {
			set tSC = $$$ERROR($$$ClassDoesNotExist, pResultClass)
			quit
		}
		
		if (pSourceClass'="") && '$$$defClassDefined(pSourceClass) {
			set tSC = $$$ERROR($$$ClassDoesNotExist, pSourceClass)
			quit
		}
		
		// create persistent class for test results
		if 'pDataOnly {
			#dim tSourceClass As %Dictionary.ClassDefinition = ##class(%Dictionary.ClassDefinition).%New()
			set tSourceClass.Name = pResultClass
			set tSourceClass.Super = "%Persistent"
			set tProp = ##class(%Dictionary.PropertyDefinition).%New()
			set tProp.Name = "ActualValue"
			set tProp.Type = "%String"
			do tSourceClass.Properties.Insert(tProp)
			set tProp = ##class(%Dictionary.PropertyDefinition).%New()
			set tProp.Name = "PredictedValue"
			set tProp.Type = "%String"
			do tSourceClass.Properties.Insert(tProp)
			set tProp = ##class(%Dictionary.PropertyDefinition).%New()
			set tProp.Name = "Probability"
			set tProp.Type = "%Numeric"
			do tSourceClass.Properties.Insert(tProp)
			set tProp = ##class(%Dictionary.PropertyDefinition).%New()
			set tProp.Name = "TestRecordId"
			set tProp.Type = "%String"
			do tSourceClass.Properties.Insert(tProp)
			if (pSourceClass'="") {
				set tProp = ##class(%Dictionary.PropertyDefinition).%New()
				set tProp.Name = "Record"
				set tProp.Type = pSourceClass
				set tProp.Calculated = 1
				set tProp.SqlComputed = 1
				set tProp.SqlComputeCode = "set {Record} = {TestRecordId}"
				do tSourceClass.Properties.Insert(tProp)
			}
			if (pAddIKnowMeasure) {
				set tProp = ##class(%Dictionary.PropertyDefinition).%New()
				set tProp.Name = "Text"
				set tProp.Type = "%String"
				do tProp.Parameters.SetAt("", "MAXLEN")
				do tSourceClass.Properties.Insert(tProp)
			}
			set tProp = ##class(%Dictionary.PropertyDefinition).%New()
			set tProp.Name = "TestId"
			set tProp.Type = "%Integer"
			do tSourceClass.Properties.Insert(tProp)
			set tSC = tSourceClass.%Save()
			quit:$$$ISERR(tSC)
			set tSC = $system.OBJ.Compile(pResultClass,"c-d")
			quit:$$$ISERR(tSC)
		}
		
		// copy test results into this table
		set tTableName = ##class(%DeepSee.Utils).%GetSQLTableName(pResultClass)
		set tSQL = "INSERT INTO "_tTableName_" (TestId, TestRecordId, ActualValue, PredictedValue, Probability"
		set:pAddIKnowMeasure tSQL = tSQL _ ", Text"
		set tSQL = tSQL _ ") SELECT TestId, TestRecordId, ActualValue, PredictedValue, Probability"
		set:pAddIKnowMeasure tSQL = tSQL _ ", (SELECT _Text FROM ("_..customSQL_") WHERE _ID = TestRecordId)"
		set tSQL = tSQL _ " FROM %DeepSee_PMML_Utils.TempResult WHERE TestId = ?"
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare(tSQL)
		quit:$$$ISERR(tSC)
		do tStatement.%Execute(..testId)
		
		if 'pDataOnly {
			// create cube definition
			set tCube = ##class(%DeepSee.Model.cube).%New()
			set tCube.name = pCubeName
			set tCube.buildRestriction = "TestId = "_..testId
			set tCube.sourceClass = pResultClass
			
			set tDim = ##class(%DeepSee.Model.dimension).%New()
			set tDim.name = "ActualValueD"
			set tDim.type = "data"
			do tCube.dimensions.Insert(tDim)
			set tHier = ##class(%DeepSee.Model.hierarchy).%New()
			set tHier.name = "H1"
			do tDim.hierarchies.Insert(tHier)
			set tLevel = ##class(%DeepSee.Model.level).%New()
			set tLevel.name = "ActualValue"
			set tLevel.displayName = "Actual Value"
			set tLevel.sourceProperty = "ActualValue"
			do tHier.levels.Insert(tLevel)
			
			set tDim = ##class(%DeepSee.Model.dimension).%New()
			set tDim.name = "PredictedValueD"
			set tDim.type = "data"
			do tCube.dimensions.Insert(tDim)
			set tHier = ##class(%DeepSee.Model.hierarchy).%New()
			set tHier.name = "H1"
			do tDim.hierarchies.Insert(tHier)
			set tLevel = ##class(%DeepSee.Model.level).%New()
			set tLevel.name = "PredictedValue"
			set tLevel.displayName = "Predicted Value"
			set tLevel.sourceProperty = "PredictedValue"
			do tHier.levels.Insert(tLevel)
			
			// TODO: add relationship to original cube if based on Cube DataSource
			
			// add iKnow measure (iKnow-managed domain) for text categorization
			if (pAddIKnowMeasure) {
				set tMeasure = ##class(%DeepSee.Model.measure).%New()
				set tMeasure.name = "Text"
				set tMeasure.type = "iKnow"
				set tMeasure.iKnowSource = "string"
				set tMeasure.sourceProperty = "Text"
				do tCube.measures.Insert(tMeasure)
			}
			
			
			set tClass = ##class(%Dictionary.ClassDefinition).%New()
			set tClass.Name = pCubeClass
			set tClass.Super = "%DeepSee.CubeDefinition"
			set tXData = ##class(%Dictionary.XDataDefinition).%New()
			set tXData.Name = "Cube"
			set tXData.XMLNamespace = "http://www.intersystems.com/deepsee"
			set tSC = tCube.XMLExportToStream(tXData.Data)
			quit:$$$ISERR(tSC)
			do tClass.XDatas.Insert(tXData)
			
			
			set tSC = tClass.%Save()
			quit:$$$ISERR(tSC)
			set (tClass, tProp, tXData) = ""
			
			set tSC = $system.OBJ.Compile(pCubeClass, "c-d")
			quit:$$$ISERR(tSC)
		}
		
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit $s($$$ISERR(tSC):$system.Status.GetErrorText(tSC), 1:"OK")
]]></Implementation>
</Method>

<XData name="Style">
<Data><![CDATA[
<style type="text/css">

.pmmlResultLabel {
	font-size: 20px;
	margin-right: 10px;
}
.pmmlResultControl {
	font-size: 20px;
	border: 0px;
}

.svgFrame {
	border: none;
}

.tabGroupBody {
	min-height: 100px;
}

img.btnAdvancedMode {
	width: 25px;
	height: 25px;
	cursor: pointer;
}

</style>
]]></Data>
</XData>

<XData name="SVGStyle">
<Data><![CDATA[
<style type="text/css">

.chart-background, .chart-plotArea {
	fill: white;
	stroke:none;
}

</style>
]]></Data>
</XData>

<Method name="%OnGetTitle">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if (..definitionClass'="") {
		quit ..definitionClass
	} else {
		quit ..%OnGetPageName()
	}
]]></Implementation>
</Method>

<Method name="onContValElementClick">
<FormalSpec>chart</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var item = chart.getSelectedItem();
	if (item < 0) return;
	var sc = zenPage.SetRowIdByPosition(item);
	if (sc == 1) {
		zen('htmlRecord').refreshContents();
		zen('popRecordDetails').show();
	}
]]></Implementation>
</Method>

<Method name="SetRowIdByPosition">
<FormalSpec>pPosition:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set ..currentRowId = ""
		
		// first check if we have an identifier in the data source
		if '..CheckDataSourceHasIdentifier() {
			set tSC = $$$ERROR($$$GeneralError, "Can only drill to row-level details if _ID column selected in custom SQL")
			quit
		}
		
		// we're looking for the pPosition'th row in %DeepSee_PMML_Utils.TempResult, which is
		// what jsonScatter was based on
		set tSQL = "SELECT TOP "_(pPosition+1)_" * FROM %DeepSee_PMML_Utils.TempResult WHERE TestId = "_..testId_" ORDER BY %ID"
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare(tSQL)
		quit:$$$ISERR(tSC)
		
		set tResult = tStatement.%Execute(), tLastRow = ""
		while (tResult.%Next()) {
			set tLastRow = tResult.%Get("TestRecordId")
		}
		set ..currentRowId = tLastRow
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	if $$$ISERR(tSC) {
		set tMessage = $zcvt($system.Status.GetErrorText(tSC),"O","JS")
		&js<alert('#(tMessage)#');>
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="CheckDataSourceHasIdentifier">
<Internal>1</Internal>
<ReturnType>%Boolean</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[	quit 0
]]></Implementation>
</Method>

<Method name="DrawRecordDetails">
<FormalSpec>pSeed:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="OnDrawRibbon">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	&html<<td><img src="images/spacer.gif" height="1" width="20"></td>>
	
	set tImage = $s(..hideAdvanced:"ds2_gear2_44.png", 1:"ds2_gear_44.png")
	set tTitle = $s(..hideAdvanced:"Show advanced options", 1:"Hide advanced options")
	set tStyle = $s(..hideAdvanced:"opacity:0.3;", 1:"")
	&html<<td><img src="deepsee/ds2_gear2_44.png" class="btnAdvancedMode" style="#(tStyle)#" onclick="zenPage.toggleAdvancedMode(!zenPage.getProperty('hideAdvanced'));" title="#(tTitle)#" /></td>>
	
	&html<<td width="40%">&nbsp;</td>>
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="toggleAdvancedMode">
<FormalSpec>hide</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('hideAdvanced', hide);
	
	zen('grpTestParams').setProperty('hidden', hide);
	
	zen('toolRibbon').refreshContents();
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.UI.AnalysisBase">
<Abstract>1</Abstract>
<Hidden>1</Hidden>
<Super>%ZEN.Component.page</Super>
<System>4</System>
<TimeCreated>62844,39577.200183</TimeCreated>

<Parameter name="AUTONS">
<Default>1</Default>
</Parameter>

<Parameter name="DOMAIN">
<Default>PMML</Default>
</Parameter>

<Parameter name="RESOURCE">
<Default>%Development</Default>
</Parameter>

<Property name="sourceType">
<Type>%ZEN.Datatype.string</Type>
<InitialExpression>"cube"</InitialExpression>
<Parameter name="VALUELIST" value=",cube,sql"/>
<Parameter name="ZENURL" value="SOURCETYPE"/>
</Property>

<Property name="sql">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="cubeName">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="ZENURL" value="CUBE"/>
</Property>

<Property name="cubeFilter">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="ZENURL" value="FILTER"/>
</Property>

<XData name="DataSourcePane">
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<pane labelPosition="top" valign="top" cellStyle="padding-bottom:8px;" name="DataSourcePane">
<radioSet id="selSourceType" label="Source type" valueList="cube,sql" value="cube"
 onchange="zenPage.changeSourceType();" />
<select id="selCube" label="Subject area" onchange="zenPage.changeCube();"
	hint="Data source this model is based on" />
<text id="txtFilter" label="Filter condition" size="50" onchange="zenPage.setProperty('cubeFilter', zen('txtFilter').getValue());"
	hint="MDX expression to filter data source records" />
<textarea id="txtSQL" label="SQL query" rows="5" cols="30" 
onchange="zenPage.changeSQL();" disabled="true" />
</pane>
]]></Data>
</XData>

<Method name="%OnAfterCreatePage">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tSC = ##class(%DeepSee.Utils).%GetCubeList(.tCubes,, 1)
		quit:$$$ISERR(tSC)
		set tCubeName="", tValueList="", tDisplayList=""
		for {
			set tCubeName = $order(tCubes(tCubeName), 1, tInfo)
			quit:tCubeName=""
			
			set tValueList = $s(tValueList="":"", 1:tValueList_",") _ tCubeName
			set tCaption = $li(tInfo,2), tCaption = $s(tCaption="":tCubeName, 1:tCaption)
			set tDisplayList = $s(tDisplayList="":"", 1:tDisplayList_",") _ tCaption
		}
		
		set cSelCube = ..%GetComponentById("selCube")
		set cSelCube.valueList = tValueList
		set cSelCube.displayList = tDisplayList
		
		if $d(%request.Data("CUBE",1), tCubeName) {
			set cSelCube.value = $$$UPPER(tCubeName)
			set tSC = ..ChangeSource("cube",tCubeName)
			quit:$$$ISERR(tSC)
		} elseif $d(%request.Data("SQL",1), tSQL) {
			do ..%SetValueById("selSourceType", "sql")
			do ..%SetValueById("txtSQL", tSQL)
			set tSC = ..ChangeSource("sql", tSQL)
			quit:$$$ISERR(tSC)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="CreateDataset">
<FormalSpec><![CDATA[*pSC:%Status,&pFields,pName:%String=""]]></FormalSpec>
<Private>1</Private>
<ReturnType>%DeepSee.PMML.Dataset.Base</ReturnType>
<Implementation><![CDATA[
	set pSC = $$$OK, tDataset = ""
	try {
		set:pName="" pName = "Analysis dataset"
		if (..sourceType = "cube") {
			set tDataset = ##class(%DeepSee.PMML.Dataset.Cube).%Create(pName, ..cubeName, .pFields, ..cubeFilter, .pSC)
		} else {
			set tDataset = ##class(%DeepSee.PMML.Dataset.SQL).%Create(pName, ..sql, .pFields,,, .pSC)
		}
	} catch (ex) {
		set pSC = ex.AsStatus()
	}
	quit tDataset
]]></Implementation>
</Method>

<Method name="ChangeSourceStr">
<FormalSpec>pType:%String,pSource:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tSC = ..ChangeSource(pType, pSource)
	quit $s($$$ISERR(tSC):$system.Status.GetErrorText(tSC), 1:"OK")
]]></Implementation>
</Method>

<Method name="ChangeSource">
<Final>1</Final>
<FormalSpec>pType:%String,pSource:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set ..sourceType = pType
		
		if (pType = "cube") {
			
			set ..cubeName = pSource
			set ..cubeFilter=""
			
		} elseif (pType="sql") {
			
			set ..sql = pSource
			
		}
		
		set tSC = ..OnChangeSource(pType, pSource)
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="OnChangeSource">
<FormalSpec>pType:%String,pSource:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="GetSourceFields">
<Description>
returns: pFields(n) = $lb(name, spec, dataType, opType)</Description>
<FormalSpec>*pFields</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		kill pFields
		
		if (..sourceType = "cube") {
			
			do ##class(%DeepSee.Utils).%GetCubeLevels(..cubeName, .tLevels, 1)
			set i=""
			for {
				set i = $order(tLevels(i), 1, tInfo)
				quit:i=""
				
				set tType = $li(tInfo,1)
				continue:(tType="m")||(tType="r")
				
				set tDimName = $li(tInfo,2), tHierName = $li(tInfo,3), tLevelName = $li(tInfo,4)
				set tSpec = "["_tDimName_"].["_tHierName_"].["_tLevelName_"]"
				do ##class(%DeepSee.Utils).%GetMemberCaption(..cubeName, tDimName, tHierName, tLevelName, .tCaption)
				
				//set tMbrCount = ##class(%DeepSee.Utils).%GetCubeMemberCount(..cubeName, .tSC, tDimName, tHierName, tLevelName)
				//quit:$$$ISERR(tSC)
				
				set pFields($i(pFields)) = $lb(tCaption, tSpec, "string", "categorical")
			}
			quit:$$$ISERR(tSC)
			
		} elseif (..sourceType="sql") && (..sql'="") {
			
			set tStatement = ##class(%SQL.Statement).%New()
			set tSC = tStatement.%Prepare(..sql)
			quit:$$$ISERR(tSC)
				
			if (tStatement.%Metadata.statementType'=1) {
				set tSC = $$$ERROR($$$GeneralError, "Only SELECT queries allowed here")
				quit
			}
			
			for i = 1:1:tStatement.%Metadata.columnCount {
				#dim tCol As %SQL.StatementColumn = tStatement.%Metadata.columns.GetAt(i)
				
				set tDataType = $case(tCol.clientType, 7:"string", 10:"string", 5:"integer", 16:"boolean", :"double")
				set tOpType = $case(tCol.clientType, 7:"categorical", 10:"categorical", 5:"categorical", 16:"categorical", :"continuous")
				set pFields($i(pFields)) = $lb(tCol.colName, tCol.colName, tDataType, tOpType)
			}
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="changeSourceType">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var srcType = zen('selSourceType').getValue();
	var sc = zenPage.setProperty('souceType', srcType);
	zen('selCube').setProperty('disabled', (srcType != 'cube'));
	zen('txtFilter').setProperty('disabled', (srcType != 'cube'));
	zen('txtSQL').setProperty('disabled', (srcType != 'sql'));
	var sc = zenPage.ChangeSourceStr(srcType, zen((srcType=='cube') ? 'selCube' : 'txtSQL').getValue());
	zenPage.onChangeSourceClient(srcType);
]]></Implementation>
</Method>

<Method name="changeCube">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	zen('txtFilter').setValue('');
	var sc = zenPage.ChangeSourceStr('cube', zen('selCube').getValue());
	if (sc != 'OK') {
		alert(sc);
	}
	zenPage.onChangeSourceClient('cube');
]]></Implementation>
</Method>

<Method name="changeSQL">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	zen('txtFilter').setValue('');
	var sc = zenPage.ChangeSourceStr('sql', zen('txtSQL').getValue());
	if (sc != 'OK') {
		alert(sc);
	}
	zenPage.onChangeSourceClient('sql');
]]></Implementation>
</Method>

<Method name="onChangeSourceClient">
<FormalSpec>type</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
</Method>
</Class>


<Class name="%DeepSee.PMML.UI.DatasetAnalysis">
<Hidden>1</Hidden>
<Super>%DeepSee.PMML.UI.AnalysisBase</Super>
<System>4</System>
<TimeCreated>62844,48688.019293</TimeCreated>

<Property name="fields">
<Type>%ZEN.Datatype.csv</Type>
</Property>

<Property name="dependencyMetric">
<Type>%ZEN.Datatype.string</Type>
<InitialExpression>"PearsonChi2"</InitialExpression>
</Property>

<XData name="Style">
<Data><![CDATA[
<style type="text/css">
table#tblDependencies {
	border: 1px solid black;
}
table#tblDependencies tr {
	border-bottom: 1px solid black;
}
table#tblDependencies tr td {
	padding: 10px;
	text-align: center;
}

span.dependent {
	color: red;
}
</style>
]]></Data>
</XData>

<XData name="Contents">
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<page xmlns="http://www.intersystems.com/zen" enclosingStyle="padding:20px"
	 title="" width="100%" height="100%" >
<hgroup valign="top">
<vgroup valign="top">
<titleBox title="Dataset" />
<pane paneName="DataSourcePane" />
<spacer width="20" />
<multiSelectSet id="chkFields" label="Analyze fields" 
onchange="zenPage.setProperty('fields',zenThis.getValue());" />
</vgroup>
<spacer width="30" />
<vgroup valign="top" cellStyle="padding-bottom:10px">
<titleBox title="Dependencies" />
<hgroup>
<select id="selDependencyMetric" label="Dependency metric" required="true" 
onchange="zenPage.setProperty('dependencyMetric',zenThis.getValue());"
valueList="PearsonChi2,PearsonChi2Yates" showEmpty="false"
displayList="Pearson's Chi,Pearson's Chi with Yates correction" />
<spacer width="20" />
<button caption="calculate" onclick="zen('htmlDependencies').refreshContents();" />
</hgroup>
<html id="htmlDependencies" OnDrawContent="DrawDependencies" />
</vgroup>
</hgroup>
</page>
]]></Data>
</XData>

<Method name="OnChangeSource">
<FormalSpec>pType:%String,pSource:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tSC = ..GetSourceFields(.tFields)
		quit:$$$ISERR(tSC)
		
		set tValueList="", tDisplayList=""
		for i = 1:1:$g(tFields) {
			set tValueList = $s(tValueList="":"", 1:tValueList_",") _ $lts(tFields(i),":")
			set tDisplayList = $s(tDisplayList="":"", 1:tDisplayList_",") _ $li(tFields(i),1)
		}
		
		set cChkFields = ..%GetComponentById("chkFields")
		set cChkFields.valueList = tValueList
		set cChkFields.displayList = tDisplayList
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="onChangeSourceClient">
<FormalSpec>type</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	zen('chkFields').refreshContents();
]]></Implementation>
</Method>

<Method name="DrawDependencies">
<FormalSpec>pSeed:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		quit:..fields=""
		set tDims = $l(..fields,",")
		
		// print table header
		kill tFields, tFieldMap
		&html<<table id="tblDependencies"><tr><td>chi<sup>2</sup><br/>(probability)</td>>
		for i = 1:1:tDims {
			set tField = $piece(..fields,",",i)
			set tFieldName = $piece(tField,":",1)
			&html<<th>#(tFieldName)#</th>>
			
			// and cache details in array for quick access
			set tFieldMap(i) = tFieldName
			set tFieldMap(i,"spec") = $piece(tField,":",2)
			set tFieldMap(i,"datatype") = $piece(tField,":",3)
			set tFieldMap(i,"optype") = $piece(tField,":",4)
			
			set tFields(i) = $lb(tFieldName, $piece(tField,":",2), $piece(tField,":",3), $piece(tField,":",4))
		}
		set tFields = tDims
		&html<</tr>>
		
		#dim tDataset As %DeepSee.PMML.Dataset = ..CreateDataset(.tSC, .tFields)
		quit:$$$ISERR(tSC)
		
		// now print cells
		kill tResults
		for i = 1:1:tDims {
			&html<<tr>>
			&html<<th>#(tFieldMap(i))#</th>>
			
			for j = 1:1:tDims {
				
				&html<<td>>
				
				if (..dependencyMetric["PearsonChi2") {
					if (i<j) {
						set tSC = ##class(%DeepSee.PMML.Dataset.Utils).GetChiSquared(tDataset, tFieldMap(i), tFieldMap(j), .tChiSquared, .tProbability,, (..dependencyMetric["Yates"))
						quit:$$$ISERR(tSC)
						set tChiSquared = $normalize(tChiSquared,4)
						set tProbability = $normalize(tProbability,4)
						set tResults(j,i) = $lb(tChiSquared, tProbability)
						set tClass = $s(tProbability<0.05:"dependent", 1:"independent")
						&html<<span class="#(tClass)#">#(tChiSquared)#<br/>(#(tProbability)#)</span>>
					} elseif (i=j) {
						&html<&nbsp;>
					} else {
						set tChiSquared = $li(tResults(i,j),1)
						set tProbability = $li(tResults(i,j),2)
						set tClass = $s(tProbability<0.05:"dependent", 1:"independent")
						&html<<span class="#(tClass)#">#(tChiSquared)#<br/>(#(tProbability)#)</span>>
					}
				}
				
				&html<</td>>
				
			}
			quit:$$$ISERR(tSC)
			&html<</tr>>
		}
		quit:$$$ISERR(tSC)
		&html<</table>>
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.UI.ModelBuilder">
<Hidden>1</Hidden>
<IncludeCode>%PMML</IncludeCode>
<Super>%DeepSee.PMML.UI.AnalysisBase</Super>
<System>4</System>
<TimeCreated>62780,39726.807248</TimeCreated>

<Parameter name="DEFAULTBUILDERCLASS">
<Type>CLASSNAME</Type>
<Internal>1</Internal>
<Default>%DeepSee.PMML.Builder.NaiveBayes</Default>
</Parameter>

<XData name="Contents">
<Description>
Property modelBuilder As %DeepSee.PMML.Builder.AbstractBuilder;</Description>
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<page xmlns="http://www.intersystems.com/zen" enclosingStyle="padding:20px"
	 width="100%" height="100%" title="PMML Model Builder" >
<jsonProvider id="json" targetClass="%DeepSee.PMML.UI.ModelBuilderData" 
OnSubmitContent="SubmitModelData" OnGetTargetObject="GetModelData" />
<jsonArrayProvider id="jsonFields" controllerId="json" arrayName="fields" />

<form id="form" controllerId="json" >
<tabGroup showTabBar="true" onshowTab="zenPage.onShowTab(zenThis);">
<tab caption="Data source" cellStyle="padding:10px;" layout="vertical">
<titleBox title="Dataset" />
<pane paneName="DataSourcePane" />
<select label="Target field" id="selTargetField" dataBinding="targetFieldSpec"
 onchange="zenPage.changeTargetField(zenThis.getValue());" />
</tab>
<tab caption="Data fields" cellStyle="padding:10px;" >
<titleBox title="Data fields" />
<hgroup cellVAlign="top" height="100%">
<vgroup id="grpFields" enclosingStyle="padding:10px; overflow-y:scroll;" />
<spacer width="40" />
<dataGrid id="grdSelectedFields" controllerId="jsonFields" selectMode="cells" 
ongetlookupdata="return zenPage.gridFieldsLookup(context);" valueColumn="Name"
onaction="return zenPage.gridFieldsAction(row,name,value);" >
<columnDescriptor value="=[@Name]" caption="Name" />
<columnDescriptor value="=[@DisplayName]" caption="Display name" />
<columnDescriptor value="=[@Spec]" readOnly="true" caption="Spec" hidden="true" />
<columnDescriptor value="=[@DataType]" name="DataType" type="lookup" caption="Data type" />
<columnDescriptor value="=[@OpType]" name="OpType" type="lookup" caption="Op type" />
<columnDescriptor value="remove" name="Remove" type="link" />
</dataGrid>
</hgroup>
</tab>
<tab caption="Model properties" cellStyle="padding:10px;" >
<hgroup id="frmModelProps" cellVAlign="top" >
<vgroup>
<titleBox title="Basic model properties" />
<vgroup cellStyle="padding-top:10px" labelPosition="left">
<text label="Model name" dataBinding="builder.ModelName"
 onchange="new function() { if (zen('txtClassName').getValue()=='User.') { zen('txtClassName').setValue('User.'+zenThis.getValue()); } }" />
<select label="Function" dataBinding="builder.FunctionName" showEmpty="false"
onchange="zenPage.updateBuilderProps();"
valueList="associationRules,sequences,classification,regression,clustering,timeSeries,mixed" />
<text label="Algorithm name" dataBinding="builder.AlgorithmName" 
onchange="zenPage.updateBuilderProps();" />
<select id="selModelClass" label="Model type" value="%DeepSee.PMML.Builder.NaiveBayes"
onchange="zenPage.changeModelClass(zenThis.getValue());" showEmpty="false"
sql="select name, $piece(name,'.',$length(name,'.')) from %dictionary.classdefinition where super = '%DeepSee.PMML.Builder.AbstractBuilder'" />
<checkbox label="Output probability" dataBinding="builder.OutputProbability"
onchange="zenPage.updateBuilderProps();" />
</vgroup>
</vgroup>
<spacer width="20" />
<vgroup >
<titleBox title="Model-specific parameters" />
<hidden id="hidPropNames" />
<vgroup id="grpModelProps" cellStyle="padding-top:10px" labelPosition="left" />
</vgroup>
</hgroup>
</tab>
<tab caption="PMML" onshow="zenPage.refreshPMML();" cellStyle="padding:10px" >
<titleBox title="PMML definition" />
<textarea id="txtPMML" rows="20" cols="80" 
hint="Changes made to the PMML definition are lost when navigating away from this tab." />
<hgroup>
<text id="txtClassName" label="Class name" size="50" value="User."
	hint="Class name of the PMML definition" />
<spacer width="20" />
<button caption="save" onclick="zenPage.savePMML();" />
</hgroup>
</tab>
</tabGroup>
</form>
</page>
]]></Data>
</XData>

<Method name="OnChangeSource">
<FormalSpec>pType:%String,pSource:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tSC = ..GetSourceFields(.tFields)
		quit:$$$ISERR(tSC)
		
		set tValueList="", tDisplayList=""
		for i = 1:1:$g(tFields) {
			set tValueList = $s(tValueList="":"", 1:tValueList_",") _ $lts(tFields(i),":")
			set tDisplayList = $s(tDisplayList="":"", 1:tDisplayList_",") _ $li(tFields(i),1)
		}
		
		set cSelTarget = ..%GetComponentById("selTargetField")
		set cSelTarget.valueList = tValueList
		set cSelTarget.displayList = tDisplayList
		
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="onChangeSourceClient">
<FormalSpec>type</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	zenPage.removeAllFields();
	zen('selTargetField').refreshContents();
]]></Implementation>
</Method>

<Method name="onShowTab">
<FormalSpec>tabGroup</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var tab = tabGroup.getCurrTabNo();
	if ((tab != 1) && ((zen('selTargetField').getValue()=='') || (zen('selTargetField').getValue()==null))) {
		alert($$$Text('Select a target field'));
		zen('selTargetField').focus();
		tabGroup.showTab(1);
		return;
	}
	
	if (tab == 2) {
		var sc = zenPage.OnShowTabFields();
		zen('grdSelectedFields').refreshContents();
		return;
	}
]]></Implementation>
</Method>

<Method name="gridFieldsLookup">
<FormalSpec>context</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	switch (context.name) {
		case 'OpType':
			return new Array('categorical', 'continuous', 'ordinal');
		case 'DataType':
			return new Array('string', 'integer', 'float', 'double', 'boolean');
		default:
			return null;
	}
]]></Implementation>
</Method>

<Method name="gridFieldsAction">
<FormalSpec>row,col,value</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	switch (col) {
		case 'Remove':
			var data = zen('json').getContentObject();
			if (data.fields.length == 0) {
				return;
			}
			if (data.fields[row-1].Spec == data.targetFieldSpec.split(':')[1]) {
				alert($$$Text('Cannot remove target field'));
				return;
			}
			var fields = new Array(data.fields.length-1);
			for (var i = 0; i < data.fields.length; i++) {
				if (i == row-1) {
					continue;
				} else {
					fields[(i<row) ? i : i-1] = data.fields[i];
				}
			}
			data.fields = fields;
			zen('json').setContentObject(data);
			zen('grdSelectedFields').refreshContents();
			break;
			
		default:
			break;
	}
]]></Implementation>
</Method>

<Method name="OnShowTabFields">
<ReturnType>%Status</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set tTargetField = ..%GetValueById("selTargetField")
		set tTargetFieldName = $piece(tTargetField,":",1)
		set tTargetFieldSpec = $piece(tTargetField,":",2)
		set tTargetFieldCategorical = ($piece(tTargetField,":",4)="categorical")
		set:tTargetFieldCategorical tDataset = ..CreateDataset(.tSC,, "Test Chi")
		quit:$$$ISERR(tSC)
		
		set tSC = ..GetSourceFields(.tFields) 
		quit:$$$ISERR(tSC)
		
		set cGrpFields = ..%GetComponentById("grpFields")
		do cGrpFields.%RemoveChildren()
		
		for i = 1:1:$g(tFields) {
			set tFieldName = $li(tFields(i),1)
			set tFieldSpec = $li(tFields(i),2)
			set tFieldDataType = $li(tFields(i),3)
			set tFieldOpType = $li(tFields(i),4)
			
			continue:tTargetFieldSpec=tFieldSpec
			
			set cGrpField = ##class(%ZEN.Component.hgroup).%New()
			do cGrpFields.%AddChild(cGrpField)
			
			set cLabel = ##class(%ZEN.Component.label).%New()
			set cLabel.label = tFieldName
			do cGrpField.%AddChild(cLabel)
			
			set cSpacer = ##class(%ZEN.Component.spacer).%New()
			set cSpacer.width = 20
			do cGrpField.%AddChild(cSpacer)
			
			/*if (tTargetFieldCategorical && (tFieldOpType="categorical")) {
				set tSC = ##class(%DeepSee.PMML.Dataset.Utils).GetChiSquared(tDataset, tTargetFieldName, tFieldName, .tChiSquared)
				quit:$$$ISERR(tSC)
				set cLabel.label = tFieldName _ " ("_tChiSquared_")"
			}*/
			
			set cButton = ##class(%ZEN.Component.button).%New()
			set cButton.caption = "add"
			set cButton.onclick = "zenPage.addField('"_tFieldName_"','"_tFieldSpec_"','"_tFieldDataType_"','"_tFieldOpType_"');"
			do cGrpField.%AddChild(cButton)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="changeTargetField">
<FormalSpec>fullSpec</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	fullSpec = fullSpec.split(':');
	zenPage.addField(fullSpec[0], fullSpec[1], fullSpec[2], fullSpec[3]);
]]></Implementation>
</Method>

<Method name="removeAllFields">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var data = zen('json').getContentObject();
	if (data == null) { 
		data = { _class: '%DeepSee.PMML.UI.ModelBuilderData', fields: new Array(0) }; 
	} else {
		data.fields = new Array(0);
	}
	zen('json').setContentObject(data);
]]></Implementation>
</Method>

<Method name="addField">
<FormalSpec>fieldName,spec,dataType,opType</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var field = { _class: '%DeepSee.PMML.Dataset.Field', Name: fieldName, DisplayName: fieldName, Spec: spec, DataType: dataType, OpType: opType };
	
	var data = zen('json').getContentObject();
	var isNew = true;
	if (data == null) { 
		data = { _class: '%DeepSee.PMML.UI.ModelBuilderData', fields: new Array(0) }; 
	} else {
		for (var i = 1; i < data.fields.length; i++) {
			if (data.fields[i].Spec == spec) {
				isNew = false;
				break;
			}
		}
	}
	if (!isNew) { return; }
	
	data.fields[data.fields.length] = field;
	zen('json').setContentObject(data);
	
	zen('grdSelectedFields').refreshContents();
]]></Implementation>
</Method>

<Method name="changeModelClass">
<FormalSpec>modelClass</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.OnChangeModelClass(modelClass);
	sc = zen('grpModelProps').refreshContents();
	if (!zen('json').submitContent('changeClass:'+modelClass)) {
		alert(zen('json').getError());
	}
	zenPage.updateBuilderProps();
]]></Implementation>
</Method>

<Method name="SubmitModelData">
<FormalSpec>pCommand:%String,pProvider:%ZEN.Auxiliary.jsonProvider,pObject:%RegisteredObject,*pResponse:%RegisteredObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set tParams = $p(pCommand,":",2,999)
		set pCommand = $p(pCommand,":",1)
		
		if (pCommand="changeClass") {
			
			set tModelClass = $p(tParams,":",1)
			quit:tModelClass=""
			
			set tBuilder = $classmethod(tModelClass, "%New")
			
			// copy current property values, if any
			if $isobject(pObject) {
	
				set tBuilder.ModelName = pObject.builder.ModelName
				set tBuilder.AlgorithmName = pObject.builder.AlgorithmName
				set tBuilder.FunctionName = pObject.builder.FunctionName
				set tBuilder.Description = pObject.builder.Description
				set tBuilder.OutputProbability = pObject.builder.OutputProbability
				
				// model-specific properties
				set tModelClassObj = ##class(%Dictionary.ClassDefinition).%OpenId(tModelClass)
				set tOldClass = pObject.builder.%ClassName(1)
				for i = 1:1:tModelClassObj.Properties.Count() {
					set tProp = tModelClassObj.Properties.GetAt(i)
					continue:$e(tProp)="%"
					continue:tProp.Transient
					continue:tProp.Calculated
					continue:tProp.Internal
					if ##class(%Dictionary.PropertyDefinition).%ExistsId(tOldClass_"||"_tProp.Name) {
						set $property(tBuilder,tProp.Name) = $property(pObject.builder, tProp.Name)
					}
				}
			}
			
			set pObject.builder = tBuilder
			do pProvider.%SetTargetObject(pObject)
			set pResponse = pObject
			
		} elseif (pCommand="BuildPMML") {
			
			#dim tBuilder As %DeepSee.PMML.Builder.AbstractBuilder
			set tBuilder = pObject.builder
			
			// set TargetField and Dataset
			set tBuilder.TargetField = $piece(pObject.targetFieldSpec,":",1)
			set tBuilder.Dataset = ..CreateDataset(.tSC, pObject.fields, "Training dataset")
			quit:$$$ISERR(tSC)
			
			set tSC = tBuilder.%SerializeObject(.tSerialBuilder)
			quit:$$$ISERR(tSC)
			set tSC = tBuilder.Dataset.%Save()
			quit:$$$ISERR(tSC)
			
			set tSC = ..%RunBackgroundMethod("BuildPMMLAsync", tSerialBuilder, tBuilder.Dataset.%Id())
			quit:$$$ISERR(tSC)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="BuildPMMLAsync">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pBuilder:%String,pDatasetId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK			
	try {
		do ..%SetBackgroundMethodStatus("Building PMML model...")
		
		kill ^IRIS.Temp.PMML.BgrTask($j)
		
		// instantiate Builder object from serialized form
		set tBuilder = ##class(%SerialObject).%Open(pBuilder)
		
		// instantiate Dataset object from persistent storage
		set tBuilder.Dataset = ##class(%DeepSee.PMML.Dataset.Base).%OpenId(pDatasetId)
		
		set tSC = tBuilder.GeneratePMML(.tPMML)
		quit:$$$ISERR(tSC)
		set tSC = tPMML.%ToString(.tPMMLString)
		quit:$$$ISERR(tSC)
		
		set ^IRIS.Temp.PMML.BgrTask(+$j) = tPMMLString
	
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	
	set ^IRIS.Temp.PMML.BgrTask(+$j, "status") = tSC
	
	// clean up persisted dataset object
	do ##class(%DeepSee.PMML.Dataset.Base).%DeleteId(pDatasetId)
	
	do ..%EndBackgroundMethod()
	
	quit tSC
]]></Implementation>
</Method>

<Method name="%OnFinishBackgroundTask">
<ClassMethod>1</ClassMethod>
<FormalSpec>pTaskID:%String</FormalSpec>
<Implementation><![CDATA[
	set tSC = $g(^IRIS.Temp.PMML.BgrTask(+pTaskID, "status"))
	
	if $$$ISERR(tSC) {
		
		set tError = $zconvert($system.Status.GetErrorText(tSC), "O", "JS")
		&js<zen('txtPMML').setValue('Error building PMML:\n#(tError)#');>
		
	} else {
		
		set tString = $g(^IRIS.Temp.PMML.BgrTask(+pTaskID))
		set tJSString = $zconvert(tString,"O","JS")
		&js<zen('txtPMML').setValue('#(tJSString)#');>
		
	}
	
	kill ^IRIS.Temp.PMML.BgrTask(+pTaskID)
]]></Implementation>
</Method>

<Method name="updateBuilderProps">
<FormalSpec>id,value</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// workaround for strange builder-property-value-disappearances when other
	// data-bound values are changed: we explicitly set each builder property 
	// value back to its current value according to the JSOn content object
	var props = zen('hidPropNames').getValue().split(',');
	for (var i = 0; i<props.length; i++) {
		if (id == props[i]) {
			zen('input'+props[i]).setValue(value);
		} else {
			var curValue = null;
			sc = eval('curValue = zen(\'json\').getContentObject().builder.'+props[i]+';');
			if (curValue != null) { zen('input'+props[i]).setValue(curValue); }
		}
	}
]]></Implementation>
</Method>

<Method name="OnChangeModelClass">
<FormalSpec>pModelBuilderClass:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tSC = $$$OK			
	try {
		set tGroup = ..%GetComponentById("grpModelProps")
		do tGroup.%RemoveChildren()
		quit:pModelBuilderClass=""
		
		set tClass = ##class(%Dictionary.ClassDefinition).%OpenId(pModelBuilderClass)
		
		#dim tProp As %Dictionary.PropertyDefinition
		set tPropNames = ""
		for i = 1:1:tClass.Properties.Count() {
			set tProp = tClass.Properties.GetAt(i)
			continue:$e(tProp.Name)="%"
			continue:tProp.Transient
			continue:tProp.Calculated
			continue:tProp.Internal
			
			set tPropNames = tPropNames _ "," _ tProp.Name
			set tValues = tProp.Parameters.GetAt("VALUELIST")
			set:$e(tValues)="," tValues = $e(tValues,2,*)
			
			if (tProp.Type = "%Boolean") {
				set tControl = ##class(%ZEN.Component.checkbox).%New()
			} elseif (tValues'="") {
				set tControl = ##class(%ZEN.Component.select).%New()
				set tControl.valueList = tValues
				set tControl.showEmpty = 0
			} else {
				set tControl = ##class(%ZEN.Component.text).%New()
			}
			
			$$$CAMELSPACE(tProp.Name,tPropName)
			set tControl.id = "input"_tProp.Name
			set tControl.originalValue = tProp.InitialExpression
			set tControl.value = tProp.InitialExpression
			set tControl.label = tPropName
			set tControl.hint = tProp.Description
			set tControl.dataBinding = "builder."_tProp.Name
			set tControl.onchange = "zenPage.updateBuilderProps('"_tProp.Name_"');"
			do tGroup.%AddChild(tControl)
		}
		
		set tPropNames = $e(tPropNames,2,*)
		&js<var sc = zen('hidPropNames').setValue('#(tPropNames)#');>
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="refreshPMML">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zen('txtPMML').setValue('building...');
	if (!zen('json').submitContent('BuildPMML', zen('selModelClass').getValue())) {
		zen('txtPMML').setValue('Error building PMML:\n'+zen('json').getError());
	}
	zen('txtPMML').refreshContents();
]]></Implementation>
</Method>

<Method name="GetModelData">
<FormalSpec><![CDATA[&pParameters,*pObject:%RegisteredObject]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set pObject = ##class(%DeepSee.PMML.UI.ModelBuilderData).%New()
	set pObject.builder = $classmethod(..#DEFAULTBUILDERCLASS, "%New")
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnAfterCreatePage">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set tSC = ##super()
		quit:$$$ISERR(tSC)
		
		do ..%SetValueById("selModelClass", ..#DEFAULTBUILDERCLASS)
		do ..OnChangeModelClass(..#DEFAULTBUILDERCLASS)
		
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="savePMML">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var name = zen('txtClassName').getValue();
	var check = zenPage.CheckClassName(name);
	
	switch (check) {
		case 'invalid':
			alert($$$Text('Invalid class name'));
			return;
		case 'inUse':
			if (!confirm($$$Text('Class name "'+name+'" already in use, overwrite?'))) { return; }
		default:
			break;
	}
	
	var sc = zenPage.OnSave(name, zen('txtPMML').getValue());
	if (sc == 'OK') {
		if (confirm('PMML Definition saved successfully\nGo to test page now?')) {
			location.href = zenPage.GetModelURL(name);
		}
	} else {
		alert($$$Text('Error saving PMML')+':\n'+sc);
	}
]]></Implementation>
</Method>

<Method name="CheckClassName">
<Internal>1</Internal>
<FormalSpec>pClassName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	quit:'$zname(pClassName,3) "invalid"
	quit:##class(%Dictionary.ClassDefinition).%ExistsId(pClassName) "inUse"
	quit "OK"
]]></Implementation>
</Method>

<Method name="GetModelURL">
<Internal>1</Internal>
<FormalSpec>pClassName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[	quit "/csp/"_$namespace_"/_DeepSee.PMML.UI.ModelTester.zen?CLASS="_$zconvert(pClassName,"O","URL")
]]></Implementation>
</Method>

<Method name="OnSave">
<Internal>1</Internal>
<FormalSpec>pClassName:%String,pPMML:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		// delete any existing class
		if $$$defClassDefined(pClassName) {
		    set tSC = $$Delete^%apiOBJ(pClassName,"-d")
		    quit:$$$ISERR(tSC)
		}
	    
	    set tClass = ##class(%Dictionary.ClassDefinition).%New()
	    set tClass.Name = pClassName
	    set tClass.Super = "%DeepSee.PMML.Definition"
	    set tClass.ProcedureBlock = 1
	    
	    set tXData = ##class(%Dictionary.XDataDefinition).%New()
	    set tXData.Name = "PMML"
	    set tXData.XMLNamespace = "http://www.intersystems.com/deepsee/pmml"
	    do tXData.Data.Write(pPMML)
	    do tClass.XDatas.Insert(tXData)
	    
	    set tSC = tClass.%Save()
	    quit:$$$ISERR(tSC)
	    set tClass="", tXData=""
	    
	    set tSC = $system.OBJ.Compile(pClassName, "ck-d")
	    quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit $s($$$ISERR(tSC):$system.Status.GetErrorText(tSC), 1:"OK")
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.UI.ModelBuilderData">
<Hidden>1</Hidden>
<Super>%RegisteredObject</Super>
<System>4</System>
<TimeCreated>62780,57054.280746</TimeCreated>

<Property name="fields">
<Type>%DeepSee.PMML.Dataset.Field</Type>
<Collection>list</Collection>
</Property>

<Property name="builder">
<Type>%DeepSee.PMML.Builder.AbstractBuilder</Type>
</Property>

<Property name="targetFieldSpec">
<Type>%String</Type>
</Property>
</Class>


<Class name="%DeepSee.PMML.UI.ModelTester">
<Super>%DeepSee.PMML.UI.AbstractTester</Super>
<System>4</System>
<TimeCreated>62887,44398.280146</TimeCreated>

<Parameter name="PAGENAME">
<Default>PMML Model Tester</Default>
</Parameter>

<Parameter name="DOCBOOKID">
<Default>APMML_testpage</Default>
</Parameter>

<Property name="modelName">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="ZENURL" value="MODEL"/>
</Property>

<Property name="dataSource">
<Type>%ZEN.Datatype.string</Type>
<Parameter name="ZENURL" value="DATASOURCE"/>
</Property>

<Method name="OnGetRibbonInfo">
<FormalSpec>*pDisplay:%Boolean,*pViewIcons:%List,*pSortOptions:%List,*pSearchBox:%Boolean,*pRibbonTitle:%String,*pCommands:%List</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pDisplay = 1
	Set pSearchBox = 0
	Set pRibbonTitle = $$$Text("Predictive Analytics")

	//set pViewIcons(1) = $LB(id,help,icon)
	
	// commands
	// $LB(id,caption,help,onclick)
	set tCount = 0
	set pCommands($i(tCount)) = $lb("cmdNew",$$$Text("New"),$$$Text("Create a PMML definition class from a file"),"zenPage.newModel();")
	set pCommands($i(tCount)) = $lb("cmdOpen",$$$Text("Open"),$$$Text("Open a PMML model"),"zenPage.openModel();")
	set pCommands($i(tCount)) = $lb("cmdRun",$$$Text("Run"),$$$Text("Run this PMML model against the selected data source"),"zenPage.test();")
	set pCommands($i(tCount)) = $lb("cmdTest",$$$Text("Test"),$$$Text("Show PMML model test page"),"zenPage.showTestPage();")
	set pCommands($i(tCount)) = $lb("cmdExport",$$$Text("Export"),"Export test results to cube","zenPage.launchExport();")
	
	Quit $$$OK
]]></Implementation>
</Method>

<XData name="dataSourcePane">
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<pane >
<titleBox id="ttlMainTitle" title="PMML Model" />
<spacer height="5" />
<vgroup cellStyle="padding-bottom:10px;" labelPosition="left">
<select label="Model" id="selModel" showEmpty="false"
 onchange="zenPage.selectModel(zenThis.getValue());" />
<select label="Data source" id="selDataSource" showEmpty="false"
onchange="zenPage.selectDataSource(zenThis.getValue());" />

<textarea label="Custom data source" id="txtSQL" cols="40" rows="6" 
onchange="var msg = zenPage.CheckSQL(zenThis.getValue()); if (msg!='OK') { alert('Error testing custom SQL:\n' + msg); zenThis.focus(); }"
 disabled="true" hint="Enter a valid SQL query. Include an identifier column named _ID to enable drilldown." />
</vgroup>
<spacer height="20" />
</pane>
]]></Data>
</XData>

<Method name="openModel">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	zenLaunchPopupWindow('_DeepSee.UI.Dialog.finderDialog.cls?MODE=pmmlModels','PMML','status,scrollbars,resizable=yes,width=800,height=600');
]]></Implementation>
</Method>

<Method name="selectModel">
<FormalSpec>model</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('modelName', model);
	sc = zenPage.OnSelectModel();
	if (sc!='OK') alert(sc);
	sc = zen('selDataSource').refreshContents(1);
	sc = zenPage.selectDataSource(zenPage.getProperty('dataSource'));
	zen('txtSQL').refreshContents();
	
	sc = zenPage.changeMode();
	sc = zenPage.reset();
]]></Implementation>
</Method>

<Method name="showTestPage">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[	zenLaunchPopupWindow(encodeURIComponent(zenPage.getProperty('definitionClass'))+'.zen?EMBEDDED=1&MODEL='+encodeURIComponent(zen('selModel').getValue()),'TEST','status,scrollbars,resizable=yes,width=800,height=600');
]]></Implementation>
</Method>

<Method name="onloadHandler">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var model = zenPage.getProperty('modelName');
	if (model=='') return;
	var sc = zen('selModel').setValue(model);
	sc = zenPage.selectModel(model);
	
	var ds = zenPage.getProperty('dataSource');
	sc = zen('selDataSource').setValue(ds);
	sc = zenPage.selectDataSource(ds);
	
	this.invokeSuper('onloadHandler', arguments);
]]></Implementation>
</Method>

<Method name="checkDataSource">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (zen('selDataSource').getValue()=='') {
		alert($$$Text('Please select a data source'));
		zen('selDataSource').focus();
		return false;
	}
	return true;
]]></Implementation>
</Method>

<Method name="TestModel">
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set ..testId = 0
		set tSC = ..%RunBackgroundMethod("TestModelAsync", ..definitionClass, ..modelName, ..dataSource, ..customSQL)
				
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit $s($$$ISERR(tSC):$system.Status.GetErrorText(tSC), 1:"OK")
]]></Implementation>
</Method>

<Method name="CheckDataSourceHasIdentifier">
<Internal>1</Internal>
<ReturnType>%Boolean</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tSC = $$$OK, tHasIDColumn = 0
	try {
		if (..dataSource = "CUSTOM") {
			set tHasIDColumn = 0, tCustomSQL = ..customSQL
			
			if (tCustomSQL'="") {
				set tCustomSQLResult = ##class(%SQL.Statement).%New()
				set tSC = tCustomSQLResult.%Prepare(tCustomSQL)
				quit:$$$ISERR(tSC)
				set tHasIDColumn = $d(tCustomSQLResult.%Metadata.columnIndex("_ID"))
			}
		} elseif (..dataSource="VERIFICATION") {
			set tHasIDColumn = 1
		} else {
			#dim tDataset As %DeepSee.PMML.Dataset
			set tSC = $classmethod(..definitionClass, "%CreateDataset", $p(..dataSource,":",2,*), .tDataset)
			quit:$$$ISERR(tSC)
			
			set tHasIDColumn = ($isobject(tDataset.IdField) && (tDataset.IdField.Spec'=""))
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tHasIDColumn
]]></Implementation>
</Method>

<Method name="TestModelAsync">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDefinition:%String,pModelName:%String,pDataSource:%String,pSQL:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK, tTestId=0, tTaskId = +$job
	try {
		do ..%SetBackgroundMethodStatus("Running...", 0)
		kill ^IRIS.Temp.PMML.BgrTask(tTaskId)
		
		if (pDataSource="CUSTOM") {
			set tSC = ##class(%DeepSee.PMML.Utils).%RunModelFromSQL(.tTestId, pDefinition, pModelName, pSQL,, 1)
		} elseif (pDataSource="VERIFICATION") {
			set tSC = ##class(%DeepSee.PMML.Utils).%RunModelFromPMMLRows(.tTestId, pDefinition, pModelName,, 1)
		} else {
			set tSC = ##class(%DeepSee.PMML.Utils).%RunModel(.tTestId, pDefinition, pModelName, $p(pDataSource,":",2,*),, 1)
		}
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus() 
	}
	set ^IRIS.Temp.PMML.BgrTask(tTaskId) = $lb(tTestId, tSC)
	do ..%EndBackgroundMethod()
	quit tSC
]]></Implementation>
</Method>

<Method name="OnSelectModel">
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set (tDisplayList,tValueList,tDefaultSQL) = ""
		
		if (..testId) {
			do ..DropTestResults(..testId)
			set ..testId = 0
		}
		
		if (..definitionClass'="") {
			
			// first find the right Model definition
			set tSC = $classmethod(..definitionClass, "%GetDefinition", .tPMML)
			quit:$$$ISERR(tSC)
			if (..modelName="") {
				set tModelDef = tPMML.Models.GetAt(1)
			} else {
				set tModelCount = tPMML.Models.Count()
				for i = 1:1:tModelCount {
					set tThisModel = tPMML.Models.GetAt(i)
					if (tThisModel.modelName=..modelName) {
						set tModelDef = tThisModel
						quit
					}
					
					// BDB504 - reproduce pseudo model name
					if (tThisModel.modelName="") {
						set tModelClass = $classname(tThisModel)
						set tIndex = $i(tClasses(tModelClass))-1
						set tName = $piece(tModelClass,".",*)_$s(tIndex:tIndex, 1:"")
						if (..modelName=tName) {
							set tModelDef = tThisModel
							quit
						}
					}
				}
			}
			if (tModelDef="") {
				set tSC = $$$ERROR($$$GeneralError, "Could not find model named '"_..modelName_"' in class '"_..definitionClass_"'")
				quit
			}
			
			// store model target type
			set tModelClass = $classmethod(..definitionClass, "%GetModelClassName", ..modelName)
			do $classmethod(tModelClass, "%GetPredictedFieldInfo", .tFieldName, .tFieldDataType, .tFieldOpType)
			set ..mode = tFieldOpType
			
			
			// check if there is a ModelVerification element
			if $isobject(tModelDef.ModelVerification) {
				set tValueList = "VERIFICATION,"
				set tDisplayList = "ModelVerification element in PMML definition,"
			}
			
			
			// now find any X-*DataSource element
			for i = 1:1:tPMML.DataDictionary.Extension.Count() {
				set tExtension = tPMML.DataDictionary.Extension.GetAt(i)
				continue:tExtension.name'="isc:datasource"
				
				for j = 1:1:tExtension.iscExtensions.Count() {
					set tCustomExtension = tExtension.iscExtensions.GetAt(j)
					continue:'tCustomExtension.%IsA("%DeepSee.PMML.Definition.Extension.DataSource")
					
					// use the first SQLDataSource's SQL to populate the SQL textbox
					if (tDefaultSQL="") && tCustomExtension.%IsA("%DeepSee.PMML.Definition.Extension.SQLDataSource") {
						set tDefaultSQL = tCustomExtension.SQL
					}
					
					set tValueList = tValueList _ "DS:"_tCustomExtension.name_","
					set tDisplayList = tDisplayList _ tCustomExtension.name_","
				}
			}
			
			
			// add custom datasource
			set tValueList = tValueList _ "CUSTOM"
			set tDisplayList = tDisplayList _ "Custom data source (SQL)"
			
			
		}
		
		set tSelect = ..%GetComponentById("selDataSource")
		set tSelect.valueList = tValueList
		set tSelect.displayList = tDisplayList
		
		// this value will be picked up by selectModel()
		set (tSelect.value, ..dataSource) = $p(tValueList,",",1)
		
		do ..%SetValueById("txtSQL", tDefaultSQL)
		set ..customSQL = tDefaultSQL
		
		
		set ..currentActualValue = ""
		set ..currentPredictedValue = ""
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit $s($$$ISERR(tSC):$system.Status.GetErrorText(tSC), 1:"OK")
]]></Implementation>
</Method>

<Method name="%OnAfterCreatePage">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set tSC = ##super()
		quit:$$$ISERR(tSC)
		
		set (..%GetComponentById("txtSQL").value, ..customSQL) = $g(%session.Data($classname(),"CustomSQL"))
		
		
		// populate selModel
		set (tValueList, tDisplayList) = ""
		if (..definitionClass'="") {
			if '$$IsDerivedFrom^%occLibrary(..definitionClass, "%DeepSee.PMML.Definition") {
				set tSC = $$$ERROR($$$GeneralError, "Selected class is not a PMML definition: "_..definitionClass)
				quit
			}
			
			set tSC = $classmethod(..definitionClass, "%GetModels", .tModels)
 			quit:$$$ISERR(tSC)
			
			for i = 1:1:tModels {
				set tModel = tModels(i)
				set tValueList = tValueList _ $s(tValueList="":"", 1:",") _ $lg(tModel,1)
				set tDisplayList = tDisplayList _ $s(tDisplayList="":"", 1:",") _ $lg(tModel,1)_" ("_$lg(tModel,3)_")"
			}
		}
		
		set tSelPMMLDef = ..%GetComponentById("selModel")
		set tSelPMMLDef.valueList = tValueList
		set tSelPMMLDef.displayList = tDisplayList
		
		// will be picked up by onloadHandler()
		set (tSelPMMLDef.value, ..modelName) = $p(tValueList,",",1)
		
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%OnGetPageName">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit $$$Text("PMML Model Tester")
]]></Implementation>
</Method>

<Method name="DrawRowID">
<FormalSpec>pTable:%ZEN.Component.tablePane,pName:%String,pSeed:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	write %query("_ID")
	quit $$$OK
]]></Implementation>
</Method>

<Method name="GetExportPackageName">
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[	quit ..definitionClass _ "." _ ..modelName
]]></Implementation>
</Method>

<Method name="OnBuildRowDetailsQuery">
<FormalSpec>*pSQL:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set tHasIDColumn = 0, tCustomSQL = ""
		
		if ($e(..dataSource,1,3)="DS:") {
			
			set tSC = $classmethod(..definitionClass, "%CreateDataset", $e(..dataSource,4,*), .tDS)
			quit:$$$ISERR(tSC)
			if (tDS.%IsA("%DeepSee.PMML.Dataset.SQL")) {
				set tCustomSQL = tDS.SQL
			} else {
				set tSC = $$$ERROR($$$NotImplemented) // not supported
				quit
			}
			
		} elseif (..dataSource="CUSTOM") {
			set tCustomSQL = ..customSQL
		}
		
		if (tCustomSQL'="") {
			// we need an _ID column in the custom SQL to tie back to the original row
			set tCustomSQLResult = ##class(%SQL.Statement).%New()
			set tSC = tCustomSQLResult.%Prepare(tCustomSQL)
			quit:$$$ISERR(tSC)
			merge tColumns = tCustomSQLResult.%Metadata.columnIndex
			set tHasIDColumn = $d(tColumns("_ID"))
			set tSELECT = "", tCol = ""
			for {
				set tCol = $order(tColumns(tCol), 1, tColData)
				quit:tCol=""
				continue:tCol="_ID"
				set tColName = $li(tColData,2)
				if $system.SQL.IsReservedWord(tColName) {
					set tSELECT = tSELECT _ ", s."_$$$QUOTE(tColName)
				} else {
					set tSELECT = tSELECT _ ", s."_tColName
				}
			}
		}
		
		if 'tHasIDColumn {
			set tSC = $$$ERROR($$$GeneralError, "Can only drill to row-level details if _ID column selected in custom SQL")
			quit
		}
		
		set tSELECT = "SELECT s._ID"_tSELECT
		set pSQL = tSELECT _ " FROM ("_tCustomSQL_") s, %DeepSee_PMML_Utils.TempResult r"
		set pSQL = pSQL _ " WHERE r.TestId = "_..testId_" AND r.ActualValue = '"_..currentActualValue_"' AND r.PredictedValue = '"_..currentPredictedValue_"' AND r.TestRecordId = s._ID"
		
	} catch (ex) {
		set tSC = $$$OK
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="selectDataSource">
<FormalSpec>ds</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('dataSource', ds);
	zen('txtSQL').setProperty('disabled', (ds=='CUSTOM') ? false : true);
	zenPage.DropTestResults(0);
	zenPage.reset();
]]></Implementation>
</Method>

<XData name="moreContentPane">
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<pane>
<modalGroup id="modNew" groupTitle="New PMML class" >
<form id="formUpload" enctype="multipart/form-data" labelPosition="left" cellStyle="padding: 3px;">
<text id="txtUploadClass" label="Class name" name="ClassName" controlStyle="width:350px;" />
<fileUpload id="fileUpload" label="PMML file" name="File" size="30"/>
<submit id="btnImport" caption="Import" onclick="zen('btnImport').setProperty('caption','Importing...'); zen('btnImport').setProperty('disabled',true);" />
</form>
</modalGroup>
</pane>
]]></Data>
</XData>

<Method name="newModel">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	zen('btnImport').setProperty('caption','Import');
	zen('btnImport').setProperty('disabled',false);
	zen('modNew').show();
]]></Implementation>
</Method>

<Method name="%OnSubmit">
<ClassMethod>1</ClassMethod>
<FormalSpec>pSubmit:%ZEN.Submit</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set tName = pSubmit.%GetValue("ClassName")
		set tStream = pSubmit.%GetStream("File")

		if ((tName'="") && ($IsObject(tStream))) {
			
			set tSC = ##class(%DeepSee.PMML.Utils).CreateFromStream(tStream, tName, 0, 1, 0)
			quit:$$$ISERR(tSC)
			
			set %response.Context("CLASS") = tName
		}

	} catch(ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="DrawRecordDetails">
<FormalSpec>pSeed:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if '..CheckDataSourceHasIdentifier() {
			write "<p>Data source should select a row identifier to be able to drill to the detail level.</p>"
			quit
		}
		
		// first build an array with all available fields, based on the selected data source row
		kill tData
		set tCubeBased = 0
		if (..dataSource="CUSTOM") {
			
			//set tSQL = "SELECT s.*, t.* FROM ("_..customSQL_") s JOIN %DeepSee_PMML_Utils.TempResult t ON s._ID = t.TestRecordId WHERE t.TestId = ? AND _ID = ?"
			set tSQL = "SELECT * FROM ("_..customSQL_") s WHERE _ID = ?"
			set tStatement = ##class(%SQL.Statement).%New()
			set tSC = tStatement.%Prepare(tSQL)
			quit:$$$ISERR(tSC)
			
			set tResult = tStatement.%Execute(..currentRowId)
			quit:'tResult.%Next()
			
			for i = 1:1:tStatement.%Metadata.columnCount {
				set tData(tStatement.%Metadata.columns.GetAt(i).colName) = tResult.%GetData(i)
			}
			
		} elseif (..dataSource="VERIFICATION") {
			
			#dim tPMML As %DeepSee.PMML.Definition.PMML
			set tSC = $classmethod(..definitionClass, "%GetDefinition", .tPMML)
			quit:$$$ISERR(tSC)
			#dim tModel As %DeepSee.PMML.Definition.Models.AbstractModel
			if (..modelName="") {
				set tModel = tPMML.Models.GetAt(1)
			} else {
				kill tModelNames
				for i = 1:1:tPMML.Models.Count() {
					set tThisModel = tPMML.Models.GetAt(i)
					if (tThisModel.modelName = ..modelName) {
						set tModel = tThisModel
					} elseif (tThisModel.modelName = "") {
						set tModelClass = $piece($classname(tThisModel),".",*)
						if (..modelName = (tModelClass_$i(tModelNames(tModelClass)))) {
							set tModel = tThisModel
						}
					}
				}
			}
			set tSC = tModel.ModelVerification.InlineTable.%GetRows(.tRowData)
			quit:$$$ISERR(tSC)
			for i = 1:1:tModel.ModelVerification.Fields.Fields.Count() {
				set tField = tModel.ModelVerification.Fields.Fields.GetAt(i)
				set tData(tField.field) = tRowData(..currentRowId, i)
			}
			
		} else {
			
			#dim tDataset As %DeepSee.PMML.Dataset
			set tDataSourceName = $p(..dataSource,":",2,*)
			set tSC = $classmethod(..definitionClass, "%CreateDataset", tDataSourceName, .tDataset)
			quit:$$$ISERR(tSC)
			
			if tDataset.%IsA("%DeepSee.PMML.Dataset.SQL") {
				
				set tStatement = ##class(%SQL.Statement).%New()
				set tIdFieldSpec = tDataset.IdField.Spec
				$$$QUOTEIFRESERVED(tIdFieldSpec)
				set tSC = tStatement.%Prepare("SELECT * FROM (" _tDataset.SQL_ ") WHERE "_tIdFieldSpec_" = ?")
				quit:$$$ISERR(tSC)
				
				set tResult = tStatement.%Execute(..currentRowId)
				quit:'tResult.%Next()
				
				for i = 1:1:tStatement.%Metadata.columnCount {
					set tData(tStatement.%Metadata.columns.GetAt(i).colName) = tResult.%GetData(i)
				}
				
			} elseif tDataset.%IsA("%DeepSee.PMML.Dataset.Cube") {
				
				set tCubeBased = 1, tCubeName = tDataset.CubeName
				
			} else {
				set tSC = $$$ERROR($$$NotImplemented)
				quit
			}
		}
		
		// now create an input object for this data array
		set tSC = $classmethod(..definitionClass, "%GetModelInstance", ..modelName, .tModel)
		quit:$$$ISERR(tSC)
		#dim tInputObj As %DeepSee.PMML.ModelInput
		if (tCubeBased) {
			set tSC = $classmethod(tModel.%GetDataClassName(), "%CreateFromDeepSee", ..currentRowId, .tDataObj, tDataSourceName)
			quit:$$$ISERR(tSC)
			set tInputObj = $classmethod(tModel.%GetInputClassName(), "%CreateFromObject", tDataObj, .tSC)
		} else {
			set tInputObj = $classmethod(tModel.%GetInputClassName(), "%CreateFromArray", .tData, .tSC)
		}
		quit:$$$ISERR(tSC)
		
		// run the model for convenience
		#dim tOutputObj As %DeepSee.PMML.ModelOutput
		set tSC = tModel.%ExecuteModel(tInputObj, .tOutputObj)
		quit:$$$ISERR(tSC)
		set tPredictedField = tModel.%GetPredictedField()
		
		// now finally start drawing!
		write "<table class=""recordDetails"">"
		
		// main target
		write "<tr class=""recordDetailTitle""><td colspan=""2"">Target field: "_tPredictedField_"</td></tr>"
		write "<tr><td>Actual: "_$justify($s(tCubeBased:$property(tDataObj,tPredictedField), 1:$g(tData(tPredictedField))),"",4)_"</td>"
		write "<td>Predicted: "_$justify(tOutputObj.%GetFeatureValue(,tPredictedField),"",4)_"</td></tr>"
		
		// inputs
		do tInputObj.%GetFields(.tInputFields)
		write "<tr class=""recordDetailTitle""><td colspan=""2"">Input fields</td></tr>"
		write "<tr><td>"
		set tField = "", i=0
		for { set tField = $order(tInputFields(tField)) q:tField=""  s x = $i(tInputFields) }
		for {
			set tField = $order(tInputFields(tField))
			quit:tField=""
			set tPropVal = $property(tInputObj, tField)
			set:$isvalidnum(tPropVal)&&(tPropVal#0.0001) tPropVal = $justify(tPropVal,"",4)
			write tField_": "_tPropVal_"<br/>"
			if tInputFields && ($i(i)>=(tInputFields/2)) {
				write "</td><td>"
				set tInputFields = 0
			}
		}
		write "</tr></td>"
		
		// outputs
		do tOutputObj.%GetFields(.tOutputFields)
		write "<tr class=""recordDetailTitle""><td colspan=""2"">Output fields</td></tr>"
		write "<tr><td>"
		set tField = "", i=0
		for { set tField = $order(tOutputFields(tField)) q:tField=""  s x = $i(tOutputFields) }
		for {
			set tField = $order(tOutputFields(tField))
			quit:tField=""
			set tPropVal = $property(tOutputObj, tField)
			set:$isvalidnum(tPropVal)&&(tPropVal#0.0001) tPropVal = $justify(tPropVal,"",4)
			write tField_": "_tPropVal_"<br/>"
			if tOutputFields && ($i(i)>=(tOutputFields/2)) {
				write "</td><td>"
				set tOutputFields = 0
			}
		}
		write "</tr></td>"
		
		// all data
		
		write "</table>"
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<XData name="Style">
<Data><![CDATA[
<style type="text/css">

.modalGroupBody {
	background-color: rgb(231, 230, 244);
}

table.recordDetails {
	font-size: 0.8em;
	margin: 10px;
	margin-top: 0px;
}

tr.recordDetailTitle {
	font-size: 1em;
	font-weight: bold;
	height: 24px;
	vertical-align: bottom;
}
tr.recordDetailTitle td {
	border-bottom: 1px solid black;
}

</style>
]]></Data>
</XData>
</Class>


<Class name="%DeepSee.PMML.Utils.DeepSee">
<IncludeCode>%DeepSee</IncludeCode>
<System>4</System>
<TimeCreated>62854,50579.453377</TimeCreated>

<Method name="GetFactPropertyForSpec">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pSpec:%String,pAsSQL:%Boolean=0,*pExpression:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK, pExpression = ""
	try {
		set tDimNo = 0, tHierNo = 0, tLevelNo = 0
		set tSC = ##class(%DeepSee.Utils).%GetDimensionInfo(pCubeName, pSpec, .tDimNo, .tHierNo, .tLevelNo)
		quit:$$$ISERR(tSC)
		
		set tCubeName = $$$DeepSeeIndex(pCubeName)
		set tLevelInfo = $$$DeepSeeMetaGLVN("cubes",tCubeName,"mbr#",tDimNo,tHierNo,tLevelNo)
		if $li(tLevelInfo,1)="m" {
			set tColName = $$$DeepSeeMetaGLVN("cubes",tCubeName,"msr#",$li(tLevelInfo,5))
			set pExpression = tColName
		} else {
			set tColName = $li(tLevelInfo,7) // TODO: verify, check time dims
			set pExpression = tColName_"."_tColName
		}
		
		set:pAsSQL pExpression = $replace(pExpression,".","->")
				
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="RunModelForListing">
<ClassMethod>1</ClassMethod>
<FormalSpec>pCubeName:%String,pSourceObjectId:%Integer,pDefinitionClass:%String,pModelName:%String="",pFeature:%String="predictedValue"</FormalSpec>
<ReturnType>%String</ReturnType>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	set tSC = $$$OK, tResult = ""
	try {
		set tBaseCube = $$$DeepSeeIndex(pCubeName)
		set tFactId = $o($$$DeepSeeIndexGLVN(tBaseCube, "%sourceId", pSourceObjectId, ""))
		
		// translate NULL values passed in from SQL
		set pModelName = $case(pModelName, $c(0):"", :pModelName)
		
		set tModelClass = $classmethod(pDefinitionClass, "%GetModelClassName", pModelName)
		
		set tModel = $classmethod(tModelClass, "%New")
		set tSC = tModel.%ExecuteModelDeepSee(tFactId, .tOutput)
		quit:$$$ISERR(tSC)
		
		set tResult = tOutput.%GetFeatureValue(pFeature)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit $s($$$ISERR(tSC):$system.Status.GetErrorText(tSC), 1:tResult)
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Utils.Math">
<Description>
This class groups a number of simple mathematical functions used by other PMML code.</Description>
<System>4</System>
<TimeCreated>62930,37671.586726</TimeCreated>

<Method name="Ceil">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNumber:%Double</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	quit $s(pNumber=(pNumber\1):pNumber, pNumber>=0:pNumber\1+1, 1:pNumber\1)
]]></Implementation>
</Method>

<Method name="Floor">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNumber:%Double</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	quit $s(pNumber=(pNumber\1):pNumber, pNumber>=0:pNumber\1, 1:pNumber\1-1)
]]></Implementation>
</Method>

<Method name="Round">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNumber:%Double</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	quit $normalize(pNumber,0)
]]></Implementation>
</Method>

<Method name="CastInteger">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNumber:%Double,pMode:%String(VALUELIST=",ceil,floor,round")</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	quit $case(pMode, "ceil":..Ceil(pNumber), "floor":..Floor(pNumber), "round":..Round(pNumber))
]]></Implementation>
</Method>

<Method name="Factorial">
<ClassMethod>1</ClassMethod>
<FormalSpec>pN:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	set tResult = 1
	for i = 2:1:pN {
		set tResult = tResult * i
	}
	quit tResult
]]></Implementation>
</Method>

<Method name="Binomial">
<ClassMethod>1</ClassMethod>
<FormalSpec>pN:%Integer,pK:%Integer</FormalSpec>
<ReturnType>%Double</ReturnType>
<Implementation><![CDATA[
	set tResult = 1
	for i = 1:1:pK {
		set tResult = tResult * ((pN - (pK - i))/i)
	}
	quit tResult
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Utils.Result">
<Abstract>1</Abstract>
<Super>%RegisteredObject</Super>
<System>4</System>
<TimeCreated>62930,44027.078355</TimeCreated>

<Property name="TestId">
<Type>%Integer</Type>
</Property>

<Property name="ModelClass">
<Type>%String</Type>
<Parameter name="MAXLEN" value="2000"/>
</Property>

<Property name="TestRecordId">
<Type>%String</Type>
<Parameter name="MAXLEN" value="2000"/>
</Property>

<Property name="ActualValue">
<Type>%String</Type>
<Parameter name="MAXLEN" value="2000"/>
</Property>

<Property name="PredictedValue">
<Type>%String</Type>
<Parameter name="MAXLEN" value="2000"/>
</Property>

<Property name="PredictTime">
<Type>%TimeStamp</Type>
</Property>

<Property name="Probability">
<Type>%Double</Type>
</Property>

<Method name="GetNewTestId">
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
</Method>
</Class>


<Class name="%DeepSee.PMML.Utils.TempResult">
<StorageStrategy>IRISTemp</StorageStrategy>
<Super>%Persistent,Result</Super>
<System>4</System>
<TimeCreated>62930,48477.842904</TimeCreated>

<Method name="GetNewTestId">
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	quit $i(^IRIS.Temp.DeepSee.PMML.ResultI("TestIdx"))
]]></Implementation>
</Method>

<Method name="GetCategoryPrecisionMetrics">
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestId:%Integer,pValue:%String,*pPrecision:%Double,*pRecall:%Double,pFMeasure:%Double,*pTruePositive:%Double,*pTrueNegative:%Double,*pFalsePositive:%Double,*pFalseNegative:%Double</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		&SQL(
			SELECT 
				100 * (TruePos / GREATEST(TruePos + FalsePos, 1)) Precision,
				100 * (TruePos / GREATEST(TruePos + FalseNeg, 1)) Recall,
				TruePos, TrueNeg, FalsePos, FalseNeg
			INTO :pPrecision, :pRecall, :pTruePositive, :pTrueNegative, :pFalsePositive, :pFalseNegative
			FROM (
				SELECT 
					SUM(CASE WHEN ActualValue = PredictedValue AND PredictedValue = :pValue THEN 1 ELSE 0 END) TruePos,
					SUM(CASE WHEN ActualValue != PredictedValue AND PredictedValue = :pValue THEN 1 ELSE 0 END) FalsePos,
					SUM(CASE WHEN (ActualValue != PredictedValue OR PredictedValue IS NULL) AND ActualValue = :pValue THEN 1 ELSE 0 END) FalseNeg,
					SUM(CASE WHEN ActualValue != :pValue AND (PredictedValue != :pValue OR PredictedValue IS NULL) THEN 1 ELSE 0 END) TrueNeg
				FROM 
					%DeepSee_PMML_Utils.TempResult r
				WHERE TestId = :pTestId
			)
		)
		set pFMeasure = $s(pPrecision+pRecall:2*pPrecision*pRecall/(pPrecision+pRecall), 1:0)
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="GetAggregatePrecisionMetrics">
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestId:%Integer,*pMacroPrecision:%Double,*pMicroPrecision:%Double,*pMacroRecall:%Double,*pMicroRecall:%Double,*pMacroFMeasure:%Double,*pMicroFMeasure:%Double</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		&SQL(SELECT 
				100 * AVG(TruePos / GREATEST((TruePos + FalsePos),1)) MacroPrecision,
				100 * AVG(TruePos / GREATEST((TruePos + FalseNeg),1)) MacroRecall,
				100 * SUM((TruePos * CategorySize) / GREATEST(TruePos + FalsePos, 1)) / SUM(CategorySize) MicroPrecision,
				100 * SUM((TruePos * CategorySize) / GREATEST(TruePos + FalseNeg, 1)) / SUM(CategorySize) MicroRecall
			 INTO :pMacroPrecision, :pMacroRecall, :pMicroPrecision, :pMicroRecall
			 FROM (
				SELECT RefValue, 
					SUM(CASE WHEN RefValue = PredictedValue AND ActualValue = RefValue THEN 1 ELSE 0 END) TruePos,
					SUM(CASE WHEN RefValue = PredictedValue AND ActualValue != RefValue THEN 1 ELSE 0 END) FalsePos,
					SUM(CASE WHEN (RefValue != PredictedValue OR PredictedValue IS NULL) AND ActualValue = RefValue THEN 1 ELSE 0 END) FalseNeg,
					SUM(CASE WHEN ActualValue = RefValue THEN 1 ELSE 0 END) CategorySize
				FROM 
					%DeepSee_PMML_Utils.TempResult r, 
					(SELECT DISTINCT %EXACT(ActualValue) As RefValue FROM %DeepSee_PMML_Utils.TempResult WHERE TestId = :pTestId) v
				WHERE TestId = :pTestId
				GROUP BY %EXACT(RefValue)
			))
			set pMicroFMeasure = $s(pMicroPrecision+pMicroRecall:2*pMicroPrecision*pMicroRecall/(pMicroPrecision+pMicroRecall), 1:0)
			set pMacroFMeasure = $s(pMacroPrecision+pMacroRecall:2*pMacroPrecision*pMacroRecall/(pMacroPrecision+pMacroRecall), 1:0)
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Index name="TestIdx">
<Properties>TestId</Properties>
</Index>

<Storage name="IRISTemp">
<Type>%Storage.Persistent</Type>
<DataLocation>^IRIS.Temp.DeepSee.PMML.ResultD</DataLocation>
<DefaultData>ResultDefaultData</DefaultData>
<IdLocation>^IRIS.Temp.DeepSee.PMML.ResultD</IdLocation>
<IndexLocation>^IRIS.Temp.DeepSee.PMML.ResultI</IndexLocation>
<StreamLocation>^IRIS.Temp.DeepSee.PMML.ResultS</StreamLocation>
<ExtentSize>100000</ExtentSize>
<Data name="ResultDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>TestId</Value>
</Value>
<Value name="3">
<Value>ModelClass</Value>
</Value>
<Value name="4">
<Value>TestRecordId</Value>
</Value>
<Value name="5">
<Value>ActualValue</Value>
</Value>
<Value name="6">
<Value>PredictedValue</Value>
</Value>
<Value name="7">
<Value>PredictTime</Value>
</Value>
<Value name="8">
<Value>Probability</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%DeepSee.PMML.Utils.TreeBuilder">
<Description><![CDATA[
Utility class to build Tree models for a <class>%DeepSee.PMML.Dataset</class> object.]]></Description>
<Super>%RegisteredObject</Super>
<System>4</System>
<TimeCreated>62838,41018.528568</TimeCreated>

<Property name="Dataset">
<Description>
The dataset to mine.</Description>
<Type>%DeepSee.PMML.Dataset</Type>
</Property>

<Property name="TargetField">
<Description><![CDATA[
The target field whose value is to be derived through this tree. 
This field should be part of <property>Dataset</property>.]]></Description>
<Type>%String</Type>
</Property>

<Property name="Tree">
<Description>
..Tree = $i
..Tree(NodeId) = $lb(parent, targetValue, confidence, count, isLeaf)
..Tree(NodeId, "condition") = [AND|OR|$lb(field, operator, value)]
..Tree(NodeId, "ch", ChildNode) = ""
..Tree(NodeId, "distribution", value) = count</Description>
<Type>%Integer</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="SplitsPerNode">
<Description>
Default (maximum) number of branches per node</Description>
<Type>%Integer</Type>
<InitialExpression>2</InitialExpression>
</Property>

<Property name="MinimalSplitCoverage">
<Description>
Minimal % of the total number of records represented by a node that should be covered by a 
branch. If a branch covers fewer records than this value, it is ignored</Description>
<Type>%Numeric</Type>
<InitialExpression>0.05</InitialExpression>
</Property>

<Property name="TrackDistributions">
<Description>
Whether or not to track distribution information for tree nodes</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="ConsiderNullValues">
<Description>
Whether or not to consider null (missing) values for split criteria</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SplitScoringAlgorithm">
<Description><![CDATA[
Which metric to use to judge split quality. This metric is returned as the split "score"
by <method>FindSplits</method>]]></Description>
<Type>%String</Type>
<InitialExpression>"GiniImpurity"</InitialExpression>
<Parameter name="VALUELIST" value=",Confidence,GiniImpurity,InformationGain"/>
</Property>

<Method name="%OnNew">
<Internal>1</Internal>
<FormalSpec>pDataset:%DeepSee.PMML.Dataset,pTargetField:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		quit:'pDataset.HasField(pTargetField, .tSC)
		set ..Dataset = pDataset
		set ..TargetField = pTargetField
		set ..Tree = 0
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="Reset">
<Description><![CDATA[
After changing building parameters, run this method to erase the current tree structure so
<method>Build</method> can be run again. ]]></Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill ..Tree
	set ..Tree = 0
	quit $$$OK
]]></Implementation>
</Method>

<Method name="Build">
<Description><![CDATA[
<p>Builds a tree structure with a maximum depth of <var>pMaxDepth</var>.</p>
<p>If a tree structure was already built, this method silently exits. Use <method>Reset</method>
to erase an existing tree structure.</p>]]></Description>
<FormalSpec>pMaxDepth:%Integer=3</FormalSpec>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		quit:$d(..Tree(0))
		
		set tSC = ..SplitNode(0)
		quit:$$$ISERR(tSC)
		
		merge tChildrenForLevel(0) = ..Tree(0,"ch")
		for tLevel = 1:1:pMaxDepth {
			set tNode = ""
			for {
				set tNode = $order(tChildrenForLevel(tLevel-1, tNode))
				quit:tNode=""
				
				set tSC = ..SplitNode(tNode)
				quit:$$$ISERR(tSC)
				
				merge tChildrenForLevel(tLevel) = ..Tree(tNode,"ch")
			}
			quit:$$$ISERR(tSC)
		}
		quit:$$$ISERR(tSC)
		
		// append distribution, targetvalue and isLeaf for root node
		set tSC = ..Dataset.Get1DDistribution(..TargetField, .tDistribution)
		quit:$$$ISERR(tSC)
		set tIsLeaf = ($g(tDistribution)=1), tTargetValue = "", tBestCount = ""
		for i = 1:1:$g(tDistribution) {
			set tCount = $li(tDistribution(i),2)
			set tValue = $li(tDistribution(i),1)
			set:tCount>tBestCount tBestCount = tCount, tTargetValue = tValue
			set:..TrackDistributions ..Tree(0,"distribution",$s(tValue="":$c(0), 1:tValue)) = tCount
		}
		set tTotal = tDistribution("total")
		set ..Tree(0) = $lb(,tTargetValue,$s(tTotal:tBestCount/tTotal, 1:0), tTotal, tIsLeaf)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="GetInvertedFilter">
<Description><![CDATA[
Returns the inverse of <var>pFilter</var>, equivalent to a boolean NOT of the entire <var>pFilter</var>.]]></Description>
<FormalSpec><![CDATA[&pFilter,*pInverted]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		kill pInverted
		quit:$g(pFilter)=""
		
		// if pFilter is a single predicate, just invert the operator
		if $listvalid(pFilter) {
			set pInverted = pFilter
			set $li(pInverted,2) = $case($li(pFilter,2), "=":"!=", "!=":"=", ">":"<=", "<":">=", "<=":">", ">=":"<")
			quit
		}
		
		// for composite filters, use Bayes' theorem
		set pInverted = $case($$$UPPER(pFilter), "AND":"OR", "OR":"AND")
		set i = ""
		for {
			set i = $order(pFilter(i))
			quit:i=""
			
			kill tSubFilter, tSubInverted
			merge tSubFilter = pFilter(i)
			set tSC = ..GetInvertedFilter(.tSubFilter, .tSubInverted)
			quit:$$$ISERR(tSC)
			
			merge pInverted(i) = tSubInverted
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="MergeFilters">
<Description><![CDATA[
Appends <var>pOtherFilter</var> to <var>pFilter</var> using <var>pLogic</var> logic]]></Description>
<FormalSpec><![CDATA[&pFilter,&pOtherFilter,pLogic:%String="AND"]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		// if pOtherFilter is empty, just exit
		quit:$g(pOtherFilter)=""
		
		// if pFilter is empty, just start with pLogic
		if $g(pFilter)="" {
			set pFilter = pLogic
		}
		
		// if pFilter is a leaf condition, start with pLogic
		elseif $listvalid(pFilter) {
			set pFilter(1) = pFilter
			set pFilter = pLogic
		}
		
		set tFilterIndex = $o(pFilter(""),-1)
		
		// if pOtherFilter is a leaf condition, append it
		if $listvalid(pOtherFilter) {
			set pFilter($i(tFilterIndex)) = pOtherFilter
		}
		
		// if pOtherFilter has the same logic, append its children
		elseif $g(pOtherFilter) = pLogic {
			set i = ""
			for {
				set i = $order(pOtherFilter(i))
				quit:i=""
				
				merge pFilter($i(tFilterIndex)) = pOtherFilter(i)
			}
		}
		
		// if pOtherFilter has different logic, append it as a separate node
		else {
			merge pFilter($i(tFilterIndex)) = pOtherFilter
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="GetNodeFilters">
<Description><![CDATA[
Returns the combination of filter conditions (<var>pFilters</var>) a record should satisfy
to end up in node <var>pNode</var>. This is a combination of the node's own condition, 
its full ancestry and any prior siblings' conditions.]]></Description>
<FormalSpec>pNode:%Integer,*pFilters</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		kill pFilters
		quit:'pNode
		quit:'$d(..Tree(pNode), tDetails)
		
		// check if node condition is not simply "true"
		if $d(..Tree(pNode,"condition")) {
			merge pFilters = ..Tree(pNode,"condition")
		}
		
		// append parent filters
		set tParentNode = $li(tDetails,1)
		if (tParentNode) {
			set tSC = ..GetNodeFilters(tParentNode, .tParentFilters)
			quit:$$$ISERR(tSC)
			
			set tSC = ..MergeFilters(.pFilters, .tParentFilters)
			quit:$$$ISERR(tSC)
		}
		
		// append inverse of *preceding* sibling filters
		set tSiblingNode = pNode
		for {
			set tSiblingNode = $order(..Tree(tParentNode, "ch", tSiblingNode), -1)
			quit:tSiblingNode=""
			
			continue:'$d(..Tree(tSiblingNode, "condition"))
			
			// invert sibling condition
			kill tSiblingCondition, tInvertedCondition
			merge tSiblingCondition = ..Tree(tSiblingNode, "condition")
			set tSC = ..GetInvertedFilter(.tSiblingCondition, .tInvertedCondition)
			quit:$$$ISERR(tSC)
			
			set tSC = ..MergeFilters(.pFilters, .tInvertedCondition)
			quit:$$$ISERR(tSC)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="SplitNode">
<Description><![CDATA[
Splits node <var>pNode</var> in <property>SplitsPerNode</property> sub-nodes (or fewer, if
not enough candidate splits satisfy coverage and other selection criteria).]]></Description>
<FormalSpec>pNode:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		// don't bother about leaf nodes
		quit:pNode&&$lg(..Tree(pNode),5)
		
		
		// find candidate splits
		set tSC = ..FindSplits(pNode, .tSplits)
		quit:$$$ISERR(tSC)
		
		
		// select splits with highest "score" and add as child node
		kill tSortedSplits
		for i = 1:1:$g(tSplits) {
			quit:i=""
			if ..MinimalSplitCoverage {
				set tCoverage = $lg(tSplits(i),2)
				continue:(tCoverage<..MinimalSplitCoverage)
				continue:(tCoverage>(1-..MinimalSplitCoverage))
			}
			set tSortedSplits(-$lg(tSplits(i),1), i) = tSplits(i)
		}
		
		kill tGroupCondition
		set tSort = "", tNodesAdded = 0
		for {
			set tSort = $order(tSortedSplits(tSort))
			quit:tSort=""
			
			set i = ""
			for {
				set i = $order(tSortedSplits(tSort, i), 1, tSplit)
				quit:i=""
				
				set tNewNode = $i(..Tree)
				set ..Tree(tNewNode) = $lb(pNode) _ $li(tSplit,3,5)
				merge ..Tree(tNewNode, "condition") = tSplits(i,"condition")
				set ..Tree(pNode,"ch",tNewNode) = ""
				set x = $i(tNodesAdded)
				
				set tGroupCondition($i(tGroupCondition)) = tSplits(i,"condition")
				
				merge:..TrackDistributions ..Tree(tNewNode, "distribution") = tSplits(i,"distribution")
				
				// theoretically, the information gain and other score values for subsequent
				// splits might change because of the preceding split conditions for that node.
				// as we usually look for binary trees, we currently ignore this.
				quit:tNodesAdded>=(..SplitsPerNode-1)
			}
			quit:tNodesAdded>=(..SplitsPerNode-1)
		}
		
		// add <true> node to catch remaining cases
		if tNodesAdded && ($g(tSplits)>(..SplitsPerNode-1)) {
			
			// store node to enable ..GetNodeFilters()
			set tNewNode = $i(..Tree)
			set ..Tree(tNewNode) = $lb(pNode,,,,) // placeholder to be overwritten later!
			set ..Tree(pNode,"ch",tNewNode) = ""
			
			// derive distributions, targetValue and isLeaf
			set tSC = ..GetNodeFilters(tNewNode, .tFilters)
			quit:$$$ISERR(tSC)
			set tSC = ..Dataset.Get1DDistribution(..TargetField, .tDistribution, .tFilters)
			quit:$$$ISERR(tSC)
			set tIsLeaf = ($g(tDistribution)=1), tTargetValue = "", tBestCount = ""
			for i = 1:1:$g(tDistribution) {
				set tCount = $li(tDistribution(i),2)
				set tValue = $li(tDistribution(i),1)
				set:tCount>tBestCount tBestCount = tCount, tTargetValue = tValue
				set:..TrackDistributions ..Tree(tNewNode,"distribution",$s(tValue="":$c(0), 1:tValue)) = tCount
			}
			set tTotal = tDistribution("total")
			
			// if no records left in this <true> node, erase
			if 'tTotal {
				kill ..Tree(tNewNode), ..Tree(pNode,"ch",tNewNode)
			} else {
				
				if $g(tGroupCondition)=1 {
					set tGroupCondition = tGroupCondition(1)
				} else {
					set tGroupCondition = "OR"
				}
				do ..GetInvertedFilter(.tGroupCondition, .tInverse)
				merge ..Tree(tNewNode,"condition") = tInverse
				
				set ..Tree(tNewNode) = $lb(pNode, tTargetValue, tBestCount/tTotal, tTotal, tIsLeaf)
			}
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="FindSplits">
<Description><![CDATA[
Returns an unsorted array of candidate splits for node <var>pNode</var>:
		pSplits(n) = $lb(score, coverage, targetValue, confidence, recordCount, isLeaf)
		pSplits(n,"condition") = ...]]></Description>
<FormalSpec>pNode:%Integer,*pSplits</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		kill pSplits
		set pSplits=0
		
		// build current node filters based on ancestry
		set tSC = ..GetNodeFilters(pNode, .tFilters)
		quit:$$$ISERR(tSC)
		
		kill tFields
		set tFieldName = ""
		for {
			set tField = ..Dataset.Fields.GetNext(.tFieldName)
			quit:tFieldName=""
			continue:tFieldName=..TargetField
			
			set tFields(tFieldName) = tField
		}
		
		// we'll skip fields with simple filter conditions and simple AND arrays
		// composite-filtered fields will eventually be weeded out by coverage criteria
		if ($g(tFilters)'="") && $listvalid($g(tFilters)) {
			
			set tFilterField = $li(tFilters,1)
			set tFilterOperator = $li(tFilters,2)
			if (tFilterOperator="=") || (tFilterOperator="!=") {
				
				// make sure the filtered value is excluded
				set tFilterValue = $li(tFilters,3)
				set tFilterValue = $s(tFilterValue="":$c(0), 1:tFilterValue)
				set tFields(tFilterField, "exclude", tFilterValue) = ""
			} else {
				kill tFields(tFilterField)
			}
			
		} elseif ($g(tFilters)="AND") {
			set i = ""
			for {
				set i = $order(tFilters(i), 1, tFilter)
				quit:i=""
				
				// skip composite subfilters
				continue:'$listvalid(tFilter)
				
				set tFilterField = $li(tFilter,1)
				set tFilterOperator = $li(tFilter,2)
				if (tFilterOperator="=") || (tFilterOperator="!=") {
					
					// make sure the filtered value is excluded
					set tFilterValue = $li(tFilter,3)
					set tFilterValue = $s(tFilterValue="":$c(0), 1:tFilterValue)
					set tFields(tFilterField, "exclude", tFilterValue) = ""
				} else {
					kill tFields(tFilterField)
				}
			}
		}
		
		// build candidate splits for each field
		set tFieldName = ""
		for {
			set tFieldName = $order(tFields(tFieldName), 1, tField)
			quit:tFieldName=""
			
			if (tField.OpType="categorical") {
				
				// now look at the distribution of this field against the target field
				set tSC = ..Dataset.GetXDDistribution($lb(tFieldName, ..TargetField), .tDistribution, .tFilters)
				quit:$$$ISERR(tSC)
				
				// calculate the information gain for each field value
				set i = "", tTotalCount = tDistribution("total")
				for {
					set i = $order(tDistribution(i))
					quit:i=""
					
					// skip "total" and "value" subscripts
					continue:'i 
					
					// skip values already filtered by parent nodes
					set tFieldValue = $g(tDistribution("value",1,i))
					continue:$d(tFields(tField,"exclude",$s(tFieldValue="":$c(0), 1:tFieldValue)))
					
					// skip null values if required
					continue:('..ConsiderNullValues)&&(tFieldValue="")
					
					kill tTrack
					set tRowTotal = $g(tDistribution("total",1,i))
					continue:'tRowTotal
					set tScore = $case(..SplitScoringAlgorithm, "GiniImpurity":1, :0)
					set j = "", tTargetValueCount = 0, tBestCount=0, tTargetValueId=""
					for {
						set j = $order(tDistribution(i,j),1,tCount)
						quit:j=""
						continue:'tCount
						
						set tFreq = tCount/tRowTotal
						if (..SplitScoringAlgorithm = "GiniImpurity") {
							set tScore = tScore - (tFreq**2)
						} elseif (..SplitScoringAlgorithm = "InformationGain") {
							set tScore = tScore - (tFreq * $zlog(tFreq)/$zlog(2))
						}
						set x = $i(tTargetValueCount)
						
						set:(tCount>tBestCount) tBestCount=tCount, tTargetValueId = j
						
						if (..TrackDistributions) {
							set tTrack(j) = tCount
						}
					}
					continue:'tTargetValueCount
					set tIsLeaf = (tTargetValueCount=1)
					set tConfidence = tBestCount/tRowTotal
					set tTargetValue = $g(tDistribution("value",2,+tTargetValueId))
					
					// optionally do some bootstrapping to adjust tScore and tConfidence/tCoverage (?)
					
					set:..SplitScoringAlgorithm="Confidence" tScore = tConfidence
					set pSplits($i(pSplits)) = $lb(tScore, tRowTotal/tTotalCount, tTargetValue, tConfidence, tRowTotal, tIsLeaf)
					set pSplits(pSplits, "condition") = $lb(tField.Name, "=", tFieldValue)
					
					if (..TrackDistributions) {
						set j = ""
						for {
							set j = $order(tTrack(j),1,tCount)
							quit:j=""
							continue:'tCount
							set tTargetValue = tDistribution("value",2,j)
							set tTargetValue = $s(tTargetValue="":$c(0), 1:tTargetValue)
							set pSplits(pSplits, "distribution", tTargetValue) = tCount
						}
					}
				}
				
			} else { // optype="continuous" or optype="ordinal"
				
				// simple implementation: find the average of each target category and then
				// look for the one which has the greatest distance between its average
				// and the weighted average of the other category averages. Then use the value
				// in the middle of these two numbers as the split point.
				set tSC = ..Dataset.GetAggregatesByCategory(tFieldName, ..TargetField, .tAggregates, .tFilters)
				quit:$$$ISERR(tSC)
				
				kill tAvgDistance
				set tTotalCount = 0
				for i = 1:1:tAggregates {
					
					set tAverage = $lg(tAggregates(i),3)
					set tTotalCount = tTotalCount + $lg(tAggregates(i),2)
					
					set tWeightedAverage = 0, tWeightedCount = 0
					for j = 1:1:tAggregates {
						continue:i=j
						set tWeightedAverage = tWeightedAverage + ($lg(tAggregates(j),3) * $lg(tAggregates(j),7))
						set tWeightedCount = tWeightedCount + $lg(tAggregates(j),7)
					}
					set tWeightedAverage = $s(tWeightedCount:tWeightedAverage / tWeightedCount, 1:0)
					
					set tAvgDistance(-$zabs(tAverage - tWeightedAverage), i) = $lb(tFieldName, $s(tAverage<tWeightedAverage:"<", 1:">"), (tAverage + tWeightedAverage) / 2)
				}
				
				set tBestDistance = $order(tAvgDistance(""))
				continue:tBestDistance=""
				set tBestCategoryId = $order(tAvgDistance(tBestDistance, ""), 1, tSplitCondition)
				set tTargetValue = $li(tAggregates(tBestCategoryId),1)
				set pSplits($i(pSplits), "condition") = tSplitCondition
				
				// now analyze the impact of this split
				kill tNewFilter
				merge tNewFilter = tFilters
				do ..MergeFilters(.tNewFilter, tSplitCondition)
				set tSC = ..Dataset.Get1DDistribution(..TargetField, .tDistribution, .tNewFilter)
				quit:$$$ISERR(tSC)
				set tRowTotal = tDistribution("total")
				set tIsLeaf = (tDistribution=1)
				set tScore = $case(..SplitScoringAlgorithm, "GiniImpurity":1, :0)
				for i = 1:1:tDistribution {
					set tValue = $li(tDistribution(i),1)
					set tCount = $li(tDistribution(i),2)
					set:(tValue=tTargetValue) tConfidence = tCount/tRowTotal
					
					set tFreq = tCount/tRowTotal
					if (..SplitScoringAlgorithm = "GiniImpurity") {
						set tScore = tScore - (tFreq**2)
					} elseif (..SplitScoringAlgorithm = "InformationGain") {
						set tScore = tScore - (tFreq * $zlog(tFreq)/$zlog(2))
					}
					
					if (..TrackDistributions) {
						set tValueIndex = $s(tValue="":$c(0), 1:tValue)
						set pSplits(pSplits, "distribution", tValueIndex) = tCount
					}
				}
				
				set:..SplitScoringAlgorithm="Confidence" tScore = tConfidence
				//pSplits(n) = $lb(score, coverage, targetValue, confidence, isLeaf)
				set pSplits(pSplits) = $lb(tScore, tRowTotal/tTotalCount, tTargetValue, tConfidence, tRowTotal, tIsLeaf)
				
			}
		}
	
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="Print">
<Description><![CDATA[
Prints the tree (starting with <var>pNode</var>) to the terminal.]]></Description>
<FormalSpec>pNode:%Integer=0,pLevel:%Integer=0,pPrintDistribution:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// indent by level
	for i = 1:1:pLevel {
		write $c(9)
	}
	
	// derive condition string
	kill tConditionTree
	merge tConditionTree = ..Tree(pNode,"condition")
	set tCondition = ..GetCondition(.tConditionTree)
	kill tConditionTree
	
	// print node
	set tInfo = ..Tree(pNode)
	write $s(pNode:pNode_": "_tCondition, 1:"<Root node>")
	write " => [",$lg(tInfo,2),"] @ ",$normalize($lg(tInfo,3)*100,2),"% of ",+$lg(tInfo,4)
	write:$lg(tInfo,5) " (leaf)"
	write !
	
	// print distribution
	if (pPrintDistribution) && ($o(..Tree(pNode, "distribution", ""))'="") {
		for i = 1:1:pLevel { write $c(9) }
		write $s(pNode>99:"     ", pNode>9:"    ", 1:"   ")
		write "distribution:"
		set tTargetValue = ""
		for {
			set tTargetValue = $order(..Tree(pNode, "distribution", tTargetValue), 1, tCount)
			quit:tTargetValue=""
			write " [",$replace(tTargetValue,$c(0),""""""),": ",tCount,"]"
		}
		write !
	}
	
	// print child nodes
	set tChild = ""
	for {
		set tChild = $order(..Tree(pNode, "ch", tChild))
		quit:tChild=""
		do ..Print(tChild, pLevel+1, pPrintDistribution)
	}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="GetCondition">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pArray]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	quit:'$d(pArray, tValue) "<True>"
	if $listvalid(tValue) {
		set tOperator = ##class(%DeepSee.PMML.Definition.Util.SimplePredicate).SymbolFromOperator($li(tValue,2))
		quit "("_$li(tValue,1)_" "_tOperator_" "_$$$QUOTE($li(tValue,3))_")"
	} else {
		set tCondition=""
		set i = ""
		for {
			set i = $order(pArray(i))
			quit:i=""
			kill tSubArray
			merge tSubArray = pArray(i)
			set tCondition = tCondition _ $lb(..GetCondition(.tSubArray))
		}
		set tCondition = "("_$lts(tCondition," "_tValue_" ")_")"
		quit tCondition
	}
]]></Implementation>
</Method>

<Method name="GetFieldList">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pArray]]></FormalSpec>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	quit:'$d(pArray, tValue) ""
	if $listvalid(tValue) {
		quit $lb($li(tValue,1))
	} else {
		set tList=""
		set i = ""
		for {
			set i = $order(pArray(i))
			quit:i=""
			kill tSubArray
			merge tSubArray = pArray(i)
			set tSubList = ..GetFieldList(.tSubArray)
			for j = 1:1:$ll(tSubList) {
				set tItem = $li(tSubList,j)
				set:$lf(tList,tItem) tList = tList _ $lb(tItem)
			}
		}
		quit tList
	}
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Utils">
<Description>
This class bundles a number of utility methods for running PMML models and managing their results.</Description>
<IncludeCode>%DeepSee,%PMML</IncludeCode>
<System>4</System>
<TimeCreated>62776,52614.696031</TimeCreated>

<Method name="CreateFromFile">
<Description><![CDATA[
Creates a PMML definition class (<class>%DeepSee.PMML.Definition</class>) based on the 
PMML definition XML in the supplied <var>pFile</var>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFile:%String,pClassName:%String,pOverwrite:%Boolean=1,pCompile:%Boolean=1,pVerbose:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tStream = ##class(%Stream.FileCharacter).%New()
	set tSC = tStream.LinkToFile(pFile)
	quit:$$$ISERR(tSC) tSC
	quit:'tStream.Size $$$ERROR($$$GeneralError, "File '"_pFile_"' does not contain a valid PMML definition")
	quit ..CreateFromStream(tStream, pClassName, pOverwrite, pCompile, pVerbose)
]]></Implementation>
</Method>

<Method name="CreateFromStream">
<Description><![CDATA[
Creates a PMML definition class (<class>%DeepSee.PMML.Definition</class>) based on the 
PMML definition XML in the supplied <var>pStream</var>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pStream:%Stream.Object,pClassName:%String,pOverwrite:%Boolean=1,pCompile:%Boolean=1,pVerbose:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		if ('$isobject(pStream)) || 'pStream.%IsA("%Stream.Object") {
			set tSC = $$$ERROR($$$GeneralError, "Supplied input is not a %Stream.Object")
			quit
		}
		
		if '$zname(pClassName,4) {
			set tSC = $$$ERROR($$$ClassNameInvalid, pClassName)
			quit
		}
		
		if $$$defClassDefined(pClassName) {
			if 'pOverwrite {
				set tSC = $$$ERROR($$$ClassNameExists, pClassName)
				quit
			} else {
				set tSC = $$Delete^%apiOBJ(pClassName, "-d")
				quit:$$$ISERR(tSC)
			}
		}
		
		set tClass = ##class(%Dictionary.ClassDefinition).%New()
		set tClass.Name = pClassName
		set tClass.Super = "%DeepSee.PMML.Definition"
		set tClass.ProcedureBlock = 1
		
		set tXData = ##class(%Dictionary.XDataDefinition).%New()
		set tXData.Name = "PMML"
		set tXData.XMLNamespace = "http://www.intersystems.com/deepsee/pmml"
		set tSC = tXData.Data.CopyFromAndSave(pStream)
		quit:$$$ISERR(tSC)
		do tClass.XDatas.Insert(tXData)
		
		set tSC = tClass.%Save()
		quit:$$$ISERR(tSC)
		
		set (tClass,tXData) = ""
		
		if (pCompile) {
			set tSC = $system.OBJ.Compile(pClassName, "c"_$s(pVerbose:"d", 1:"-d"))
			if $$$ISERR(tSC) { // clean up if compile fails
				set x = $$Delete^%apiOBJ(pClassName, "-d")
			}
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="CreateFromString">
<Description><![CDATA[
Creates a PMML definition class (<class>%DeepSee.PMML.Definition</class>) based on the 
PMML definition XML in the supplied <var>pString</var>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pString:%String,pClassName:%String,pOverwrite:%Boolean=1,pCompile:%Boolean=1,pVerbose:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		if '$zname(pClassName,4) {
			set tSC = $$$ERROR($$$ClassNameInvalid, pClassName)
			quit
		}
		
		if $$$defClassDefined(pClassName) {
			if 'pOverwrite {
				set tSC = $$$ERROR($$$ClassNameExists, pClassName)
				quit
			} else {
				set tSC = $$Delete^%apiOBJ(pClassName, "-d")
				quit:$$$ISERR(tSC)
			}
		}
		
		set tClass = ##class(%Dictionary.ClassDefinition).%New()
		set tClass.Name = pClassName
		set tClass.Super = "%DeepSee.PMML.Definition"
		set tClass.ProcedureBlock = 1
		
		set tXData = ##class(%Dictionary.XDataDefinition).%New()
		set tXData.Name = "PMML"
		set tXData.XMLNamespace = "http://www.intersystems.com/deepsee/pmml"
		set tSC = tXData.Data.Write(pString)
		quit:$$$ISERR(tSC)
		do tClass.XDatas.Insert(tXData)
		
		set tSC = tClass.%Save()
		quit:$$$ISERR(tSC)
		
		set (tClass,tXData) = ""
		
		if (pCompile) {
			set tSC = $system.OBJ.Compile(pClassName, "c"_$s(pVerbose:"d", 1:"-d"))
			if $$$ISERR(tSC) { // clean up if compile fails
				set x = $$Delete^%apiOBJ(pClassName, "-d")
			}
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%RunModel">
<Description><![CDATA[
<p>Test a DeepSee or SQL-linked PMML model by running the model against all records in the 
Data Source <var>pDatasource</var> specified in the model definition, defaulting to the first
datasource definition found in the model.</p>
<p>Use <var>pResultsClass</var> to define the class (subclass of <class>%DeepSee.PMML.Utils.Result</class>)
the results of this batch run will be written to. This defaults to <class>%DeepSee.PMML.Utils.TempResult</class>,
which stores its data in the Temp database and therefore gets purged upon restarting the instance.<br/>
Results will be stored with their TestId property set to the value of <var>pResultsId</var> if
a nonzero, non-null value is provided, or call the GetNewTestId() method of <var>pResultsClass</var> to generate a new one.<br/>
If <var>pTracking</var> is true, progress information will be written to ^IRIS.Temp.PMML.BgrTask($job),
so this method can be run in the background.</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pResultsId:%Integer,pDefinitionClass:%String,pModelName:%String="",pDataSource:%String="",pResultsClass:%String="%DeepSee.PMML.Utils.TempResult",pTracking:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tModelClass = $classmethod(pDefinitionClass, "%GetModelClassName", .pModelName)
		if (tModelClass="") {
			set tSC = $$$ERROR($$$GeneralError, pDefinitionClass_" does not contain a model named '"_pModelName_"'")
			quit
		}
		
		set tPredictedField = $classmethod(tModelClass, "%GetPredictedField")
		if (tPredictedField="") {
			set tSC = $$$ERROR($$$GeneralError, "could not identify target field for model '"_tModelClass_"'")
			quit
		}
		
		#dim tModel As %DeepSee.PMML.Model.AbstractModel
		set tModel = $classmethod(tModelClass, "%New")
		set tDataClass = tModel.%GetDataClassName()
		
		set tOutputClass = tModel.%GetOutputClassName()
		set tInputClass = tModel.%GetInputClassName()
		
		#dim tDataset As %DeepSee.PMML.Dataset
		set tSC = $classmethod(pDefinitionClass, "%CreateDataset", pDataSource, .tDataset)
		quit:$$$ISERR(tSC)
		
		// derive predicted field spec and SQL
		if (tDataset.%IsA("%DeepSee.PMML.Dataset.SQL")) {
			
			set tSQLQuery = tDataset.SQL, tIsSQL = 1
			set tTargetFieldCol = $classmethod(tDataClass, "%GetResultSetColumn", tPredictedField, pDataSource)
			
		} elseif (tDataset.%IsA("%DeepSee.PMML.Dataset.Cube")) {
			
			set tIsSQL = 0, tField = tDataset.Fields.GetAt(tPredictedField)
			set tSC = ##class(%DeepSee.PMML.Utils.DeepSee).GetFactPropertyForSpec(tDataset.CubeName, tField.Spec, 1, .tFieldSQL)
			quit:$$$ISERR(tSC)
				
			set tSQLQuery = "SELECT ID, CASE " _ tFieldSQL _ " WHEN '"_$$$DeepSeeNullMarker_"' THEN NULL ELSE " _ tFieldSQL _ " END Result FROM "_##class(%DeepSee.Utils).%GetCubeFactTable(tDataset.CubeName)
			set tTargetFieldCol = "Result"
			
		} else {
			set tSC = $$$ERROR($$$GeneralError, "DataSource does not support validation: '"_pDataSource_"'")
			quit
		}
		
		if (pTracking) {
			set tTaskId = +$job
			set tStatement = ##class(%SQL.Statement).%New()
			set tSC = tStatement.%Prepare("SELECT COUNT(*) FROM ("_tSQLQuery_")")
			quit:$$$ISERR(tSC)
			set tResultSet = tStatement.%Execute()
			if tResultSet.%Next() {
				set tTotal = tResultSet.%GetData(1)
			} else {
				set tTotal = 0
			}
			kill ^IRIS.Temp.PMML.BgrTask(tTaskId,"track")
			set ^IRIS.Temp.PMML.BgrTask(tTaskId,"track","start") = $zh
			set ^IRIS.Temp.PMML.BgrTask(tTaskId,"track","total") = tTotal
			set ^IRIS.Temp.PMML.BgrTask(tTaskId,"track","done") = 0
		}
		
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare(tSQLQuery)
		quit:$$$ISERR(tSC)
		
		set tResultSet = tStatement.%Execute()
		
		set:($g(pResultsId)="")||($g(pResultsId)=0) pResultsId = $classmethod(pResultsClass, "GetNewTestId")
		set tIdField = $s($isobject(tDataset.IdField):tDataset.IdField.Spec, 1:"")
		
		set tCount = 0
		while tResultSet.%Next() {
			set tCount = tCount+1
		
			// get actual and predicted values for SQLquery result record
			set tActualValue = tResultSet.%Get(tTargetFieldCol)
			
			if (tIsSQL) {
				set tSC = $classmethod(tDataClass, "%CreateFromResultSet", tResultSet, .tInput,, pDataSource)
				quit:$$$ISERR(tSC)
			} else {
				set tSC = $classmethod(tDataClass, "%CreateFromDeepSee", tResultSet.%Get("ID"), .tInput, pDataSource)
				quit:$$$ISERR(tSC)
			}
			
			set tSC = tModel.%ExecuteModel(tInput, .tOutput)
			quit:$$$ISERR(tSC)
			
			set tPredictedValue = tOutput.%GetFeatureValue("predictedValue", tPredictedField)
			set tProbability = tOutput.%GetFeatureValue("probability", tPredictedField)
			
			
			set tResult = $classmethod(pResultsClass, "%New")
			set tResult.TestId = pResultsId
			set tResult.ModelClass = tModelClass
			set tResult.ActualValue = tActualValue
			set tResult.PredictedValue = tPredictedValue
			set tResult.Probability = tProbability
			set tResult.PredictTime = $zdt($ztimestamp,3)
			set tResult.TestRecordId = $s('tIsSQL:tResultSet.%Get("ID"), tIdField="":tCount, 1:tResultSet.%Get(tIdField))
			set tSC = tResult.%Save()
			quit:$$$ISERR(tSC)
			
			set:pTracking&&'(tCount#10) ^IRIS.Temp.PMML.BgrTask(tTaskId,"track","done") = tCount
			
		}
		quit:$$$ISERR(tSC)
		
		set:pTracking ^IRIS.Temp.PMML.BgrTask(tTaskId,"track","done") = tCount
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%RunModelFromResultSet">
<Description><![CDATA[
<p>Runs a PMML model against all records returned by a user-supplied ResultSet object, looping
through all rows and checking the model outcome against the actual value found in the query result. 
<var>pFieldMap</var> is expected to contain a mapping from this model's <class>%DeepSee.PMML.Data</class>
class to the columns (by name) in the supplied result set. If no field map is specified, 
the resultset is expected to contain columns with names corresponding to the models data fields.</p>
<p>Use <var>pResultsClass</var> to define the class (subclass of <class>%DeepSee.PMML.Utils.Result</class>)
the results of this batch run will be written to. This defaults to <class>%DeepSee.PMML.Utils.TempResult</class>,
which stores its data in the Temp database and therefore gets purged upon restarting the instance.<br/>
Results will be stored with their TestId property set to the value of <var>pResultsId</var> if
a nonzero, non-null value is provided, or call the GetNewTestId() method of <var>pResultsClass</var> to generate a new one.<br/>
If <var>pTracking</var> is true, progress information will be written to ^IRIS.Temp.PMML.BgrTask($job),
so this method can be run in the background.</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pResultsId:%Integer,pDefinitionClass:%String,pModelName:%String="",pResultSet:%ResultSet,&pFieldMap,pResultsClass:%String="%DeepSee.PMML.Utils.TempResult",pTracking:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tModelClass = $classmethod(pDefinitionClass, "%GetModelClassName", .pModelName)
		if (tModelClass="") {
			set tSC = $$$ERROR($$$GeneralError, pDefinitionClass_" does not contain a model named '"_pModelName_"'")
			quit
		}
		set tDataClass = $classmethod(pDefinitionClass, "%GetDataClassName")
		
		set tPredictedField = $classmethod(tModelClass, "%GetPredictedField")
		if (tPredictedField="") {
			set tSC = $$$ERROR($$$GeneralError, "Could not identify target field for model '"_tModelClass_"'")
			quit
		}
		set tTargetFieldCol = $g(pFieldMap(tPredictedField),tPredictedField)
		if '$d(pResultSet.%GetMetadata().columnIndex($$$UPPER(tTargetFieldCol))) {
			set tSC = $$$ERROR($$$GeneralError, "Test result set does not select the target field for this model: '"_tTargetFieldCol_"'")
			quit
		}
		
		set tIDFieldCol = $g(pFieldMap("_ID"),"_ID")
		set tHasIDField = $d(pResultSet.%GetMetadata().columnIndex(tIDFieldCol))
		
		// if pFieldMap is empty, ensure it has data so pFieldMap will take precedence over
		// the default DataSource in %CreateFromResultSet
		set:'$d(pFieldMap) pFieldMap = 1
		
		if (pTracking) {
			set tTaskId = +$job
			set gBgrData = $name(^IRIS.Temp.PMML.BgrTask(tTaskId,"track"))
			
			// we cannot get the total number of rows for this pResultSet,
			// except if this comes from a %RunModelFromSQL call
			set tTotal = $s('$d(@gBgrData@("done")):$g(@gBgrData@("total"),-1), 1:-1)
			
			kill @gBgrData
			set @gBgrData@("start") = $zh
			set @gBgrData@("total") = tTotal
			set @gBgrData@("done") = 0
		}
		
		#dim tModel As %DeepSee.PMML.Model.AbstractModel
		set tModel = $classmethod(tModelClass, "%New")
		
		set:($g(pResultsId)="")||($g(pResultsId)=0) pResultsId = $classmethod(pResultsClass, "GetNewTestId")
		
		set tCount = 0
		while pResultSet.%Next() {
			set tCount = tCount+1
		
			// get actual and predicted values for SQLquery result record
			set tActualValue = pResultSet.%Get(tTargetFieldCol)
			
			set tSC = $classmethod(tDataClass, "%CreateFromResultSet", pResultSet, .tInput, .pFieldMap)
			quit:$$$ISERR(tSC)
			
			set tSC = tModel.%ExecuteModel(tInput, .tOutput)
			quit:$$$ISERR(tSC)
			
			set tPredictedValue = tOutput.%GetFeatureValue("predictedValue", tPredictedField)
			set tProbability = tOutput.%GetFeatureValue("probability", tPredictedField)
			
			
			set tResult = $classmethod(pResultsClass, "%New")
			set tResult.TestId = pResultsId
			set tResult.ModelClass = tModelClass
			set tResult.ActualValue = tActualValue
			set tResult.PredictedValue = tPredictedValue
			set tResult.Probability = tProbability
			set tResult.PredictTime = $zdt($ztimestamp,3)
			set tResult.TestRecordId = $s(tHasIDField:pResultSet.%Get(tIDFieldCol), 1:tCount)
			set tSC = tResult.%Save()
			quit:$$$ISERR(tSC)
			
			set:pTracking&&'(tCount#10) ^IRIS.Temp.PMML.BgrTask(tTaskId,"track","done") = tCount
		}
		quit:$$$ISERR(tSC)
		
		set:pTracking ^IRIS.Temp.PMML.BgrTask(tTaskId,"track","done") = tCount
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%RunModelFromSQL">
<Description><![CDATA[
<p>Runs a PMML model against all records returned by a user-supplied SQL query, looping through
the rows and checking the model outcome against the actual value found in the query result. 
<var>pFieldMap</var> is expected to contain a mapping from this model's <class>%DeepSee.PMML.Data</class>
class to the columns (by name) in the supplied result set. If no field map is specified, 
the resultset is expected to contain columns with names corresponding to the models data fields.</p>
<p>Use <var>pResultsClass</var> to define the class (subclass of <class>%DeepSee.PMML.Utils.Result</class>)
the results of this batch run will be written to. This defaults to <class>%DeepSee.PMML.Utils.TempResult</class>,
which stores its data in the Temp database and therefore gets purged upon restarting the instance.<br/>
Results will be stored with their TestId property set to the value of <var>pResultsId</var> if
a nonzero, non-null value is provided, or call the GetNewTestId() method of <var>pResultsClass</var> to generate a new one.<br/>
If <var>pTracking</var> is true, progress information will be written to ^IRIS.Temp.PMML.BgrTask($job),
so this method can be run in the background.</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pResultsId:%Integer,pDefinitionClass:%String,pModelName:%String="",pSQL:%String,&pFieldMap,&pSQLParams,pResultsClass:%String="%DeepSee.PMML.Utils.TempResult",pTracking:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		if (pTracking) {
			set tTaskId = +$job
			set tStatement = ##class(%SQL.Statement).%New()
			set tSC = tStatement.%Prepare("SELECT COUNT(*) FROM ("_pSQL_")")
			quit:$$$ISERR(tSC)
			set tResultSet = tStatement.%Execute(pSQLParams...)
			if tResultSet.%Next() {
				set tTotal = tResultSet.%GetData(1)
			} else {
				set tTotal = 0
			}
			
			// just set the total, further status info will be handled by %RunModelFromResultSet()
			kill ^IRIS.Temp.PMML.BgrTask(tTaskId,"track")
			set ^IRIS.Temp.PMML.BgrTask(tTaskId,"track","total") = tTotal
		}
		
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare(pSQL)
		quit:$$$ISERR(tSC)
		
		kill %objlasterror
		set tResultSet = tStatement.%Execute(pSQLParams...)
		set tSC = $g(%objlasterror, $$$OK)
		quit:$$$ISERR(tSC)
		
		set tSC = ..%RunModelFromResultSet(.pResultsId, pDefinitionClass, pModelName, .tResultSet, .pFieldMap, pResultsClass, pTracking)
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%RunModelFromPMMLRows">
<Description><![CDATA[
<p>Runs a PMML model against the &lt;ModelVerification&gt; records included in the PMML model
definition.</p>
<p>Use <var>pResultsClass</var> to define the class (subclass of <class>%DeepSee.PMML.Utils.Result</class>)
the results of this batch run will be written to. This defaults to <class>%DeepSee.PMML.Utils.TempResult</class>,
which stores its data in the Temp database and therefore gets purged upon restarting the instance.<br/>
Results will be stored with their TestId property set to the value of <var>pResultsId</var> if
a nonzero, non-null value is provided, or call the GetNewTestId() method of <var>pResultsClass</var> to generate a new one.<br/>
If <var>pTracking</var> is true, progress information will be written to ^IRIS.Temp.PMML.BgrTask($job),
so this method can be run in the background.</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pResultsId:%Integer,pDefinitionClass:%String,pModelName:%String="",pResultsClass:%String="%DeepSee.PMML.Utils.TempResult",pTracking:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tModelClass = $classmethod(pDefinitionClass, "%GetModelClassName", .pModelName)
		if (tModelClass="") {
			set tSC = $$$ERROR($$$GeneralError, pDefinitionClass_" does not contain a model named '"_pModelName_"'")
			quit
		}
		
		set tPredictedField = $classmethod(tModelClass, "%GetPredictedField")
		if (tPredictedField="") {
			set tSC = $$$ERROR($$$GeneralError, "Could not identify target field for model '"_tModelClass_"'")
			quit
		}
		
		#dim tModel As %DeepSee.PMML.Model.AbstractModel
		set tModel = $classmethod(tModelClass, "%New")
		set tDataClass = tModel.%GetDataClassName()
		
		set tOutputClass = tModel.%GetOutputClassName()
		set tInputClass = tModel.%GetInputClassName()
		
		// build array from ModelVerification records
		#dim tModelVerification As %DeepSee.PMML.Definition.ModelVerification
		set tSC = tModel.%GetDefinition(.tModelDef)
		quit:$$$ISERR(tSC)
		
		if '$isobject(tModelDef.ModelVerification) {
			set tSC = $$$ERROR($$$GeneralError, "Model '"_pModelName_"' has no ModelVerification element")
			quit
		}
		
		set tModelVerification = tModelDef.ModelVerification
		for i = 1:1:tModelVerification.fieldCount {
			set tVerificationField = tModelVerification.Fields.Fields.GetAt(i)
			set tFields($s(tVerificationField.column="":tVerificationField.field, 1:tVerificationField.column)) = tVerificationField.field
		}
		
		set tSC = tModelVerification.InlineTable.%GetRows(.tRows)
		quit:$$$ISERR(tSC)
		
		if (pTracking) {
			set tTaskId = +$job
			kill ^IRIS.Temp.PMML.BgrTask(tTaskId,"track")
			set ^IRIS.Temp.PMML.BgrTask(tTaskId,"track","start") = $zh
			set ^IRIS.Temp.PMML.BgrTask(tTaskId,"track","total") = tModelVerification.recordCount
			set ^IRIS.Temp.PMML.BgrTask(tTaskId,"track","done") = 0
		}
		
		set:($g(pResultsId)="")||($g(pResultsId)=0) pResultsId = $classmethod(pResultsClass, "GetNewTestId")
		
		for i = 1:1:tModelVerification.recordCount {
			kill tRecord
			set tColumn = ""
			for {
				set tColumn = $order(tRows(i,tColumn),1,tValue)
				quit:tColumn=""
				set tRecord(tFields(tColumn)) = tValue
			}
			set tActualValue = $g(tRecord(tPredictedField))
			
			set tInput = $classmethod(tDataClass, "%CreateFromArray", .tRecord, .tSC)
			quit:$$$ISERR(tSC)
			
			set tSC = tModel.%ExecuteModel(tInput, .tOutput)
			quit:$$$ISERR(tSC)
			
			set tPredictedValue = tOutput.%GetFeatureValue("predictedValue", tPredictedField)
			set tProbability = tOutput.%GetFeatureValue("probability", tPredictedField)
			
			set tResult = $classmethod(pResultsClass, "%New")
			set tResult.TestId = pResultsId
			set tResult.ModelClass = tModelClass
			set tResult.ActualValue = tActualValue
			set tResult.PredictedValue = tPredictedValue
			set tResult.Probability = tProbability
			set tResult.PredictTime = $zdt($ztimestamp,3)
			set tResult.TestRecordId = i
			set tSC = tResult.%Save()
			quit:$$$ISERR(tSC)
			
			set:pTracking&&'(i#10) ^IRIS.Temp.PMML.BgrTask(tTaskId,"track","done") = i
		}
		quit:$$$ISERR(tSC)
		
		set:pTracking ^IRIS.Temp.PMML.BgrTask(tTaskId,"track","done") = tModelVerification.recordCount
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%DropResults">
<Description><![CDATA[
Drops all results for a given test ID from the <class>%DeepSee.PMML.Utils.TempResult</class>
table.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestId:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare("DELETE FROM %DeepSee_PMML_Utils.TempResult WHERE TestId = "_pTestId)
		quit:$$$ISERR(tSC)
		
		kill %objlasterror
		do tStatement.%Execute()
		set tSC = $g(%objlasterror,$$$OK)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%DropAllResults">
<Description><![CDATA[
Drops all results for all test IDs from the <class>%DeepSee.PMML.Utils.TempResult</class>
table.]]></Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		set tSC = ##class(%DeepSee.PMML.Utils.TempResult).%KillExtent()
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%DeepSee.PMML.Utils.iKnow.DirectInput">
<Hidden>1</Hidden>
<Super>%iKnow.DirectInput</Super>
<System>4</System>
<TimeCreated>62881,40266.75249</TimeCreated>

<Property name="Entities">
<Description>
..Entities([value]) = [ent ID]
..Entities([hash],i) = $lb([ent ID], [value])</Description>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="CRCs">
<Description>
..CRCs([master ID], [slave ID], [relation ID]) = [crc id]</Description>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="Frequencies">
<Description>
..Frequencies([$case(type, ent:0, crc:1), [ID]) = [freq]</Description>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="Sentences">
<Description>
..Sentence([sent], [ent ID]) = [pos]</Description>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="LiteralMap">
<Description>
..LiteralMap([lit ID]) = [ent ID]</Description>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<Private>1</Private>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	set tSC = ##super(0, 0)
    quit $$$OK
]]></Implementation>
</Method>

<Method name="Finalize">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill ..Entities, ..Frequencies, ..Sentences, ..LiteralMap, ..CRCs
    quit $$$OK
]]></Implementation>
</Method>

<Method name="ProcessEntity">
<FormalSpec>SrcId:%Integer,Pos:%Integer,value:%String</FormalSpec>
<Implementation><![CDATA[
	quit:value=""
	if $l(value)>150 {
		set tHash = $zcrc(value,7)
		set ..Entities(tHash, $o(..Entities(tHash,""),-1)+1) = $lb(Pos, value)
	} else {
		set ..Entities(value) = Pos
	}
]]></Implementation>
</Method>

<Method name="ProcessFreq">
<FormalSpec>SrcId:%Integer,Pos:%Integer,value:%List</FormalSpec>
<Implementation><![CDATA[	set ..Frequencies(0, Pos) = $lg(value,1)+$lg(value,2)
]]></Implementation>
</Method>

<Method name="ProcessSrc">
<FormalSpec>SrcId:%Integer,value:%String</FormalSpec>
<Implementation><![CDATA[	kill ..Entities, ..Frequencies, ..Sentences, ..LiteralMap, ..CRCs
]]></Implementation>
</Method>

<Method name="GetFrequency">
<FormalSpec>pValue:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	quit:pValue="" 0
	quit $g(..Frequencies(0, ..GetEntityId(pValue)),0)
]]></Implementation>
</Method>

<Method name="GetCrcFrequency">
<FormalSpec>pMaster:%String,pRelation:%String,pSlave:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	set tMaster = ..GetEntityId(pMaster, 0)
	set tRelation = ..GetEntityId(pRelation, 0)
	set tSlave = ..GetEntityId(pSlave, 0)
	set tCrcId = $g(..CRCs(tMaster, tRelation, tSlave), -1)
	quit $g(..Frequencies(1, tCrcId), 0)
]]></Implementation>
</Method>

<Method name="GetCoocFrequency">
<FormalSpec>pEntities:%List</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	kill ids
	set l = $ll(pEntities), ok=1
	for i = 1:1:l {
		set id = ..GetEntityId($li(pEntities,i))
		if (id<=0) {
			set ok=0
			quit
		}
		set ids(i) = id
	}
	quit:'ok 0
	
	set s = "", freq = 0
	for {
		set s = $order(..Sentences(s))
		quit:s=""
		
		set c = 0
		for i=1:1:l {
			quit:'$d(..Sentences(s,ids(i)))
			set c = c + 1
		}
		set:c=l freq = freq+1
	}
	quit freq
]]></Implementation>
</Method>

<Method name="GetEntityId">
<FormalSpec>pValue:%String,pNotExistsValue:%Integer=-1</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	quit:pValue="" 0
	
	set tPos = pNotExistsValue
	if $l(pValue)>150 {
		set tHash = $zcrc(pValue,7)
		set i = ""
		for {
			set i = $order(..Entities(tHash, i), 1, tInfo)
			quit:i=""
			
			if $lg(tInfo,2)=pValue {
				set tPos = $lg(tInfo,1)
				quit
			}
		}
	} else {
		set tPos = $g(..Entities(pValue), pNotExistsValue)
	}
	quit tPos
]]></Implementation>
</Method>

<Method name="ProcessSentEnts">
<FormalSpec>SrcId:%Integer,SentId:%Integer,value:%List</FormalSpec>
<Implementation><![CDATA[
	set ptr = 0, pos = 0
	while $listnext(value,ptr,id) {
		set:id<0 id = ..LiteralMap(-id)
		set ..Sentences(SentId, id) = $i(pos)
	}
]]></Implementation>
</Method>

<Method name="ProcessLitEnt">
<FormalSpec>SrcId:%Integer,Pos:%Integer,value:%Integer</FormalSpec>
<Implementation><![CDATA[	set ..LiteralMap(Pos) = value
]]></Implementation>
</Method>

<Method name="ProcessCRC">
<FormalSpec>SrcId:%Integer,SentId:%Integer,Pos:%Integer,pValue:%List</FormalSpec>
<Implementation><![CDATA[	set x =$i(..Frequencies(1, +$lg(pValue,4)))
]]></Implementation>
</Method>

<Method name="ProcessCrcUni">
<FormalSpec>SrcId:%Integer,Pos:%Integer,value:%List</FormalSpec>
<Implementation><![CDATA[	set ..CRCs(+$lg(value,1), +$lg(value,2), +$lg(value,3)) = Pos
]]></Implementation>
</Method>
</Class>
</Export>
